MEAP Edition
Manning Early Access Program
Software Design in Python
Version 5
Copyright 2025 Manning Publications
For more information on this and other Manning titles go to manning.com.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

welcome
Thank you for purchasing the MEAP of my book, Software Design in Python. When I teach this course
to my university students, I tell them the goal is that by the end of the semester, they’ll all be much
better programmers. I want the same goal for my book; by the end of it, you’ll be a much better
programmer.
You should have the same “course prerequisites” — basic knowledge of object-oriented
programming in Python. The book’s examples use Python 3.12, but I tried to ensure that the design
techniques can apply to earlier versions of the language or to any other modern object-oriented
language. Each example program is simple to run on the command line.
How do you become a better programmer? The key is good software design. I teach design
principles and design patterns. Examples of design principles include Single Responsibility,
Encapsulation, Delegation, and Code to the Interface. Applying these principles will improve your
code when you’re solving common programming problems that you encounter as you develop an
application. Design patterns exist at a higher plane of software design, but they are based on the
design principles. Design patterns, such as the Observer Pattern and the Visitor Pattern, are
industry-proven solutions to common software architecture problems that you can adapt for your
applications. Well-designed software does what it’s supposed to do and is flexible, reliable,
maintainable, and costs less time and money.
The best way to teach and to learn is through examples. My book contains many “before” and
“after” programming examples. I first show a poorly design example and we discover its
shortcomings. Then I show an “after” version that uses a design principle or a design pattern and
highlight the benefits of the better design. I drew many diagrams to illustrate the good and bad
designs. Students often ask questions in my classes, and I’ve tried to capture the most common
ones with imagined Q and A conversations interspersed throughout the text. I teach practical
techniques and not abstract theoretical material.
Besides teaching this course successfully at the university level, my experience includes decades
of software development in both industry and scientific research. I was a senior scientist at NASA
and JPL where I designed and developed software for the Mars rovers and the Orion spacecraft. I
also had research and development positions at IBM Research and the Lawrence Livermore
National Laboratory. In my earlier career, I was a senior software developer and engineering
manager at various Silicon Valley companies such as Apple and Sun Microsystems. I have always
been passionate about good software design, and I hope that shows in my book writing.
With your help, I want to make this the best possible book. Please let me know what you think
and leave your comments and suggestions in the liveBook Discussion Forum. Explaining things well
is always a challenge for teachers and authors. Tell me how I did!
—Ronald Mak
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

brief contents
PART 1: INTRODUCTION
1 The path to well-designed software
2 Iterate to achieve good design
PART 2: DESIGN THE RIGHT APPLICATION
3 Get requirements to build the right application
4 Good class design to build the application right
PART 3: DESIGN THE APPLICATION RIGHT
5 Hide class implementations
6 Don’t surprise your users
7 Design subclasses right
PART 4: DESIGN PATTERNS SOLVE APPLICATION ARCHITECTURE PROBLEMS
8 The Template Method and Strategy Design Patterns
9 The Factory Method and the Abstract Factory Design Patterns
10 The Adapter and Façade Design Patterns
11 The Iterator and Visitor Design Patterns
12 The Observer Design Pattern
13 The State Design Pattern
14 The Singleton, Composite, and Decorator Design Patterns
PART 5: ADDITIONAL DESIGN TECHNIQUES
15 Designing solutions with recursion and backtracking
16 Designing multithreaded programs
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

1
1 The path to well-
designed software
This chapter covers
The basics of software design
The benefits of good software design
How to analyze an application’s requirements to design the right application
How to apply good design techniques to develop the application right
Well-designed programs do what they’re supposed to do. They are more reliable, flexible, and
maintainable. Furthermore, they are more easily tested and are often completed sooner than
poorly designed programs. Well-designed programs are simply better in many ways.
To improve your software design skills, this book will teach you the principles and patterns that
will enable you to develop well-designed sustainable applications. A sustainable application is an
application that has a long life, and therefore, we want it to be reliable, flexible, and maintainable.
Top-tier design skills are highly sought after by employers in today’s competitive job market. Your
career requires that you know and apply good software design techniques.
This book will improve your software design skills by teaching object-oriented design principles
and design patterns. Design principles help to improve the design of a few lines of code, a function,
an entire class, or a set of classes that work together. Design patterns provide models for solving
common software architecture problems. These are built on design principles. This book focuses on
Python, but you can use these skills in any modern object-oriented programming language.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

2
Achieving well-designed software is usually not a straightforward path. We first need to get the
application’s requirements, study them, and understand what the application is supposed to do.
Multiple development iterations are often necessary to achieve good design, possibly with some
backtracking to recover from bad design decisions. A well-designed application evolves from hard
work.
To get the most out of this book, you should be at least a beginning to intermediate Python
programmer. You should be familiar with basic data structures and their algorithms, and you
should understand object-oriented programming (OOP). Furthermore, you should be able to
program well enough to write simple applications and be able to edit, compile, debug, and run
them.
Because the techniques in this book for good design build on OOP concepts, we’ll review the
concepts briefly at the end of this chapter.
1.1 What is software design?
Design is a disciplined engineering approach to creating a solution to a problem. For software
developers, the solution is a successful application that meets its requirements. We practice
disciplined software engineering by applying the design techniques covered in this book to find the
best solution path from the requirements to a well-designed, sustainable application. These
techniques include design principles that improve our code and design patterns that help solve
common software architecture problems.
Good design principles can help eliminate bad surprises where code doesn’t behave as expected or
has poor performance. The principles help make our code more flexible and able to handle changes
such as new requirements. Design patterns operate at a higher level of design and are built from
the design principles. The patterns are industry-proven models for creating custom solutions to
common software architecture problems.
1.2 What you will learn from this book
This book is for beginner to intermediate software developers who want to learn good software
design skills. It will also benefit more experienced developers who need a refresher on good design.
By using many before-good-design and after-good-design program examples, this book will teach
you how to
Apply design principles to improve your code
Employ design patterns that are industry-proven models for solving common
software architecture problems
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

3
Gather, validate, and analyze the requirements for an application to ensure that
you write the right application and design it well
Develop a well-designed application iteratively and backtrack to recover from
bad design decisions
LEARN BY EXAMPLE
We learn best by example. It’s not always very effective if someone simply tells us to use a
certain design principle or design pattern. We want to see how and why the principle or
pattern makes a program better. We’ll try to justify each one with example applications.
“Before” and “after” programs will highlight the design improvements.
This book’s program examples are in Python, a very popular language for developing applications.
So that we can concentrate on the design principles and design patterns, the program examples will
use only basic features of the language.
NOTE The example programs in this book were tested with the 3.12 version of Python, although the
programs should work with earlier versions starting with Python 3.6.
1.3 The benefits of good software design
A sustainable application has a lifespan during which it is deployed, successfully used by its
customers, and continually maintained. New releases fix bugs and add new features as the
application’s requirements evolve. Good software design reliably creates sustainable applications.
On the other hand, an unsustainable application can devolve into an unmanageable tangle of
software “patches” to fix bugs and to add new features. At some point, no future programmer will
want to touch it.
NOTE Although an application may require multiple individual programs working cooperatively, each
example application in this book is relatively short and simple to make it easy to see the techniques
that it exemplifies. Therefore, we’ll often use the words application and program (referring to the
program that implements the application) interchangeably.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

4
We want to go beyond quick hacks and the just-get-it-done-on-time-no-matter-what style of
programming. Of course, there is nothing wrong with doing a quick hack whenever it’s appropriate.
Sometimes, you need your computer to do something, such as a short task to be done only once or
not very often, and if a line or two of code or a short script will get it done, go for it!
No one can argue against finishing an application on time. By designing an application well, we
can often complete it faster. A well-designed application evolves in a systematic manner. It attains
the minimum viable product (MVP) status sooner, where it passes tests and meets the minimum set
of requirements. If necessary, an MVP can be deployed as the application’s first release. A well-
designed application is easier to test, and it’s more flexible when you need to add features or make
other changes.
Our goal is to create well-designed applications that meet their requirements, are completed on
time, and are maintainable. Well-designed software
Meets its requirements—It does what it’s supposed to do.
Is reliable—It passes its tests and has fewer bugs.
Does what its users expect—When we call a function or create an object, we
should not be surprised by its result.
Is efficient—Does not have hidden runtime performance problems.
Is flexible and scalable—When requirements change, it is easy to add new
features without increasing the complexity of the software.
Enables collaboration—Developers can work together better and recover quicker
from bad design decisions.
Is maintainable—Well-designed code is more understandable by future de vel o -
pers.
Uses good design techniques—Good design techniques can improve the software
by, for example, simplifying code and removing repeated code.
Employs appropriate design patterns—Appropriate design patterns are industry- -
proven models for solving common software architecture problems.
Saves time and costs overall—Good design results in fewer mistakes and major
do- overs during development. Any extra time spent upfront to do good design
for a sustainable application will be compensated by decreased maintenance
time and costs after deployment and potentially a longer lifespan.
Is better code—You can be proud to develop good code.
1.4 A few design examples
Software design deals with many issues to improve our code. Here are a few illustrative examples.
This book covers many more design problems.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

5
1.4.1 Leaking changes
The bane of all programmers is making changes to one part of a program that then requires making
changes to other parts. The changes may cascade to rewriting most, if not all, of the program. The
following listing is an example Car class exhibiting this problem.
Listing 1.1 (Program 1.1 Changes): car.py (poorly designed)
class Car:
def step_on_brake(self):
print("Stepped on the brake.")
def insert_key(self):
print("Inserted the key.")
def turn_key(self):
print("Turned the key.")
def step_on_accelerator(self):
print("Stepped on the accelerator.")
In listing 1.2, class Driver uses class Car.
Listing 1.2 (Program 1.1 Changes): driver.py (poorly designed)
class Driver:
def __init__(self, c):
self._car = c
def start_car(self):
self._car.step_on_brake()
self._car.insert_key()
self._car.turn_key()
self._car.step_on_accelerator()
If we aim later for more modern cars, we replace
def insert_key():
def turn_key():
with
def press_start_button():
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

6
In class Car, we would be forced to make changes to class Driver. The changes we make in class Car
leaked into class Driver. This problem becomes more acute in larger programs where you may not
easily detect where leaks occurred. As we’ll see in examples throughout this book, good software
design helps to prevent such leaks by reducing dependencies among classes.
1.4.2 Code that’s too complex
Class Automobile is complex because it tries to do too much. If something goes wrong, it will be
harder to find the bug.
Listing 1.3 (Program 1.2 Changes): automobile.py (poorly designed)
class Automobile:
def __init__(self):
self._brakes = []
self._engine = None
self._engine_oil = None
self._heading = None
self._headlights = []
self._speed = None
self._soap = None
self._tires = []
self._vacuum_cleaner = None
def accelerate(self):
print("Accelerating.")
def adjust_headlights(self):
print("Adjusting headlights.")
def apply_brakes(self):
print("Applying brakes.")
def change_oil(self):
print("Changing oil.")
def change_tires(self):
print("Changing tires.")
def check_brakes(self):
print("Checking brakes.")
def check_tires(self):
print("Checking tires.")
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

7
def rotate_tires(self):
print("Rotating tires.")
def shut_off_engine(self):
print("Shutting off engine.")
def start_engine(self):
print("Starting engine.")
def tuneup_engine(self):
print("Tuning up engine.")
def turn_left(self):
print("Turning left.")
def turn_right(self):
print("Turning right.")
def vacuum_car(self):
print("Vacuuming car.")
def wash_car(self):
print("Washing car.")
def wax_car(self):
print("Waxing car.")
The examples throughout this book show ways to avoid this very common problem by designing
each class to have only one major responsibility.
Proliferation of classes is another way programs become too complex. Figure 1.1 illustrates how
this can easily get out of hand.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

8
Figure 1.1 A hierarchy of classes and subclasses. Does it have to be so complex? Good design techniques can
simplify this data.
Do we really need all those classes? Excessive subclasses can add extra dependencies and make the
code harder to understand and debug. Good design can help to eliminate unnecessary classes from
a program. However, sometimes applying good design techniques means adding classes to make a
program more flexible. We’ll see examples of both.
1.4.3 Inflexible code
Suppose we have an application that has class Pet with two subclasses Cat and Dog.
Listing 1.4 (Program 1.3 Inflexible): pet.py
class Pet:
def id(self):
return ''
class Cat(Pet):
def id(self):
return 'cat'
class Dog(Pet):
def id(self):
return 'dog'
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

9
Further, let’s suppose that in another part of the application, we have the statements
pet = Cat()
print(f'My pet is a {pet.id()}.')
The assignment statement is inflexible. What if later we need the variable pet to point to a pet Dog
object? Or what if we added Hamster and Goldfish subclasses, and we wanted to refer to those
types of pets? We would have to modify the source code containing the previous statement because
we decided that we would only refer to a cat when we wrote the statement. This is known as
hardcoding—we froze decisions when we wrote the code.
We’ll see how good design techniques encourage us to write flexible code where decisions (such
as which type of Pet object to refer to) can be made dynamically during run time.
1.4.4 Surprise!
If we write poorly designed code, that code may harbor nasty surprises for other programmers who
use it, especially if the surprise is incorrect results. An example is the following Date class.
Listing 1.5 (Program 1.4 Surprise): date.py (poorly designed)
class Date:
_MONTH_NAMES = [
'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN',
'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'
]
def __init__(self, y, m, d):
self._year = y
self._month = m
self._day = d
def __str__(self):
return f'{Date._MONTH_NAMES[self._month]} ' \
f'{self._day}, {self._year}'
The main program creates and prints a date string in the following listing.
Listing 1.6 (Program 1.4 Surprise): main.py
from date import Date
if __name__ == '__main__':
birthday = Date(2025, 9, 2) # SEP 2, 2025
print(birthday)
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

10
What date string does the program print?
As many of our example programs demonstrate in this book, a well-designed program does what
it’s supposed to do and doesn’t have surprises.
1.4.5 Common architecture problems
Programmers often encounter software architecture problems that are actually quite common.
Design patterns provide models for developing custom solutions to many of these problems. For
example, consider the situation where an application component, known as the publisher,
produces data, and other application components, known as the subscribers, consume the data
(figure 1.2). We’ll see later in the book how the Observer Design Pattern provides a model for us to
develop a solution for this architecture problem.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

11
Figure 1.2 Publisher–subscriber is a common software architecture situation. One application component
produces data that other application components consume. The Observer Design Pattern provides a model to
solve this problem.
1.5 Make sure we’re going to build the right application; then, build it
right
The critical start to designing an application is to acquire and analyze its requirements to ensure
that we’re developing the right application. An application, no matter how well designed, is not
successful if it doesn’t do what it’s supposed to. Getting good requirements is the important topic in
chapter 3. From the requirements, we can determine the initial set of classes. We then apply good
design techniques to build the application right.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

12
1.6 Good design doesn’t come easily
It takes practice and experience to consistently develop well-designed software. Developing an
application most often requires multiple design–code–test iterations. We must make design
tradeoffs, and we may need to backtrack from poor design decisions. It’s a rocky path to achieving
good design. If instead of developing the software iteratively we tried to complete it in one
prolonged coding marathon, we should not expect a successfully working application to simply
appear by magic at the end. This Big Bang almost never occurs (figure 1.3).
Figure 1.3 The Big Bang theory of application development. If we write lots of code in a prolonged marathon
instead of developing the software iteratively, we can only hope that the Big Bang at the end will magically
produce a working application. Unfortunately, that magic rarely happens.
1.7 Change and complexity are the enemies of good design
Change and complexity are the primary challenges to good design, and they are the two themes
that appear throughout this book. Change and complexity are inevitable facts of life for software
developers. Any design that does not take change into consideration will soon run into trouble
when the first change request come in. Code can become messy and complex as a development
project wears on, especially if there are multiple programmers on the project team. Design
principles and design patterns are tools used to deal with change and complexity.
Change can occur during development. As we’re writing the code, the application requirements
can change. Or we might change our mind about the design and want to rewrite some of our code.
After we’ve completed and deployed the application, we may get requests to add or modify
features. Good design enables us to modify one part of our code without needing to modify other
parts. Good design promotes the flexibility necessary to handle changes.
However, if we’re not careful, trying to make an application flexible enough to handle many
changes can increase its complexity. Our programs can become so complex that we won’t be able
to manage them. Good design also helps to keep our applications from getting out of hand. A good
software designer must make tradeoffs often.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

13
1.8 Design with object-oriented programming concepts
This book is about software design for the widely used OOP paradigm of application development.
OOP concepts are the foundation of all the good design principles and design patterns covered in
this book. Therefore, a quick review of the concepts will help ensure that we’re all on the same
page.
OOP is based on the following four main concepts:
Encapsulation
Abstraction
Inheritance
Polymorphism
A well-designed Python class encapsulates code by containing instance variables and methods. At
run time, an application instantiates (creates) objects from a class. The instance variables constitute
the attributes of the object.
During run time, an object undergoes state changes. Each state of the object is characterized by
a unique set of values of its attributes. An object makes a transition from one state to another
whenever one or more of its instance variables change values. The methods of an object can
operate on the instance variables. These functions determine how an object behaves during run
time.
A class’s public attributes constitute its interface and can be accessed by any code, whereas its
private attributes are accessible only by methods of that class. Protected members of a class are
accessible only by methods of subclasses of that class.
In this book, we’ll go beyond the strictly OOP meaning of encapsulation and use it to contain and
isolate changes in an application. Encapsulate What Varies is a design principle we will use many
times. Chapter 5 covers making members of a class private and protected to encapsulate changes
to its implementation.
Abstraction involves ignoring irrelevant details and paying attention only to what’s important relative
to the application we’re developing. Properly using abstraction is an important way to reduce
complexity.
Inheritance allows us to create subclasses (child classes) from a superclass (parent or base class).
A parent class passes down state information (in the form of instance variables) and behavior (in
the form of methods) to its subclasses. Each subclass can add its own additional state and behavior,
or it can override (replace) any inherited state or behavior.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

14
At run time, if you have a variable whose value is an object instantiated from one of the
subclasses of a common superclass, polymorphism is a runtime mechanism that determines how
the object behaves (i.e., which methods execute) based on which subclass instantiated the object.
Polymorphism helps to simplify an application’s design. Throughout this book, we will see that OOP
concepts are the foundation for the design principles and design patterns that the book covers.
1.9 Summary
Design is a disciplined engineering approach to creating a solution to a problem.
In software engineering, the problem is to create working software, and the
solution is a well-designed, sustainable application.
Well-designed software is better in many ways, such as being more reliable,
flexible, and maintainable. Good design helps ensure that applications are
completed on time and do what their clients expect.
It is possible to become a better programmer by using good software design
techniques that include good design principles and design patterns.
Good design principles help make our code more flexible and able to handle
changes such as new requirements. Design patterns are industry-proven
models for creating solutions to common software architecture problems.
Software design starts by acquiring and analyzing an application’s requirements
to ensure that we’re developing the right application. The application must do
what it’s supposed to do.
Developing a well-designed sustainable application nearly always requires
multiple iterations with backtracking over bad design decisions. It’s hard work.
Don’t rely on a magical Big Bang at the end of a marathon coding session.
Good software design must deal with the major challenges of change and
complexity.
The design principles and design patterns in this book are based on the object-
oriented programming concepts of abstraction, encapsulation, inheritance, and
polymorphism.
Encapsulation also means isolating the parts of a program that can change.
Then, when changes do occur, they won’t leak out and cause changes to other
parts of the program.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

15
2 Iterate to achieve
good design
This chapter covers
An iterative development strategy to achieve a well-designed application
Backtracking to recover from bad design decisions
Design principles to improve code
The development path to a well-designed application is almost never straight and narrow. As
described in chapter 1, we should not have marathon coding sessions and then count on a magical
Big Bang finish.
A much more rewarding development strategy takes an iterative approach. Each iteration builds
on the accomplishments of the previous one. Such a strategy is more likely to result in a successful
well-designed application.
The example application in this chapter demonstrates the iterative development strategy, and it
includes backtracking over a bad design decision. In addition, the chapter also deals with change
and complexity, the major challenges to good design. It introduces several key design principles,
which will appear repeatedly in subsequent chapters that will introduce additional design principles.
2.1 Good application design requires an iterative process
By some accounts, Wolfgang Amadeus Mozart was such a musical genius that he could compose an
entire symphony in his head and then write it down with few, if any, edits. Hardly any of us is a
programming Mozart who can develop well-designed applications in our heads and then write the
code perfectly all at once.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

16
NOTE I am not a programming Mozart. Even though the program examples in this book are all
relatively short, each is the final version of several hidden iterations I made until I was satisfied.
Indeed, as represented by the informal design decision tree in figure 2.1, the road to a well-
designed application is often a bumpy one, with wrong turns and dead ends that require
backtracking and rewriting. Each branch of the tree is a development path that either leads to a
successful application (the pot of gold) or a dead end (lumps of coal). If we took a dead-end branch,
we must back up to the previous decision node and take another branch. After exhausting all
possible branches at a node, we must back up again to the next higher node. We hope eventually to
find a path to a successfully completed application.
Figure 2.1 A design decision tree and the application development path shown as the dotted line. Each tree
node denotes a juncture during development when we must decide to choose a path (i.e., branch) on which to
continue. While designing and coding, if we head down a branch that leads to a dead-end (the lumps of coal),
we must backtrack to the previous decision node and try another branch. After trying all the branches at a
node, we must backtrack to the next higher node and try the next branch from there. We hope to find the path
to a successfully completed application (the pot of gold).
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

17
The design decision tree in the figure is somewhat misleading because it shows the entire tree with
all the branches representing development paths. We rarely know in advance all the decisions we’ll
need to make while coding. Instead, we construct the decision tree node by node during program
development. At each node, we decide the next path to take and create a branch. Of course, we
should take the path that appears to be correct and that will result in a good design. However, if
that branch turns out to be a decision and coding path leading to a dead end, either because some
application requirements changed or because we simply made a bad design decision, we must go
back to the node and create a new branch. Once we’ve run out of branches for a node, we must go
back up to the parent node and create a new branch there. We hope to eventually find the path to a
successfully completed application. In the worst case, we may have to backtrack to the topmost
node and start over from there.
How does this work in practice? Modern agile software development practice advocates that
development should progress in a series of iterations. An iteration can represent a trip down a
branch of the decision tree. As shown in figure 2.2, each iteration consists of three phases: design,
code, and test to incrementally improve or add more features to the application. Only after all of an
iteration’s tests have passed should we start the next iteration. An iteration can last as little as a few
hours to around two weeks. If an iteration lasts longer than that, we’re likely trying to do too much
during the iteration.
Figure 2.2 Iterations during application development. Each iteration stands for going down a branch in the
decision tree, including backing up and trying another branch. Each iteration includes designing, coding, and
testing to incrementally improve or add more features to the application. The iterations can take different
amounts of time, as short as a few hours or up to around two weeks.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

18
TEST-DRIVEN DEVELOPMENT
During each iteration, the intuitive order of activities is design–code–test. However, test-
driven development (TDD) is a development process that uses the order test–design–code.
Using TDD, at the start of each iteration, we write the test programs for the features that we
want to implement during the iteration. Of course, all the tests will initially fail because we
haven’t written the code yet that implements the features. The goal of each iteration is to
design and write the code that will make all tests for that iteration pass.
As we saw with the decision tree, the series of iterations doesn’t imply continuous forward progress.
Some iterations are the result of backtracking and taking an alternate path. But don’t despair! As
you become a more experienced programmer, the decision tree becomes smaller, and you will
need fewer iterations to complete your application. However, achieving good design remains a
continuous-improvement process.
2.2 Don’t let changes leak out
Woe to the programmer who discovers that making changes to one part of an application requires
changes to other parts! In the worst-case scenario, major portions of the application, if not the
entire application, will require rewriting.
Chapter 1 mentioned that one of the primary design challenges is to accommodate change. If we
write a significant application, we should anticipate what parts will change. There are numerous
causes for code changes. Some of the common ones are the following:
The requirements change. The requirements state what our application must
do, or allow its users to do, and they may change both during development and
after the application is finished.
We change our mind about design during development.
We add new features (or remove the ones that are not needed) from a
completed application.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

19
2.3 Iterate to achieve good design
For the example application in this section, we will eventually arrive at a good design that
encapsulates changes and has other benefits, but only after several iterations of designing, coding,
and testing. The example will also demonstrate how it’s sometimes necessary to backtrack from a
poor design decision that seemed right when we made it.
A NOTE ABOUT THE EXAMPLES’ CODING STYLE
To keep the example programs short and simple, we’ll leave out descriptive and explanatory
comments that applications normally should have in the source code. Instead, the printed
examples will use code annotations.
In the example, we want to develop a book catalogue application that stores a list of books and
allows a user to search for books that match the user’s target attributes. Here are the application’s
initial requirements.
A user must be able to add fiction books and their attributes to the catalogue.
The attributes for each book shall be the book title and the author’s last and first
names.
A user must be able to search for books that match the user’s target attribute
values.
Searches for books shall depend on matching any number of target attributes.
String matches of the book titles and authors’ first and last names must be case-
insensitive.
A user must be able to specify any number of don’t-care (wildcard) target
attributes.
Each don’t-care attribute must by default match the corresponding attribute in
all books in the catalogue. The remaining target attributes must match exactly.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

20
FUNCTIONS AND METHODS
A function is defined outside of any classes and is therefore independent — it does not need
to be called on an object. Many functions that we use are included with Python, such as len()
which returns the length of a string or list.
A method is a function that is defined as part of a class, and so it implements a behavior of an
object instantiated from the class. A regular method must be called on an object of the class,
such as shape.draw(). A static method (described for listing 2.2) must be called either on an
object of the class or on the class itself.
Since a method is a function, functions and methods have many of the same design issues.
2.3.1 Iteration 1: Initial cohesive classes
Looking at the requirements, we can readily design two classes: Book and Catalogue. At run time,
the catalogue will store Book objects. The private instance variables of Book are a book’s private
attributes: the book’s _title and author’s _first and _last names. The constructor is passed the
attribute values and initializes these instance variables.
PUBLIC, PRIVATE, AND PROTECTED INSTANCE VARIABLES AND METHODS IN PYTHON
By convention, the names of a Python class’s private instance variables and private methods
each begins with the underscore _ character, such as _x. Because the Python compiler
doesn’t enforce private names as in languages like Java and C++, using the underscore is only
a safety measure to prevent unintentional access by code from outside the class. It is not
meant to be a security measure. If a name is defined with a leading underscore in a class, we
rely on programmers to treat it as private.
In a superclass, some programmers like to use the single underscore for the names of
protected instance variables and methods and double underscores (such as __x) for private
names. Protected members of a class in languages like Java and C++ are accessible from
methods defined in the class itself and in its subclasses, but not from anywhere else.
Examples in this book will follow the suggestions under “Method Names and Instance
Variables” in the PEP 8 Style Guide for Python Code (https://peps. python.org/ pep-0008): “Use
one leading underscore only for non-public methods and instance variables”. Under
“Designing for Inheritance”, the style guide suggests: “If your class is intended to be
subclassed, and you have attributes that you do not want subclasses to use, consider naming
them with double leading underscores and no trailing underscores. This invokes Python’s
name mangling algorithm, where the name of the class is mangled into the attribute name.
This helps avoid attribute name collisions should subclasses inadvertently contain attributes
with the same name.”
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

21
Therefore, initially in this program example, class Book has private instance variables _title,
_last, and _first, and class Catalog has private instance variable _booklist and private method
_is_match(). In iterations 3 and 4 when we’ll define subclasses of Catalog, we’ll rename its
instance variable __booklist with two leading underscores to indicate that the subclasses
shouldn’t access that variable.
Python predefines the names of special methods such as __init__() and __str__() to have
leading and trailing double underscores.
Listing 2.1 (Program 2.1 Books-1): book.py
class Book:
def __init__(self, title, last, first):
self._title = title #A
self._last = last #A
self._first = first #A
@property #B
def title(self): return self._title #B
#B
@property #B
def last(self): return self._last #B
#B
@property #B
def first(self): return self._first #B
def __str__(self):
return (f"{{TITLE: '{self._title}', LAST: '{self._last}', " #C
f"FIRST: '{self._first}'}}") #C
#A The Book class’s instance variables are private.
#B The Book class’s public read-only properties.
#C Return a Book object’s print string.
The __str()__ special method for a Book object returns a print string of a book’s properties
surrounded by braces, with a label for each attribute value. An example string would be
{TITLE: 'To Kill a Mockingbird', LAST: 'Lee', FIRST: 'Harper'}
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

22
THE @PROPERTY DECORATOR
Python decorators are a form of metaprogramming—programming that modifies the code
we’re writing. Decorator actions occur each time we run our program, before Python
executes the first line of code that we wrote.
Each @property decorator automatically creates a property object. A property object is
named after the public method that follows the decorator, known as a getter method.
Therefore, class Book in listing 2.1 has property objects named title, last, and first. A property
object and its associated getter method are typically named after the private instance
variable whose value the method gets, but without the leading underscore.
A property object provides a public but controlled way to access a private instance variable’s
value. It discourages access to a class’s private instance variables from outside the class. We
can access a property like an instance variable. If target is a Book object, we can write
target.title, target.last, and target.first, and each access automatically calls the associated
getter method.
Because a property is read-only, it is not possible to modify its value with an assignment
statement. For example, the statement
target.last = "Smith"
is an error.
A property’s name is not restricted to the name of a private instance variable. The property
can be a value that’s calculated at run time each time it’s used. For example, in a Circle class,
we can have a public circumference and area properties while instance variable _radius is
private.
from math import pi
class Circle:
def __init__(self, radius):
self._radius = radius
@property
def circumference(self): return 2*pi*self._radius
@property
def area(self): return pi*self._radius*self._radius
Chapter 5 will discuss how to use properties to modify the values of private instance
variables.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

23
In class Catalogue (listing 2.2), private instance variable _booklist is a list of Book objects stored in
the catalogue. Public method add() creates a new Book object from a title and the author’s last and
first names and appends the object to the list. Public method find() searches the list for a matching
book.
Private static method _equal_ignore_case() performs a case-insensitive comparison of two
strings, target_str and other_str. An empty target string represents a don’t-care attribute, in which
case the comparison always returns true.
Listing 2.2 (Program 2.1 Books-1): catalogue.py
from book import Book
class Catalogue:
@staticmethod
def _equal_ignore_case(target_str, other_str):
if len(target_str) == 0: #A
return True
else:
return target_str.casefold() == other_str.casefold() #B
def __init__(self):
self._booklist = [] #C
def add(self, title, last, first):
book = Book(title, last, first)
self._booklist.append(book)
def _is_match(self, book, target):
return ( Catalogue._equal_ignore_case(target.title,
book.title)
and Catalogue._equal_ignore_case(target.last,
book.last)
and Catalogue._equal_ignore_case(target.first,
book.first)
)
def find(self, target):
return [book for book in self._booklist
if self._is_match(book, target)
]
#A Always a true comparison if the target string is empty.
#B Compare the strings ignoring case.
#C Private list of Book objects
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

24
Public method find() is passed a Book object named target that contains the target attributes. It
uses list comprehension to create a list of books that matches the target attributes. The list
comprehension iterates over the books in _booklist and calls the private method _is_match(),
passing each book in the list and the target book. Method _is_match() in turn calls the private static
method _equal_ignore_case() to compare the target title, last name, and first name to the
corresponding attributes of the book. The method returns the list of matching books or an empty
list if no books matched.
STATIC METHODS
A @staticmethod decorator makes the method that follows it into a static method of class.
Such a method does not have a self parameter, and therefore it is not implicitly passed a
reference to an object instantiated from the class. In listing 2.2, private static method
_equal_ignore_case() returns a value based solely on argument values explicitly passed to it,
not on the instance variables of an implicitly passed object.
To call a static method, precede the name of the method with the name of the class, as in
Catalogue._equal_ignore_case. We can also call a static method on an object of the class,
such as cat._equal_ignore_case if cat is a Catalogue object, but the static method would have
no reference to the object.
We want to define classes that are cohesive, each with only a single primary responsibility. The Book
class is responsible for storing a book’s attributes. The Catalogue class is responsible for
maintaining the list of Book objects, which includes adding new books to the list and finding book
matches in the list.
THE SINGLE RESPONSIBILITY PRINCIPLE
The Single Responsibility Principle states that a well-designed class should be cohesive,
meaning that it ought to have only a single primary responsibility. A poorly designed class
has too many responsibilities. A cohesive class with a clear responsibility is easy to use—
there should be no doubt what its purpose is. A cohesive class is easy to maintain—all its
methods and instance variables serve a single primary purpose.
In the test program main.py (listing 2.3), function fill() loads the catalogue with some fiction books.
The top-level main code performs test searches with some target books, and it calls function
search() to do each search. Some of the target attributes are empty strings that represent don’t-
cares.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

25
Listing 2.3 (Program 2.1 Books-1): main.py
from book import Book
from catalogue import Catalogue
def fill(catalogue): #A
catalogue.add("Life of Pi", "Martel", "Yann")
catalogue.add("The Call of the Wild", "London", "Jack")
catalogue.add("To Kill a Mockingbird", "Lee", "Harper")
catalogue.add("Little Women", "Alcott", "Louisa")
catalogue.add("The Adventures of Sherlock Holmes", "Doyle", "Conan")
catalogue.add("And Then There Were None", "Christie", "Agatha")
catalogue.add("Carrie", "King", "Stephen")
catalogue.add("It: A Novel", "King", "Stephen")
catalogue.add("Frankenstein", "Shelley", "Mary")
catalogue.add("2001: A Space Odyssey", "Clarke", "Arthur")
catalogue.add("Ender's Game", "Card", "Orson")
def search(catalogue, target): #B
print()
print("Find ", end="")
print(target)
matches = catalogue.find(target)
if len(matches) == 0:
print("No matches.")
else:
print("Matches:")
for book in matches:
print(" ", end="")
print(book)
def test(catalogue): #C
target = Book("Life of Pi", "Martel", "Yann")
search(catalogue, target)
target = Book("", "King", "")
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

26
search(catalogue, target)
target = Book("1984", "Orwell", "George")
search(catalogue, target)
target = Book("", "", "") #D
search(catalogue, target)
if __name__ == '__main__':
catalogue = Catalogue() #E
fill(catalogue) #E
test(catalogue) #E
#A Fill the catalogue with test Book objects
#B Search the catalogue for a target book
#C Test function
#D Target Book with don’t-care (wildcard) attributes
#E Mainline code
The output from the test run is
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

27
Find {TITLE: 'Life of Pi', LAST: 'Martel', FIRST: 'Yann'}
Matches:
{TITLE: 'Life of Pi', LAST: 'Martel', FIRST: 'Yann'}
Find {TITLE: '', LAST: 'King', FIRST: ''}
Matches:
{TITLE: 'Carrie', LAST: 'King', FIRST: 'Stephen'}
{TITLE: 'It: A Novel', LAST: 'King', FIRST: 'Stephen'}
Find {TITLE: '1984', LAST: 'Orwell', FIRST: 'George'}
No matches.
Find {TITLE: '', LAST: '', FIRST: ''}
Matches:
{TITLE: 'Life of Pi', LAST: 'Martel', FIRST: 'Yann'}
{TITLE: 'The Call of the Wild', LAST: 'London', FIRST: 'Jack'}
{TITLE: 'To Kill a Mockingbird', LAST: 'Lee', FIRST: 'Harper'}
{TITLE: 'Little Women', LAST: 'Alcott', FIRST: 'Louisa'}
{TITLE: 'The Adventures of Sherlock Holmes', LAST: 'Doyle', [CA]
FIRST: 'Conan'}
{TITLE: 'And Then There Were None', LAST: 'Christie', FIRST: 'Agatha'}
{TITLE: 'Carrie', LAST: 'King', FIRST: 'Stephen'}
{TITLE: 'It: A Novel', LAST: 'King', FIRST: 'Stephen'}
{TITLE: 'Frankenstein', LAST: 'Shelley', FIRST: 'Mary'}
{TITLE: '2001: A Space Odyssey', LAST: 'Clarke', FIRST: 'Arthur'}
{TITLE: 'Ender's Game', LAST: 'Card', FIRST: 'Orson'}
RUNNING THE EXAMPLE PROGRAMS
All the example programs in this book use the 3.12 version of Python, although most of the
examples should also work with earlier Python 3 versions. You can run each program on the
command line in a terminal window with the python command. For example, to run source
file main.py of a program, which contains the mainline code:
python main.py
You can also run the examples using any of the Python IDEs (integrated Development
Environment) such as Spyder, Visual Studio Code, or Jupyter notebooks. An IDE generally
includes a “smart” editor with syntax checking and debugging features.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

28
Apparently, our application fulfills its requirements. Figure 2.3 depicts our progress thus far after
one development iteration. We’ll award ourselves a couple of gold coins.
Figure 2.3 In our first development iteration, we created two classes: Book and Catalogue. The dotted line
shows our development path. The application fulfills its current requirements.
2.3.2 Iteration 2: Encapsulation, delegation, and loose coupling
Now, suppose that we’re given additional requirements to add two more book attributes—the
publication year and the genre:
The attributes for each fiction book shall include its publication year and its
genre.
The book genres shall be ADVENTURE, CLASSICS, DETECTIVE, FANTASY,
HISTORIC, HORROR, ROMANCE, and SCIFI.
We need to make some code changes to accommodate the new requirements. Ostensibly, class
Book needs two new instance variables for the year and the genre. Because the requirements give a
specific list for the genres, we can define enumeration constants for them.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

29
STRINGS VS. ENUMERATION TYPES
Whenever there is a limited set of values, such as for the genre, an enumeration type is
preferable to using a string type. With strings, we must worry about case-sensitive versus
case-insensitive comparisons. If we have a typo or a misspelling in a string, the resulting
runtime logic error may be hard to detect. Comparisons of enumeration constant values
during run time are very efficient, and Python will catch a misspelling of an enumeration
constant before the application runs.
At this point, we can see that any attribute changes we make to class Book will require
corresponding changes to class Catalogue (listing 2.2):
Method add() has book attributes as parameters.
The if statement in method find() references the book attributes.
We can plug the leak by encapsulating the code that will vary by putting the attributes into a
separate class Attributes (see listing 2.4).
THE ENCAPSULATE WHAT VARIES PRINCIPLE
The Encapsulate What Varies Principle recommends that good software design separates
code that can vary from code that won’t vary. Encapsulating the code that can vary isolates it
from the rest of the program. Then, when changes occur to the encapsulated code, those
changes won’t leak out and cause other code to change. A common way to encapsulate code
that can vary is to put it in a class by itself.
Because changing the book attributes necessitates changes to searching the attributes, we also
need to encapsulate that behavior in class Attributes. Private method is_match() explicitly compares
attributes and returns True or False, respectively, if they do or do not match. Special Genre value
UNSPECIFIED and year value 0 will be don’t-care search target values. To perform the case-
insensitive string comparisons, we must move the private static method _equal_ignore_case() from
class Catalogue to class Attributes.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

30
Listing 2.4 (Program 2.2 Books-2): attributes.py
from enum import Enum
class Genre(Enum): #A
UNSPECIFIED = 0
ADVENTURE = 1
CLASSICS = 2
DETECTIVE = 3
FANTASY = 4
HISTORIC = 5
HORROR = 6
ROMANCE = 7
SCIFI = 8
def __str__(self): return self.name.lower()
class Attributes:
@staticmethod
def _equal_ignore_case(target_str, other_str): #D
if len(target_str) == 0:
return True
else:
return target_str.casefold() == other_str.casefold()
def __init__(self, title, last, first, year, genre):
self._title = title
self._last = last
self._first = first
self._year = year #C
self._genre = genre #C
@property
def title(self): return self._title
@property
def last(self): return self._last
@property
def first(self): return self._first
@property
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

31
def year(self): return self._year
@property
def genre(self): return self._genre
def is_match(self, target_attrs): #B
return (
Attributes._equal_ignore_case(target_attrs.title,
self._title)
and Attributes._equal_ignore_case(target_attrs.last,
self._last)
and Attributes._equal_ignore_case(target_attrs.first,
self._first)
and ( (target_attrs.year == 0)
or (target_attrs.year == self._year))
and ( (target_attrs.genre == Genre.UNSPECIFIED)
or (target_attrs.genre == self._genre))
)
def __str__(self):
return (f"{{TITLE: '{self._title}', LAST: '{self._last}', "
f"FIRST: '{self._first}', YEAR: {self._year}, " #E
f"GENRE: {self._genre}}}") #E
#A The Genre attribute
#B Explicitly match attributes, including year and genre.
#C The added year and genre attributes
#D Class method moved from class Catalogue
#E The print string includes the year and genre attributes.
We replaced the __str__() special method for a Book object with one for an Attributes object that
returns a print string for all the attributes, including the year and genre.
A Book object is now constructed from an Attributes object, as follows. Each Book object will
point to its Attributes object.
Listing 2.5 (Program 2.2 Books-2): book.py
class Book:
def __init__(self, attributes):
self._attributes = attributes
@property
def attributes(self): return self._attributes #A
#A Each Book object will contain an Attributes object.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

32
Class Catalogue needs changes to its add() and find() methods to handle the new Attributes class
(listing 2.6). We pass Attributes object attrs to method add(), which uses the object to construct a
Book object to add to the booklist. We pass the target Attributes object target_attrs to method
find().
Listing 2.6 (Program 2.2 Books-2): catalogue.py
from attributes import Attributes
from book import Book
class Catalogue:
def __init__(self):
self._booklist = []
def add(self, attrs):
self._booklist.append(Book(attrs)) #A
def find(self, target_attrs):
return [book for book in self._booklist
if book.attributes.is_match(target_attrs) #B
]
#A Construct a Book object from the Attributes object.
#B Delegate attribute matching to class Attributes.
Method find() becomes much simpler (listing 2.8). The method delegates attribute matching to class
Attributes by calling the latter’s is_match() method, and thus find() is no longer affected by any
changes to book attributes.
Attribute matching does fit better in a cohesive Attributes class.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

33
THE DELEGATION PRINCIPLE
The Delegation Principle says to move functionality out of one class (the requester) into
another more suitable class (the delegate) to make the two classes more cohesive. The
requester class commonly has an instance variable that will contain an object of the delegate
class. A particular method in the delegate class implements the work to be done on behalf of
the requester class. The requester class should not have any dependencies on how the
delegate class does that work. At run time, an object of the requester class can request the
work by calling that method on the object of the delegate class.
In our example, the requester is class Catalogue, and the delegate is class Attributes.
Class Catalogue is now loosely coupled with class Attributes because we’ve minimized the
dependences of Catalogue on Attributes. Class Catalogue doesn’t know the specific attributes that
class Attributes maintains. Classes Book and Attributes are also loosely coupled with each other:
class Attributes doesn’t know that its objects are stored by Book objects, and class Book also
doesn’t need to know how class Attributes is implemented.
THE PRINCIPLE OF LEAST KNOWLEDGE
Well-designed classes are loosely coupled, meaning that they ought to have little, if any,
dependencies on each other. The less a class knows about how another class is
implemented, the fewer dependencies it has on the other class. A class can hide its
implementation by making its instance variables and methods private.
This is the Principle of Least Knowledge, which supports the Encapsulate What Varies
Principle. If a class needs to change its implementation, the change can’t affect any other
code that doesn’t depend on that implementation.
The test program main.py must change whenever the book attributes change. Example code to add
a book to the catalogue is now
catalogue.add(Attributes("The Call of the Wild",
"London", "Jack",
1903, Genre.ADVENTURE))
catalogue.add(Attributes("To Kill a Mockingbird",
"Lee", "Harper",
1960, Genre.CLASSICS))
and example code to search for books is now
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

34
target_attrs = Attributes("Life of Pi", "Martel", "Yann",
2003, Genre.ADVENTURE)
search(catalogue, target_attrs)
target_attrs = Attributes("", "King", "", 0, Genre.HORROR)
search(catalogue, target_attrs)
However, we won’t consider that an encapsulation failure because the testing code is not
intrinsically a part of the application. We must assume that any means to load the catalogue from
outside the application (such as from a file) must know about the current book attributes.
Some sample output is
Find {TITLE: '', LAST: 'King', FIRST: '', YEAR: 0, GENRE: horror}
Matches:
{TITLE: 'Carrie', LAST: 'King', FIRST: 'Stephen', YEAR: 1974, å
GENRE: horror}
{TITLE: 'It: A Novel', LAST: 'King', FIRST: 'Stephen', YEAR: 1986, å
GENRE: horror}
Figure 2.4 shows our progress after two iterations. We were able to handle a few more
requirements, so let’s award ourselves more gold coins.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

35
Figure 2.4 The second development iteration adds class Attributes, and class Catalogue delegates attribute
matching to class Attributes.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

36
2.3.3 Iteration 3: More kinds of books and their attributes
We’ve been concerned with changes to the Book attributes. But the kinds of books we store in the
catalogue can also change. Here are more requirements:
It must be possible to add cookbooks and their attributes to the catalogue.
The attributes for a cookbook must include its region.
The regions shall be CHINA, FRANCE, INDIA, ITALY, MEXICO, US, and
UNSPECIFIED.
This may also be an opportunity to show off our object-oriented programming skills! Our
application now must store both fiction and cookbooks in the catalogue. It’s reasonable to make
Book a superclass and design two new subclasses for it, Fiction and Cookbook. In the next listing,
the constructor for subclass Fiction calls the constructor of its superclass and passes the initializing
attributes: super().__init__(attrs).
Listing 2.7 (Program 2.3 Books-3): fiction.py
from book import Book
class Fiction(Book): #A
def __init__(self, attrs):
super().__init__(attrs) #B
#A Class Fiction is a subclass of class Book.
#B Call the constructor of superclass Book.
In the next listing, the constructor for subclass Cookbook also calls the superclass constructor.
Listing 2.8 (Program 2.3 Books-3): cookbook.py
from book import Book
class Cookbook(Book): #A
def __init__(self, attrs):
super().__init__(attrs) #B
#A Class Cookbook is a subclass of class Book.
#B Call the constructor of superclass Book.
We can also make Attributes a superclass (listing 2.9) and design two new subclasses for it,
FictionAttrs and CookbookAttrs. Superclass Attributes maintains the instance variables __title, __last,
and __first. The values of these attributes are shared by the subclasses, but their names should not
be accessed by the subclasses. Therefore, we’ve renamed them with leading double underscores in
accordance with the PEP 8 guidelines reproduced earlier. Method is_match() only compares the
common attributes and method __str()__ renders only them.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

37
Listing 2.9 (Program 2.3 Books-3): attributes.py
class Attributes:
@staticmethod
def _equal_ignore_case(target_str, other_str):
if len(target_str) == 0:
return True
else:
return target_str.casefold() == other_str.casefold()
def __init__(self, title, last, first):
self.__title = title #A
self.__last = last #A
self.__first = first #A
@property
def title(self): return self.__title
@property
def last(self): return self.__last
@property
def first(self): return self.__first
def is_match(self, target_attrs):
return (
Attributes._equal_ignore_case(target_attrs.title, #B
self.__title) #B
and Attributes._equal_ignore_case(target_attrs.last, #B
self.__last) #B
and Attributes._equal_ignore_case(target_attrs.first, #B
self.__first) #C
)
def __str__(self):
return (f"TITLE: '{self.__title}'" #C
f", LAST: '{self.__last}'" #C
f", FIRST: '{self.__first}'") #C
#A Private attributes renamed with leading double underscores.
#B Compare only the private attributes.
#C Render only the private attributes.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

38
Subclass FictionAttrs contains the attributes unique to fiction books: genre and year (listing 2.10). Its
constructor first calls the constructor of its superclass Attributes to initialize the inherited common
instance variables title, last, and first. Then, it initializes the year and genre instance variables of the
subclass. We also moved the definitions of the Genre enumeration constants and their special
method __str__() into class FictionAttrs.
Method is_match() first calls the superclass method super().is_match() to check the common title
and the last and first name attributes. If that passes, then the subclass can check the fiction book’s
private _year and _genre attributes. The __str__() method renders the common attributes by calling
super().__str__() before rendering the subclass’s private attributes.
Listing 2.10 (Program 2.3 Books-3): fictionattrs.py
from enum import Enum
from attributes import Attributes
class Genre(Enum): ...
class FictionAttrs(Attributes):
def __init__(self, title, last, first, year, genre):
super().__init__(title, last, first) #A
self._year = year #B
self._genre = genre #B
@property
def year(self): return self._year #E
@property
def genre(self): return self._genre #E
def is_match(self, target_attrs):
if not super().is_match(target_attrs): return False #C
return (
( (target_attrs.year == 0) #D
or (target_attrs.year == self._year)) #D
and #D
( (target_attrs.genre == Genre.UNSPECIFIED) #D
or (target_attrs.genre == self._genre)) #D
)
def __str__(self):
return ("{" + super().__str__() + \ #E
f", YEAR: {self._year} " #E
f", GENRE: {self._genre.name.lower()}" + "}" ) #E
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

39
#A First initialize the common attributes.
#B Then initialize the year and genre for fiction books.
#C First match the common attributes.
#D Then match the year and genre for fiction books.
#E Render the common attributes before the subclass’s private _year and _genre attributes.
Subclass CookbookAttrs contains the region attribute unique to cookbooks, as in the following
listing. Its constructor, is_match(), and __str__() methods behave similarly to the ones in subclass
FictionAttrs.
Listing 2.11 (Program 2.3 Books-3): cookbookattrs.py
from enum import Enum
from attributes import Attributes
class Region(Enum):
UNSPECIFIED = 0
China = 1
France = 2
India = 3
Italy = 4
Mexico = 5
Persia = 6
US = 7
def __str__(self): return self.name
class CookbookAttrs(Attributes):
def __init__(self, title, last, first, region):
super().__init__(title, last, first) #A
self._region = region #B
@property
def region(self): return self._region #E
def is_match(self, target_attrs):
if not super().is_match(target_attrs): return False #C
return ( (target_attrs.region == Region.UNSPECIFIED) #D
or (target_attrs.region == self._region)) #D
def __str__(self):
return ("{" + super().__str__() + \ #E
f", REGION: {self._region}" + "}") #E
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

40
#A First initialize the common attributes.
#B Then initialize the region for cookbooks.
#C First match the common attributes.
#D Then match the region for cookbooks.
#E Render the common attributes before the subclass’s private _region attribute.
These are examples of the Open-Closed Principle. Once we’ve decided that class Attributes has
captured the common instance variables and methods for all attributes, we closed it for
modification to provide code stability. We don’t expect to make more changes to the class. But we
opened the class for extensions in the form of subclasses such as FictionAttrs and CookbookAttrs to
provide the flexibility to add more kinds of book attributes. Class Book and its subclasses are
another example of this design principle.
THE OPEN-CLOSED PRINCIPLE
Closing a class to modification provides stability―programmers will always know what that
code does and how to use it. But keeping it open for extensions in the form of subclasses
allows adding functionality beyond what the closed superclass provides. That’s the idea
behind the Open-Closed Principle.
This principle supports loose coupling and encapsulation. For example, a Shape superclass
can hide how it stores coordinates. But it can have subclasses such as Rectangle and Circle
that extend functionality by displaying the various shapes, but the subclasses are not
dependent on how the coordinates are stored. If it ever becomes necessary to change the
coordinates code in the superclass, the subclasses will inherit the changes but not require
any code modifications.
Class Book has not changed (listing 2.5). As each Book object, whether Fiction or Cookbook, must
contain its corresponding Attributes object, either FictionAttrs or CookbookAttrs, respectively, we’ll
put that instance variable in superclass Book. Therefore, Book contains the superclass Attributes,
rather than specifically FictionAttrs or CookbookAttrs. This is an example of coding to the interface,
because superclass Attributes serves as the interface of its subclasses.
THE CODE TO THE INTERFACE PRINCIPLE
If a class has several subclasses, our code should have the flexibility to work with any of the
subclasses at run time. A Book object can contain either a FictionAttrs object or a
CookbookAttrs object.
The Code to the interface Principle relies on polymorphism. Which is_match() method of
class Catalogue is invoked at run time depends on the type of object (FictionAttrs or
CookbookAttrs) that is assigned to instance variable book.attributes.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

41
Class Catalogue now has an add() method that appends to _booklist either a Fiction book object
created with a FictionAttrs object or a Cookbook object created with a CookbookAttrs object. It also
needs find_fiction() and find_cookbook() methods, as in the following listing. Instance variable
_booklist remains a list of Book objects, not specifically Fiction or Cookbook objects, another
example of the Code to the Interface Principle.
Listing 2.12 (Program 2.3 Books-3): catalogue.py
from fiction import Fiction
from fictionattrs import FictionAttrs
from cookbook import Cookbook
class Catalogue:
def __init__(self):
self._booklist = []
def add(self, attrs): #A
if isinstance(attrs, FictionAttrs): book = Fiction(attrs)
else: book = Cookbook(attrs)
self._booklist.append(book)
def find_fiction(self, target_attrs): #B
return [book for book in self._booklist
if ( isinstance(book, Fiction) #C
and book.attributes.is_match(target_attrs))
]
def find_cookbook(self, target_attrs): #D
return [book for book in self._booklist
if ( isinstance(book, Cookbook) #E
and book.attributes.is_match(target_attrs))
]
#A Add a fiction book or a cookbook to the catalogue.
#B Find matching fiction books.
#C Is this book a fiction book?
#D Find matching cookbooks.
#E Is this book a cookbook?
The add() method needs to determine whether the Attributes object that was passed to it is an
FictionAttrs or a CookbookAttrs object. It calls the Boolean type-checking function isinstance() which
returns true if attrs is a FictionAttrs object.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

42
Methods find_fiction() and find_cookbook() are similar. Each must verify that it searches the right
kind of books, fiction or cookbook, by calling the isinstance() function. Both methods delegate
attributes matching to the book.attributes object.
When the test program main.py loads books into the catalogue, it calls the Catalogue object’s
add() method either with a FictionAttrs object,
catalogue.add(FictionAttrs("Little Women",
"Alcott", "Louisa",
1868, Genre.CLASSICS))
or with a CookbookAttrs object:
catalogue.add(CookbookAttrs("The Woks of Life",
"Leung", "Bill",
Region.China))
Indeed, what if the requirements change further, and the catalogue must store and search for other
kinds of books, and each kind has unique attributes? We made our application more complex by
attempting to handle requirement changes, namely new kinds of books and additional book
attributes. Examples of the complexity include the following:
Each kind of book requires a pair of Book and Attributes subclasses.
Each kind of book requires a find() method in class Catalogue. These methods
have similar code.
Method add() method in class Catalogue requires a call to the Boolean type-
checking function isinstance() to determine whether the attributes are fiction or
cookbook.
Also in class Catalogue, each find() method requires a call to isinstance() to
ensure it will check the right kind of book. Otherwise, these methods have
similar code.
If our application needs to manage more kinds of books, we will have an increase of subclasses,
duplicate code, and runtime type checks.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

43
THE DON’T REPEAT YOURSELF PRINCIPLE
Repeated code is often a sign of poor design, according to the Don’t Repeat Yourself
Principle, often abbreviated DRY. Not only does repeated code enlarge the size of a program,
but that code also makes the program harder to maintain. If you need to make a change to
the code that’s repeated, you’ll need to make the same change to multiple copies of the
code. You run the risk of missing a copy or inadvertently changing copies differently.
One way to eliminate repeated code is to share only one copy of it as a separate function or
as a separate cohesive class.
Table 2.1 shows the current situation with fiction books and cookbooks, and what happens when
we include how-to books.
Table 2.1 Our current design requires many classes to handle different kinds of books and their attributes.
Kind of book Classes Attributes
All books Book, Attributes title, last, first
Fiction Fiction, FictionAttrs year, genre
Cookbook Cookbook, CookbookAttrs region
How-to Howto, HowtoAttrs subject
Figure 2.5 shows a diagram of our application architecture as we’ve designed it thus far.
Figure 2.5 A diagram of our application architecture as we’ve designed it thus far, showing our classes and
subclasses and their relationships.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

44
After the third iteration, we must admit that using subclasses to handle changes in the
requirements for books and attributes was a poor design decision that won’t scale well if there are
more kinds of books. Figure 2.6 shows our progress after this iteration. We deserve those lumps of
coal!
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

45
Figure 2.6 The third development iteration added subclasses Fiction, Cookbook, FictionAttrs, and
CookbookAttrs. This increase in the number of subclasses plus the added runtime type checking tell us that
we took a wrong decision path.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

46
2.3.4 Iteration 4: A better design after backtracking
Let’s take a deep breath, backtrack, and take another decision branch. Recall the purposes of
classes in object-oriented programming, as described in chapter 1. A class has instance variables to
maintain an object’s state at run time, and an object undergoes a state transition whenever the
values of its instance variables change. A class has methods to implement the object’s behavior.
In our book catalogue application, as we’ve designed it thus far, subclasses Fiction and Cookbook
have little to do with state or behavior. We don’t need those subclasses. Class Book alone ought to
be sufficient.
Subclasses FictionAttrs and CookbookAttrs represent very similar behaviors, primarily
performing attribute matching during book searches. However, they have different instance
variables for their respective attributes. Is there a way to have the Attributes class alone handle all
the different attributes and eliminate its subclasses? An Attributes object associated with any kind
of Book object would have to store both the name and the value of each attribute.
Whenever there are name–value pairs in a Python program, we should consider the dictionary
data structure. A dictionary object contains name–value pairs, where the name serves as the key to
retrieve the paired value. Therefore, the pairs in a dictionary are usually called key–value pairs. A
Python dictionary’s keys can be any immutable type, such as strings, numbers, and enumeration
constants. The keys must be unique within a dictionary. A dictionary’s values can be any type, and
the values do not need to be unique.
We can make each Attributes object a dictionary. For the dictionary’s keys, we can define the
enumeration class Key (listing 2.13). We need one Key enumeration constant per attribute across all
the kinds of books. For example, the dictionary value paired with key KIND will indicate the kind of
book: FICTION, COOKBOOK, etc., and the value paired with key YEAR will be an integer. To make it
easier to change the list of enumeration constants in the future, we’ll define the enumeration class
Key in its own key.py source file. We’ll do the same for the other enumeration classes.
Listing 2.13 (Program 2.4 Books-4): key.py
from enum import Enum
class Key(Enum):
KIND = 0
TITLE = 1
LAST = 2
FIRST = 3
YEAR = 4
GENRE = 5
REGION = 6
SUBJECT = 7
def __str__(self): return self.name
Table 2.2 shows the keys we have thus far, and the datatype of the value paired with each key.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

47
Table 2.2 Key–value pairs that represent book attributes.
Key constant Datatype of paired value
KIND class Kind (Enum)
TITLE string
LAST string
FIRST string
YEAR int
GENRE class Genre (Enum)
REGION class Region (Enum)
SUBJECT class Subject (Enum)
It will be easy later to add new kinds of books, such as how-to books to the Kind enumeration
constants.
Listing 2.14 (Program 2.4 Books-4): kind.py
from enum import Enum
class Kind(Enum):
FICTION = 0
COOKBOOK = 1
HOWTO = 2
def __str__(self): return self.name.lower()
In the next listing, we define the Genre enumeration constants similarly.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

48
Listing 2.15 (Program 2.4 Books-4): genre.py
from enum import Enum
class Genre(Enum):
UNSPECIFIED = 0
ADVENTURE = 1
CLASSICS = 2
DETECTIVE = 3
FANTASY = 4
HISTORIC = 5
HORROR = 6
ROMANCE = 7
SCIFI = 8
def __str__(self): return self.name.lower()
Likewise, in the following listing, we define the Region enumeration constants.
Listing 2.16 (Program 2.4 Books-4): region.py
from enum import Enum
class Region(Enum):
UNSPECIFIED = 0
China = 1
France = 2
India = 3
Italy = 4
Mexico = 5
Persia = 6
US = 7
def __str__(self): return self.name
And finally, we define the Subject enumeration constants.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

49
Listing 2.17 (Program 2.4 Books-4): subject.py
from enum import Enum
class Subject(Enum):
DRAWING = 0
PAINTING = 1
WRITING = 2
def __str__(self): return self.name.lower()
We no longer need UNSPECIFIED constants. In our new design, if an attribute is missing in a search
target, that attribute will be a don’t-care.
We create and initialize an Attributes object by passing it a dictionary of key-value pairs. The
__init__() constructor verifies that the value of each key–value pair in the dictionary has the correct
datatype. This is an example of defensive programming—we don’t ever want to create an invalid
Attributes object.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

50
Listing 2.18 (Program 2.4 Books-4): attributes.py (part 1 of 3)
from key import Key
from kind import Kind
from genre import Genre
from region import Region
from subject import Subject
class Attributes:
@staticmethod
def _equal_ignore_case(target_str, other_str): ...
def __init__(self, dictionary): #A
for key, value in dictionary.items(): #B
if key == Key.YEAR:
assert(isinstance(value, int))
elif key in [Key.TITLE, Key.LAST, Key.FIRST]:
assert(isinstance(value, str))
elif key == Key.KIND:
assert(isinstance(value, Kind))
elif key == Key.GENRE:
assert(isinstance(value, Genre))
elif key == Key.REGION:
assert(isinstance(value, Region))
elif key == Key.SUBJECT:
assert(isinstance(value, Subject))
self._dictionary = dictionary
...
#A The Attributes constructor
#B Iterate over the elements of the dictionary to verify that the value of each pair has the correct datatype.
DEFENSIVE PROGRAMMING
Well-designed applications practice defensive programming to guard against programming
errors. Methods should create only proper objects from their parameter values.
Perform runtime value checks of function and method parameters to ensure that no invalid
values are being passed in. However, to keep the example programs in this book short, their
functions and methods generally do not have parameter checking.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

51
Private method _is_matching_pair() checks the attributes dictionary for a matching target_key and
target_value. If the target_key is not in the dictionary, the method returns False. It returns True if the
target_key is in the dictionary and the dictionary’s paired value is equal to target_value. However, if
the values are strings, the method compares them by calling _equal_ignore_case().
Method is_match() iterates over the key-value pairs in dictionary target_attrs and checks each
pair against the attributes dictionary by calling _is_matching_pair(). It returns True only if all the
pairs match.
If a particular attribute (such as the year) isn’t in target_attrs, then that attribute is a don’t-care
during matching.
Listing 2.19 (Program 2.4 Books-4): attributes.py (part 2 of 3)
...
def _is_matching_key_value(self, target_key, target_value):
if target_key not in self._dictionary.keys(): return False #A
if self._dictionary[target_key] == target_value: return True #B
if isinstance(target_value, str): #C
return Attributes._equal_ignore_case(
self._dictionary[target_key], target_value)
return False
def is_match(self, target_attrs):
for target_key, target_value \
in target_attrs._dictionary.items():
if not self._is_matching_key_value(target_key,
target_value):
return False
return True
...
#A Is the target key in the attributes dictionary?
#B Are the values equal?
#C Are the string values equal?
An example string that special method __str__() returns is
{KIND: fiction, TITLE: 'Carrie', LAST: 'King', FIRST: 'Stephen', å
YEAR: 1974, GENRE: horror}
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

52
Listing 2.20 (Program 2.4 Books-4): attributes.py (part 3 of 3)
...
def __str__(self):
last_key = list(self._dictionary.keys())[-1]
ostr = '{'
for key, value in self._dictionary.items(): #A
ostr += str(key.name) + ': '
if isinstance(value, str):
ostr += "'" + value + "'"
else:
ostr += str(value)
if key != last_key: ostr += ', '
ostr += '}'
return ostr
#A Iterate over the key–value pairs of the attributes dictionary.
Class Book now has a special method __str__() that returns a print string of its attributes, but the
rest of the class itself hasn’t changed.
Listing 2.21 (Program 2.4 Books-4): book.py
class Book:
def __init__(self, attributes):
self._attributes = attributes
@property
def attributes(self): return self._attributes
def __str__(self):
return str(self._attributes)
Class Catalogue is much simpler now, as shown in the following listing. We’ve eliminated the
duplicate code and now follow the Don’t Repeat Yourself Principle. There is only one find() method.
We no longer need calls to isinstance() to do runtime type checks. A bonus of this design is a book
can have any attributes, not limited to certain ones based on the kind of book.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

53
Listing 2.22 (Program 2.4 Books-4): catalogue.py
from book import Book
class Catalogue:
def __init__(self):
self._booklist = []
def add(self, attrs):
book = Book(attrs)
self._booklist.append(book)
def find(self, target_attrs):
return [book for book in self._booklist
if book.attributes.is_match(target_attrs)
]
In the test program main.py, function fill() now enters a book into the catalogue with statements like
attrs = {
Key.KIND: Kind.FICTION,
Key.TITLE: "Life of Pi",
Key.LAST: "Martel",
Key.FIRST: "Yann",
Key.YEAR: 2003,
Key.GENRE: Genre.ADVENTURE
}
catalogue.add(Attributes(attrs))
An example search is
target_attrs = {
Key.KIND: Kind.FICTION,
Key.LAST: "KING",
Key.GENRE: Genre.HORROR
}
search(catalogue, Attributes(target_attrs))
The string "KING" will match "King" in the catalogue. The output is
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

54
Find {KIND: fiction, LAST: 'KING', GENRE: horror}
Matches:
{KIND: fiction, TITLE: 'Carrie', LAST: 'King', FIRST: 'Stephen', å
YEAR: 1974, GENRE: horror}
{KIND: fiction, TITLE: 'It: A Novel', LAST: 'King', FIRST: å
'Stephen', YEAR: 1986, GENRE: horror}
Missing attributes are don’t-cares, so this search will return all Chinese cookbooks:
target_attrs = {
Key.REGION: Region.China
}
search(catalogue, Attributes(target_attrs))
The output is
Find {REGION: China}
Matches:
{KIND: cookbook, TITLE: 'The Wok of Life', LAST: 'Leung', FIRST: å
'Bill', REGION: China}
{KIND: cookbook, TITLE: 'Chinese Cooking for Dummies', LAST: 'Yan', å
FIRST: 'Martin', REGION: China}
Figure 2.7 shows that after four iterations, we’ve arrived at an application design that successfully
encapsulates changes to the kinds of books and their attributes. Only class Attributes will need
modifications. Classes Book and Catalogue will not require modifications. We can award ourselves a
pot of gold.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

55
Figure 2.7 It took four iterations, including some backtracking, to find the development path to an application
design that successfully encapsulates changes to the kinds of books and their attributes.
This chapter demonstrated developing the book application with four iterations. Virtually all
significant applications will require multiple iterations, often many more than four. The following
chapters will have shorter example programs, and we’ll limit the number of iterations.
2.4 Summary
It usually takes several development iterations to achieve a well-designed
program. Be willing to backtrack from bad design decisions.
The Single Responsibility Principle (SRP) states that a class should be cohesive
and have only one primary responsibility.
The Encapsulate What Varies Principle states that code that can vary should be
isolated to keep its changes from causing other code to change.
The Delegation Principle states that one class can perform work on the behalf of
another class, where the work belongs to a more suitable cohesive class.
The Principle of Least Knowledge states that classes should not know about
each other’s implementation, and so the classes are loosely coupled with few, if
any, dependencies on each other.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

56
The Open-Closed Principle states that a class should be closed for modification
but open for extension to provide both stability and flexibility.
The Code to the Interface Principle states that for runtime flexibility, we should
not write code that can work only with a specific subclass but use polymorphism
and write code that can work with multiple subclasses.
The Don’t Repeat Yourself Principle states that well-designed code does not
contain duplicate copies of code.
OOP is important for good application design, but it’s not a panacea to all design
problems. Be smart about how to apply its concepts. For example, do not create
too many subclasses unnecessarily and thereby make your application too
complex.
Using better data structures can simplify complex code.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

57
3 Get requirements to
build the right application
This chapter covers
Functional and nonfunctional requirements of an application
What are good requirements and how to obtain them
Use cases
The functional specification
Analyzing the requirements to obtain the initial application classes
Before we start worrying about building an application right (make it well-designed), we must ensure
that we’re going to build the right application. An application that doesn’t do what the client wants is
a failed, unsuccessful application, no matter how well designed it may be. The client of an
application can be a future end user (including yourself), your manager who requested you to write
the application, the person who hired you as a software consultant or contractor, or any other
stakeholder who wants a successful application.
In this chapter, we’ll learn how to get good requirements for an application. Then, we’ll see how
to analyze them to obtain the initial set of classes. Remember that requirements can change, and
we must design accordingly and develop iteratively.
3.1 The overture to application design
Figure 3.1 shows a timeline of the major activities and milestones during the application
development. The activities with the bold outlines, which are covered in this chapter, are the crucial
overture to application design.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

58
Figure 3.1 Timeline of the major activities while developing an application. The activities with the bold outlines
are the crucial prelude to application design. The dotted time spans following Get Requirements and
Functional Specification suggest that their freeze dates must be flexible.
Suppose a client has asked you to develop a more advanced version of the book catalogue
application from chapter 2. The client has some ideas about a “book catalogue server” that stores
book data in some sort of database, and library customers searching for books are provided a form
interface where they fill in and submit their desired book attributes. Moreover, a special type of end
user with a librarian role is responsible for adding new books to the catalogue and updating or
removing existing books (figure 3.2).
How can we convert these vague ideas into firm requirements to ensure that the application we
eventually develop will fully satisfy the client? There are two kinds of requirements: functional and
nonfunctional.
Figure 3.2 A more advanced version of the book catalogue application. A librarian interacts with the book
catalogue server to enter new books into the catalogue and to update and remove existing books. A customer
interacts with the server to search for books. The books are stored in a backend database.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

59
3.2 Functional requirements: What must the application do?
A functional requirement states a specific operation that the application must do, or a specific
operation that the application must allow an end user to do, to be a successful application. In
chapter 2, we saw functional requirements for our example book catalogue application. Based on
those requirements, a list of operations that the application must do includes
Storing attributes for all books including the book title and the author’s first and
last names
Storing year and genre attributes for fiction books, a region attribute for
cookbooks, and a subject attribute for how-to books
Performing case-insensitive string matches
Allowing don’t-care target attributes for book searches
Based on the functional requirements, a list of operations the application must allow its end users
to do includes
Adding fiction books, cookbooks, and how-to books to the catalogue
Searching the catalogue for books that match a given set of target attributes
We can rewrite these operations as requirements using strong auxiliary verbs such as must and
shall:
A user must be able to add fiction books, cookbooks, and how-to books and
their attributes to the catalogue.
The attributes for each book shall be the book title and the author’s last and first
names.
The attributes of a fiction book shall include its publication year and genre:
adventure, classics, detective, fantasy, historic, horror, romance, or science
fiction.
The attributes of a cookbook shall include its region: China, France, India, Italy,
Mexico, Iran, or the United States.
The attributes of a how-to book shall include its subject: drawing, painting, or
writing.
A user must be able to search the catalogue for books that match a given set of
target attributes.
String comparisons while matching attributes during book searches shall be
case-insensitive.
A user must be able to specify don’t-care attributes for book searches.
When we listen to what clients tell us and then translate their desires into written requirements, we
should not create statements using weaker auxiliary verbs such as should or could.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

60
3.3 Nonfunctional requirements: Constraints on the application
A nonfunctional requirement imposes a specific restriction or constraint that the application must
satisfy to be successful. These requirements involve issues such as performance, platforms, and
maintainability.
We didn’t list nonfunctional requirements in chapter 2 for our book catalogue application. Here’s
a list of nonfunctional requirements for the application:
A book search must take under 2 seconds.
The application must run on the Windows, macOS, and Linux platforms.
The user interface shall be similar to the UI of the previous version.
Displayed messages shall be customizable to be in English, Spanish, or
Vietnamese.
Do not think that nonfunctional requirements are less important than functional requirements! A
well-designed and fully functional application is a failure if its performance is unacceptable or if it
doesn’t run on the users’ platforms.
INTERNATIONALIZATION NOTE
The last nonfunctional requirement listed above pertains to internationalization, sometimes
abbreviated I18N (because, well, there are 18 letters between the initial I and the final N of
the word). The process of adapting an application to a particular locale is called localization
(L10N) and involves changing the natural language (English, Spanish, etc.) of text messages
and making other text changes such as date, time, monetary formats, and character-
encoding standards. If you’re developing an internationalized application, encapsulate the
affected parts of the application when the locales vary.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

61
A requirement should not state how to design the application to meet the requirement. For
example, the nonfunctional requirement about the user interface does not say to make forms of
the old UI be included in the new UI. Requirements should not include design and implementation
details.
WHAT ARE GOOD REQUIREMENTS?
What makes an ideal set of requirements? Ideal requirements for developing a well-d esigned
application themselves meet the following standards:
Clarity—The requirements must be written clearly in nontechnical and jargon-
free language to be understood by both the client and the software developers.
Consistency—Requirements must not contradict each other. For example, we
cannot have one requirement state that the application must run on Windows
and macOS and another one state that the application must run only on Linux.
Correctness—Each requirement must be correct. For example, a requirement for
a medical application that states that the application must process pregnancy
data from male patients is clearly wrong.
Completeness—Any gaps in the requirements can lead to wrong guesses by the
software developers and result in an application that doesn’t do what the client
wants.
Being realistic—Do not include requirements that can’t be satisfied, such as
overly optimistic performance figures.
Being verifiable—Will it be possible to test the application to ensure that it
satisfies every requirement?
Traceability—Can we trace each requirement to a functionality or constraint of
the application? We don’t want the application to miss satisfying any
requirements. Conversely, can we trace each functionality or constraint to a
requirement? We don’t want to load the application with unwanted features.
3.4 How to get requirements
How do we get requirements for an application? Where do they come from? Because requirements
dictate what will make the application successful, an obvious start is to ask the client about the
application. This may involve an extended set of interviews—unless it’s a trivial application, it most
certainly won’t be a one-time interview. Ask questions and get clarifications. Is this what you want?
What do you mean by that? Do you want the application to do this or that?
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

62
These requirements-gathering interviews require good interpersonal skills. We need to discover
what our client wants and not introduce our own biases. We have a major bridge to gap—we
assume that clients are experts in their domains (such as finance for a banking application),
whereas we’re the software development experts. Clients’ expertise and vocabularies may not have
much in common with ours.
But here’s a major catch: clients do not always know what they want! Do not apply too much
pressure to get requirements out of them, or they may start making things up. Your client may be
thinking, “I’m paying these developers a lot, and they have a deadline. They won’t get going unless I
give them more requirements. I’d better give them something to make them start coding.” This is a
surefire way to get bad requirements, and bad requirements can only lead to bad applications.
Therefore, software developers must work hard to get requirements by other means. One way is
to observe the ways people currently do their tasks and imagine how an application can improve
their performance. Look at specific tasks being done manually or with legacy software and devise
requirements for the application to better automate those tasks.
In some software organizations, team members such as project managers who may have better
communication skills than the programmers are responsible for interviewing the client to get the
initial lists of requirements. However, it’s still important for the developers to have some hands-on
contacts with the problems they are expected to solve.
Many meetings among the members of the development team may be necessary to decide upon
the lists of functional and nonfunctional requirements. In an ideal situation, an application’s client is
made a virtual member of the development team to be always available to answer questions about
requirements. Short of that situation, it is critical to maintain a communication channel between the
developers and their client that is as open as possible. The feedback loop between the client and
the development team must be tight and constantly active.
3.4.1 A short requirements case study
Figure 3.3 shows a simple scenario. Public libraries used to have card catalogues, which were
physical banks of drawers that held index cards containing the attributes of the books in the library.
The cards were alphabetized by book title, author’s last name, and subject. Therefore, each book
required at least three cards. Each drawer was labeled by the range of the alphabet of the cards it
held.
A library customer looking for a book would consult the card catalogue to see if the library had
the book, and if so, the cards indicated where to find it. Librarians maintained the card catalogue. It
was a very manual process for both the librarians and the customers. Therefore, our client, the
head librarian, hired us to automate the catalogue.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

63
Figure 3.3 To automate a library’s old-fashioned card catalogue with a software application, you must first get
the requirements to develop the right application.
We must first get the requirements from the client to develop the right application. We interview
the head librarian to learn how the librarians maintain the card catalogue and to ask what they
think we can do to improve their work. We also interview the library’s customers to understand how
they search for books in the card catalogue and to ask what we can do to improve their searches.
But perhaps the librarians may only be able to suggest incremental improvements to their work,
such as an online form to create and print cards for the drawers. Similarly, the library’s customers
may not have the imagination to come up with better searching methods. Therefore, we must
observe the librarians working and the customers searching and apply our experience with
computer-based applications to come up with more requirements. We can create and show
prototypes of the new application to inspire better requirements. Getting requirements is another
iterative process.
3.4.2 Stated and implied requirements
The librarians and customers provide stated application requirements. By reading between the
lines, we can conceive implied requirements. Yes, our interviewees said that requirements A and C
are needed. But we know from our own experience (or common sense) that they will also need
requirement B to properly automate their operations.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

64
On the timeline in figure 3.1, the client and the developers must agree on the date labeled
“Requirements freeze.” Presumably, there will be no more changes to the requirements after that
date. But often, the collected requirements are less than ideal, so then we should expect they may
still change, and there may still be additional requirements. However, the requirements must settle
shortly after the freeze date to enable software design to stabilize and ultimately to complete the
application on time. Good application design encapsulates the parts of the application that are
most likely to be affected by requirement changes. A well-designed application is flexible enough to
incorporate any resulting new code.
SOFTWARE ENGINEERING
Requirements gathering and analysis is a major topic within the broader subject of software
engineering. Software engineering covers project-level topics, including project management
and schedules; development methodologies (such as extreme programming and test-driven
development); enterprise application architectures; tools for task management, bug tracking,
and software revision control; testing strategies; project documentation; product
deployment and maintenance; and other topics. Software engineering in general, other than
the topic of software design, is outside the scope of this book.
Entire books have been written about how to gather and analyze software requirements.
This book can only give a brief outline of the process.
3.5 Unified Modeling Language diagrams for creating and
documenting design
The Unified Modeling Language (UML) is an industry-standard family of diagrams to help software
developers design an application and document the design. The following section covers UML use
case diagrams that describe to both the application’s client and its developers how an end user will
interact with the application. Chapter 4 covers UML class, state, and sequence diagrams that further
document the application’s design.
UML diagramming is a useful skill in every software developer’s repertoire. Not only are the
diagrams important for documenting an application’s design, but their visual nature makes them
very helpful during software designing and coding.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

65
NOTE Most of the popular computer-based drawing tools provide palettes of the UML objects. During
the development iterations, the diagrams are easy to create and manipulate to keep track of an
application’s evolving design.
3.6 Use cases provide context for the requirements
The lists of functional and nonfunctional requirements for an application are parts of the
documentation that the development team writes to describe the application. Use cases provide
context for the requirements and show how they determine the application’s runtime behavior.
A use case describes how an end user of the application, often with a specified role (such as our
book catalogue application’s customer or librarian), will perform a sequence of actions to achieve a
particular goal. Therefore, we write it from the point of view of that user. Since users can interact
with the application in different ways to achieve various goals, we will need multiple use cases to
cover the major goals.
Documentation of use cases typically consists of two parts. First, a UML use case diagram groups
together several related use cases and shows which users interact with which use cases. The
second part consists of a written use case description for each use case.
3.6.1 UML use case diagram
Figure 3.4 shows an example use case diagram for an advanced version of our book catalogue
application. In this version, a backend database stores the books and their attributes.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

66
Figure 3.4 A UML use case diagram containing the names of six use cases for an advanced version of our book
catalogue application. The labels in the dashed boxes and the dashed arrows indicate the various components
of the diagram. When drawing a use case diagram, do not include these labels and arrows.
The diagram shows the names of several use cases and how various actors interact with them. The
box that encloses the use cases represents the application and its boundary—it’s important to know
what’s in the application and what’s not. The name of each use case should be short and descriptive
in a verb–noun form, such as “Add Book” and “Log in customer.” The figures represent actors who
interact with the use cases. An actor is any agent external to the application that interacts with the
application, and it can be a person (such as the librarian and the customer) or another application
or system (such as the database system). The interaction lines indicate which use cases each actor
can interact with.
A large application may have many use case diagrams, each containing a small number (at most
about a half dozen) of use cases.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

67
3.6.2 Use case description
Use cases provide context for the application’s requirements. They show how the functional
requirements determine the functionality of the application, and they also show which
nonfunctional requirements ensure that the functionality will be practical.
We write a separate use case description for each use case in the use case diagrams. This
description provides detailed information about the use case:
Name of the use case—It should be short and descriptive in a verb–noun form.
Goal—What is the actor trying to achieve?
Summary of the use case—A short (one or two sentences) description.
Actors—Who or what interacts with this use case?
Preconditions—What must be true, or what must have already happened, before
this use case can go into action? References to other use cases can appear here.
Trigger—What did an actor do to start this use case? Write the following
sequence of action steps from the point of view of this actor.
Primary action sequence—A sequence of action steps that occur during this use
case between the triggering actor (and any other actors) and the application.
There should be no more than about 10 steps. If you need more steps, the use
case may be too complex and should be broken up. The steps can refer to other
use cases.
Alternate action sequences—What action steps should occur if something goes
wrong during the primary sequence?
Postconditions—What will be the situation when this use case is finished?
Nonfunctional requirements—Which nonfunctional requirements apply to this
use case?
Glossary—Define any terms in this use case that a reader may find confusing.
Write each use case from the point of view of the actor that triggers the use case.
Here is an example of a use case description for the advanced version of our book catalogue
application. The customer fills out an online form that includes a “Search” button to specify the
desired target book attributes to do a book search.
Name of the use case—Search Catalogue.
Goal—Search the book catalogue for books that match the customer’s target
attributes.
Summary of the use case—The customer searches the book catalogue using a set
of target book attributes, and the catalogue returns a list of any books that
match those attributes.
Actors—The customer and the backend database.
Preconditions—Books and their attributes are already loaded into the catalogue.
See the use case Add Book. The customer has completed filling the Attributes
form with the target book attributes. See the use case Complete Form.
Trigger—The customer presses the “Search” button.
Primary action sequence:
1. The application verifies that the Attributes form is correctly filled out.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

68
2. The application formulates a database query from the book attributes in the
form.
3. The application sends the query to the backend database server.
4. The database returns a list of matching books to the application.
5. The application formats the list of matching books for presentation.
6. The customer sees the list of matching books.
Alternate action sequence 1—Incorrectly filled form. Replace primary sequence
steps 2–6.
2. Highlight the incorrect form field.
3. Display an explanatory error message.
4. The customer corrects the erroneous form field.
5. Return to primary sequence step 1.
Alternate action sequence 2—No matching books. Replace primary sequence
steps 4–6.
4. The database returns an empty list.
5. The application displays “No books found.”
Postconditions—The customer sees either a list of matching books or the
message “No books found.” There were no changes to the book catalogue.
Nonfunctional requirements:
Search results must return in under 2 seconds.
The customer shall be on a Windows, macOS, or Linux platform.
The application must be usable by a customer whose native language is English,
Spanish, or Vietnamese.
Glossary:
Catalogue—A searchable repository of books and their
attributes
Attribute—A feature of a book that can be matched during a
search, such as the book title or the author’s name
Customer—A user who searches the book catalogue
Use case descriptions should be short, simple, and informal. Both the application’s clients and its
developers need to understand them. Therefore, we should not use overly technical language.
There should be no implementation details. We must concentrate on what the application needs to
do in response to an actor’s triggering action, not how the application will do it.
Requirements come from a continuous engagement with the client of the application. Write
down the requirements that are known so far and create use cases. The use cases illustrate for the
client how the application will behave under various scenarios. This can inspire more requirements.
New requirements may, in turn, require new use cases. There may be several rounds of adding new
requirements and creating new use cases. A substantial application with a rich set of actor
interactions can have dozens of use cases.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

69
A powerful way to elicit requirements is to show the client a prototype of the application. This
can be some quick-and-dirty code that shows a few key use cases in action. Seeing a tangible piece
of working code, however hacked together, will often inspire the client to point out what’s missing
or superfluous, or what doesn’t work in a desired way. This prototype can be as simple as a deck of
slides containing simulated screenshots of the application as it’s being used. We then capture
comments and observations by the client in new requirements, or we modify existing ones.
3.7 The functional specification and software validation
The development team writes a functional specification to document the application it’s about to
create. Its purpose is to inform both the application’s client and the developers in nontechnical,
jargon-free language.
NOTE The format and contents of the functional specification are usually determined by the client’s
organization. Different organizations might give the document different names, such as External
Reference Specification. It’s external because this document views the application from the outside.
It should contain no internal implementation details. Implementation details belong in the design
specification covered in chapter 4.
The functional specification should include the following content:
Application name—For example, Book Catalogue.
Clear problem statement—What is the problem that this application addresses?
For example, the ability to store and search for books.
Objectives—What is the application supposed to accomplish? For example, to
create a means to enter books into a repository and then search for them using
target book attributes.
Functional requirements—A list of the functional requirements. The requirements
should be stated strongly with the auxiliary verbs must or shall.
Nonfunctional requirements—A list of the nonfunctional requirements. The
requirements should be stated strongly with the auxiliary verbs must or shall.
Use cases—UML use case diagrams and a use description for each use case.
A functional specification can also include an external test plan, a deployment plan, and a
maintenance plan. These are often separate documents.
If it’s included, the external test plan should describe black-box tests. These are tests that are
doable without knowing the internals of the application code. For each test, the test plan describes
what the input data or user action should be and the expected result. Black-box testing helps to
verify that an application meets its functional and nonfunctional requirements. Such tests are often
run by test engineers who were not part of the development team.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

70
How elaborate should the functional specification be? That often depends on the client’s
organization and the development methodology. Some organizations and methodologies place less
emphasis on documentation and favor prototyping and tighter engagement with the client. Other
organizations regard the functional specification to be such an important document that they go to
the extreme of considering it to be a contract between the client and the software developers. They
may require multiple levels of management to sign off a complete functional specification and then
deem it frozen before allowing the developers to move on to designing the application.
But ideally, as suggested in figure 3.1 by the dotted time span, we should be allowed to modify
the functional specification when we need to tweak requirements or discover new ones during
application design and coding. It should be modifiable up to a certain point in time, often called the
“features freeze,” agreed to by the developers and the client. Even though it’s initially moveable, the
functional specification serves as an important stake in the ground for both the developers and the
client.
Regardless of whether it rises to the level of a contract, it is critical that the client of the
application carefully read the functional specification, which should have no implementation details.
By reading, understanding, and approving the functional specification, the client validates the
application, that is, confirms that we are going to build the right application, one that meets the
client’s requirements.
Once the application is validated (remember that clients can still change their minds about the
requirements), we can begin the design–code–test iterations. Testing is verification that we are
building the software right—that we are implementing bug-free code to fulfill each and every
requirement.
NOTE Software verification and validation (software V&V) is a major topic in the fields of software
engineering and software quality control.
3.8 Where do classes come from?
Once we have at least the first draft of the functional specification, we can start to think about the
classes of the application. To create the initial set of classes, analyze the application’s functional
requirements. Requirements analysis, the process of carefully examining an application’s
requirements during design, is a major software engineering topic. The rest of this chapter covers
its most important points.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

71
Here is an extended set of functional requirements for the more advanced version of our book
catalogue application from chapter 2. Recall that functional requirements state what an application
must do or allow a user to do:
The book catalogue shall store different kinds of books and their attributes.
A librarian must be able to add new books to the catalogue.
A librarian must be able to update and delete existing books in the catalogue.
The kinds of books shall include fiction, cookbooks, and how-to.
All books must have title, author’s last name, and author’s first name attribute
values.
Fiction books must include the publication year and genre attributes.
Genre must include adventure, classics, detective, fantasy, historic, horror,
romance, and science fiction.
Cookbooks must include the region attribute.
How-to books must include the subject attribute.
A customer must be able to search the catalogue by providing any number of
desired target attribute values.
A customer must complete a web browser-based form to specify target attribute
values for book searches.
A customer’s input in the form must be verified for correct format and values.
During searches, string attribute matches must be case-insensitive.
A customer must be able to specify any number of don’t-care (wildcard) target
attributes.
Each don’t-care attribute must, by default, match the corresponding attribute in
all books in the catalogue.
A book in the catalogue shall match if it has all the attributes in the customer’s
target attributes and all the corresponding book and target attribute values are
equal, or the target attribute is a don’t-care.
3.8.1 Textual analysis: Nouns can become classes
Recall from section 1.8 that a class specifies the state and behavior of its objects at run time. To
determine what classes our application should have, first find the nouns in the requirements: book,
catalogue, attribute, librarian, customer, kind, title, name, year, genre, region, subject, browser, form,
input, and string. The nouns represent potential classes, but as shown in table 3.1, it’s a judgment
call which nouns should become classes and which should become attributes in our application.
This is the type of design decision that we may need to revisit during the development iterations.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

72
Table 3.1 Decide whether each noun of the requirements should be a class.
Noun Class?
catalogue Yes. The application implements a book catalogue.
Book Yes. The catalogue stores book objects.
attribute Yes. Each book object has a set of attributes.
librarian No. According to figure 3.4, a librarian is an agent
outside of the application.
customer No. According to figure 3.4, a customer is an agent
outside of the application.
kind No. It is an attribute value that is an enumeration
constant.
title No. It is an attribute value that is a string.
name No. It is an attribute value that is a string.
year No. It is an attribute value that is an integer.
genre No. It is an attribute value that is an enumeration
constant.
region No. It is an attribute value that is an enumeration
constant.
subject No. It is an attribute value that is an enumeration
constant.
browser No. The application works with existing browsers.
form Yes. The application manages a user input form.
input No. It is an attribute value entered by a user into a
form.
format No. A format isn’t a separate thing in the application.
value No. An attribute value is an integer, string, or
enumeration constant.
string No. The application uses built-in Python strings.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

73
We are left with these nouns that can become the initial classes in our application: catalogue, book,
attribute, and form. For each class, we must determine its instance variables so that its objects can
maintain state at run time. Table 3.2 can be the result after several design iterations like the ones
described in chapter 2. Later iterations can discover more classes.
Table 3.2 The initial classes of the application
Class State Instance variables
Catalogue List of books _booklist (list of Book objects)
Book Book attributes _attributes (the book’s attributes)
Attributes Attribute values _dictionary (dictionary of key–value pairs)
Form Input values individual instance variables for the book attributes
3.8.2 Textual analysis: Verbs can become methods
Next, we must determine the runtime behavior of each class’s objects from the verbs in the
requirements: store, add, update, delete, include, have, be, search, complete, verify, constitute, specify,
and match. We should consider only (transitive) verbs that perform some action on an object. Like
table 3.2, table 3.3 can be the result after several design iterations.
Table 3.3 Determine the behavior of each class.
Verb Class Method
add Catalogue add() a book to the booklist
update Catalogue update() a book in the booklist
delete Catalogue delete() a book from the booklist
search Catalogue find() matching books in the booklist
verify Form verify() user input in the form fields
match Attributes is_match() check if attributes match
Each class’s methods work with that class’s instance variables. For example, in class Catalogue, the
add() method appends Book objects to the _booklist instance variable.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

74
Now that we have some initial classes, we need to make sure to design them and any subsequent
classes well. That’s the topic of the next chapters.
3.9 Summary
Functional requirements state what an application must do, or allow a user to
do, for the application to be successful.
Nonfunctional requirements impose restrictions or constraints that the
application must meet to be successful. They are just as important as functional
requirements. Examples are performance or platform requirements.
State requirements using the strong verbs must and shall.
Getting good requirements is crucial. Interview the application’s clients or
observe how people currently perform their tasks. Create prototypes of the
application to show to the clients. Imagine ways an application can improve
their productivity.
Requirements come from a continuous engagement with clients, who may not
always know what they want. Be prepared for the requirements to change
during application design and even during coding.
Good requirements are clear, consistent, correct, complete, realistic, verifiable,
and traceable.
Use cases provide context for the requirements and show how they determine
the application’s functionality. Document the use cases with UML use case
diagrams and use case descriptions. Use cases can inspire new requirements.
A functional specification written in nontechnical, jargon-free language informs
both the clients and the software developers what the application will do. It can
include an external test plan for black-box testing. Some organizations consider
this document to be a contract between clients and developers. Ideally, it should
be modifiable (up until the features freeze milestone) to accommodate changes
to the requirements.
Clients validate that the software developers are going to build the right
application by approving the functional specification. The developers verify that
they are building the application right through testing. Software verification and
validation (software V&V) is a major topic in the fields of software engineering
and software quality control.
Analyze the requirements to obtain the initial set of classes for the application.
Determine which nouns become classes and which verbs become methods that
implement behavior. Assign instance variables and methods to the classes.
Don’t fall victim to paralysis by analysis. Create and show prototypes, start the
development iterations, and more classes will arise.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

75
4 Good class design to
build the application right
This chapter covers
The place of design in the application development process
How to design classes well
UML diagrams to aid class design
The design specification
In chapter 3, we worked with our clients on the functional and nonfunctional requirements to
ensure that we build the right application. Simple textual analysis produced our initial set of classes.
In this chapter, we begin to design the classes well to ensure that we build the application right.
In chapter 1, we learned that design is a disciplined engineering approach to create a solution to
a problem. For software development, that means applying good software design techniques to
find the best development path to a well-designed application that meets its requirements. In
chapter 2, we saw that the development path requires iterations and, most likely, backtracking.
This chapter discusses where application design fits within the overall development process. It
covers some basic guidelines for good class design. Because most applications consist of multiple
classes, we’ll also examine how the classes can relate to each other. Chapter 3 introduced UML
(Unified Modeling Language) use case diagrams. To document our class design, we’ll use more of
these industry-standard diagrams. Finally, a design specification pulls together all the design
documentation for an application.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

76
4.1 When do we do application design?
A major application is often created by several software developers working together as a team,
with various activities overlapping over time. This chapter covers the design activities with the bold
borders in figure 4.1.
Application design occurs during nearly the entire project. As we saw in chapter 3, we must first
get the application’s requirements. Creating use cases and prototypes help to elicit requirements.
The Functional Specification documents the requirements and use cases. We can choose the
application’s initial classes from its requirements. Some of the prototypes may result in more
classes. Most of the application design subsequently occurs during the development iterations,
where we expand and refine the initial set of classes. This chapter covers how to document our
class design for our own benefit and for the design specification.
Figure 4.1 Creating an application involves many activities. This diagram shows when the activities start
relative to each other and how they overlap in time. However, it does not show their relative durations. The
major project milestones are presented at the bottom. Most of the application design occurs during the
development iterations. The design specification documents our design. This diagram shows these activities
with heavy borders. Their dotted timespans suggest that their freeze dates must be flexible.
Both external black box testing (described in chapter 3) and internal testing (described later in this
chapter) occur in parallel with the development iterations.
The bottom of the diagram shows milestone dates, such as “Project Start,” “Requirements
Freeze,” “Features Freeze,” and so forth, that a project schedule maintains. These are goals that the
project team should meet to get an application deployed on time. However, many projects slip their
freeze milestones. For example, the project manager may agree that new requirements are
important enough to be included in the project past the requirements’ freeze milestone. If we allow
a project to slip much past a milestone freeze date, we greatly increase the risk of not completing
the project on time.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

77
4.2 Two important goals for good class design
In chapter 3, we saw how performing a textual analysis of the requirements gives us a good start at
determining our application’s classes. But how can we be certain that we’ve put the instance
variables and methods in the right classes? When we design classes, there are two important goals:
cohesion and loose coupling.
4.2.1 Cohesion and the Single Responsibility Principle
A class is cohesive if it adheres to the Single Responsibility Principle (section 2.3.1). A well-designed
class should have only one primary responsibility. Let’s revisit the Automobile class from listing 1.3:
Listing 4.1 (Program 4.1 Automobile-1): automobile.py (not cohesive)
class Automobile:
def __init__(self):
self._brakes = [] #A
self._engine = None #A
self._engine_oil = None #A
self._heading = None #A
self._headlights = [] #A
self._speed = None #A
self._soap = None #A
self._tires = [] #A
self._vacuum_cleaner = None #A
def accelerate(self): #B
print("Accelerating.")
def adjust_headlights(self): #B
print("Adjusting headlights.")
def apply_brakes(self): #B
print("Applying brakes.")
def change_oil(self): #B
print("Changing oil.")
def change_tires(self): #B
print("Changing tires.")
def check_brakes(self): #B
print("Checking brakes.")
def check_tires(self): #B
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

78
print("Checking tires.")
def rotate_tires(self): #B
print("Rotating tires.")
def shut_off_engine(self): #B
print("Shutting off engine.")
def start_engine(self): #B
print("Starting engine.")
def tuneup_engine(self): #B
print("Tuning up engine.")
def turn_left(self): #B
print("Turning left.")
def turn_right(self): #B
print("Turning right.")
def vacuum_car(self): #B
print("Vacuuming car.")
def wash_car(self): #B
print("Washing car.")
def wax_car(self): #B
print("Waxing car.")
#A State information
#B Behaviors
This class is not cohesive because it has too many state and behavior responsibilities:
automobile operation
state— _brakes, _engine, _heading, _speed
behavior—accelerate(), apply_brakes(), shut_off_engine(),
start_engine(), turn_left(), turn_right()
automobile maintenance
state—_engine_oil, _headlights, _tires
behavior—adjust_headlights(), change_oil(), change_tires(),
check_brakes(), check_tires(), rotate_tires(), tuneup_engine()
automobile cleaning
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

79
state—_soap, _vacuum_cleaner, _wax
behavior— vacuum_car(), wash_car(), wax_car()
We need to break class Automobile into smaller classes, each of which has a single primary
responsibility.
Listing 4.2 (Program 4.2 Automobile-2): automobile.py (cohesive)
class Automobile: #A
def __init__(self):
self._brakes = []
self._engine = None
self._engine_oil = None
self._heading = None
self._headlights = []
self._speed = None
self._soap = None
self._tires = []
self._vacuum_cleaner = None
def accelerate(self):
print("Accelerating.")
def apply_brakes(self):
print("Applying brakes.")
def shut_off_engine(self):
print("Shutting off engine.")
def start_engine(self):
print("Starting engine.")
def turn_left(self):
print("Turning left.")
def turn_right(self):
print("Turning right.")
class Garage: #B
def __init__(self, car):
self._car = car
self._new_oil = None
self._new_tires = []
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

80
def adjust_headlights(self):
print("Accelerating.")
def change_oil(self):
print("Changing oil.")
def change_tires(self):
print("Changing tires.")
def check_brakes(self):
print("Checking brakes.")
def check_tires(self):
print("Checking tires.")
def rotate_tires(self):
print("Rotating tires.")
def tuneup_engine(self):
print("Tuning up engine.")
class CarWash: #C
def __init__(self, car):
self._car = car
self._vacuum_cleaner = None
self._wax = None
def vacuum_car(self):
print("Vacuuming car.")
def wash_car(self):
print("Washing car.")
def wax_car(self):
print("Waxing car.")
#A Responsible for automobile operations
#B Responsible for automobile maintenance
#C Responsible for automobile cleaning
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

81
Each of these classes is cohesive with a single primary responsibility. Class Automobile is
responsible for automobile operations. Class Garage is responsible for automobile maintenance.
Class CarWash is responsible for automobile cleaning. The constructors of the latter two classes
each has parameter car, the Automobile object, and perform their operations on that object. The
Single Responsibility Principle is important for good class design. If changes are necessary, a
cohesive class should have only one reason to change.
4.2.2 Loose coupling and the Principle of Least Knowledge
Loosely coupled classes have minimal dependencies on each other. Class A is dependent on class B
if class A has references to class B. For example, class Garage depends on class Automobile because
its instance variable _car is assigned an Automobile object.
Loosely coupled classes adhere to the Principle of Least Knowledge (section 2.3.2), which
supports encapsulation. The less class A knows about the internal implementation details of class B,
the less likely changes to class B will affect class A.
We saw an example of the Principle of Least Knowledge in chapter 2. The dependency that class
Catalogue (reproduced below) had on class Attributes was only through parameters attrs and
target_attrs, which the class simply passed as arguments to other methods. The class required no
knowledge of how class Attributes implemented the book attributes.
Listing 4.3 (Program 2.4 Books-4): catalogue.py
from book import Book
class Catalogue:
def __init__(self):
self._booklist = []
def add(self, attrs):
book = Book(attrs)
self._booklist.append(book)
def find(self, target_attrs):
return [book for book in self._booklist
if book.attributes.is_match(target_attrs)
]
Class Attributes (reproduced below) had no dependencies at all on class Catalogue. It had no
instance variables, parameters, or local variables that referred to Catalogue objects. Therefore,
Attributes objects do not know that they are ultimately stored in a Catalogue object. Even though
class Catalogue delegated attribute matching to class Attributes by calling the latter’s Boolean
is_match() method, class Attributes did not know who was calling that method.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

82
Listing 4.4 (Program 2.4 Books-4): attributes.py
from key import Key
from kind import Kind
from genre import Genre
from region import Region
from subject import Subject
class Attributes:
@staticmethod
def _equal_ignore_case(target_str, other_str):
if len(target_str) == 0:
return True;
else:
return target_str.casefold() == other_str.casefold()
def __init__(self, dictionary):
self._dictionary = dictionary
for key, value in dictionary.items():
if key == Key.YEAR:
assert(isinstance(value, int))
elif key in [Key.TITLE, Key.LAST, Key.FIRST]:
assert(isinstance(value, str))
elif key == Key.KIND:
assert(isinstance(value, Kind))
elif key == Key.GENRE:
assert(isinstance(value, Genre))
elif key == Key.REGION:
assert(isinstance(value, Region))
elif key == Key.SUBJECT:
assert(isinstance(value, Subject))
def _is_matching_key_value(self, target_key, target_value):
if target_key not in self._dictionary.keys(): return False
if self._dictionary[target_key] == target_value: return True
if isinstance(target_value, str):
return Attributes._equal_ignore_case(
self._dictionary[target_key], target_value)
def is_match(self, target_attrs):
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

83
for target_key, target_value \
in target_attrs._dictionary.items():
if not self._is_matching_key_value(target_key,
target_value):
return False
return True
def __str__(self):
last_key = list(self._dictionary.keys())[-1]
ostr = '{'
for key, value in self._dictionary.items():
ostr += str(key.name) + ': '
if isinstance(value, str):
ostr += "'" + value + "'"
else:
ostr += str(value)
if key != last_key: ostr += ', '
ostr += '}'
return ostr
Classes Catalogue and Attributes are loosely coupled. We saw how loose coupling encapsulates any
changes in class Attributes from affecting class Catalogue. Loose coupling and the Principle of Least
Knowledge are important for good class design.
4.3 UML class diagrams to document class design
We saw UML use case diagrams in chapter 3. UML class diagrams document class design. A class
diagram consists of at least the name of the class. Optionally, it includes the names and datatypes
of the class’s instance variables and the signature of its methods. A method’s signature consists of
the name of the method, the name and datatype of each parameter, and the datatype of the return
value.
NOTE Google “UML drawing tools” for tools to draw these diagrams. Some of the tools are free.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

84
Figure 4.2 shows four possible UML class diagrams for the class Catalogue (listing 4.3). The first
diagram only shows the class name. The second diagram includes the instance variables but not the
methods. The third diagram includes the methods in the bottom section but not the instance
variables in the empty middle section. The fourth diagram includes the instance variables (middle
section) and the methods (bottom section). The selection of diagram depends on how much detail
about the class we need to show. A diagram in a high-level description of the application could
show less than a diagram in a low-level description.
Figure 4.2 Possible UML class diagrams for class Catalogue that include different amounts of information. A
plus sign (+) indicates what is intended to be public, and a minus sign (-) indicates what is intended to be
private. How much information to include in a class diagram depends on whether the diagram is in high-level or
low-level design documentation of the application.
PRIVATE INSTANCE VARIABLES AND METHODS
Section 2.3 described how to indicate in Python classes that certain instance variables and
members are meant to be private.
The minus sign (-) in front of a name indicates that the member is private, and the plus sign (+)
that the member is public. The datatype of a instance variable follows the name and a colon. The
signature of each method does not need to include every detail about the parameters; we only
show their datatypes. It’s not necessary to include the constructors and the destructor of a class. If
the method returns a value, put a colon after the parameters followed by the return value’s
datatype. Unless it’s important to show them, we can leave out getter and setter methods. Figure
4.3 is a possible UML class diagram for class Attributes (listing 4.4).
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

85
Figure 4.3 A UML class diagram for class Attributes that includes all three parts: its name, instance
variables, and methods. Private method _equal_ignore_case() is underlined to indicate that it is a Class
relationships determine runtime interactions
Most applications consist of multiple classes, especially if they are well-designed, cohesive classes.
The relationship between two classes determines how their objects can interact at run time.
Therefore, it’s important during class design to get the relationships right.
A class diagram that includes an application’s classes should also indicate the relationships
among them by connecting the diagrams with lines. Figure 2.5 in chapter 2, also reproduced in
figure 4.4, is such a diagram.
Figure 4.4 A UML class diagram that shows an application’s multiple classes and their relationships. The
relationship between two classes determines how their instantiated objects can interact at run time.
Table 4.1 at the end of section 4.4.4 will summarize the ways to specify the different relationships
with class diagrams.
4.3.1 Dependency: The most basic relationship
A line connecting two classes, like the one between Book and Attributes in figure 4.4, represents a
dependency relationship. Just as we can choose the amount of information to show for each class,
we can also choose how much information to show about each relationship. A simple line between
two classes indicates an unspecified dependency relationship. This gives the least amount of
relationship information. An arrowhead clarifies who depends on whom. In figure 4.5, class
Catalogue depends on class Book (since a Catalogue object contains Book objects), but class Book
does not depend on class Catalogue.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

86
Figure 4.5 A UML diagram that shows (left to right) class Catalogue, a relationship, and class Book. The
dependency relationship arrow going from class Catalogue to class Book indicates that class Catalogue
depends on class Book. But class Book does not depend on class Catalogue.
If we want to include more information about a relationship between two classes, we can label the
dependency arrows (figure 4.6). For example, instance variable _booklist of class Catalogue is a list
of Book objects (listing 4.3). When we label a relationship arrow with the instance variable name, we
don’t include the name in the middle section of the class diagram. Figure 4.6 also indicates
multiplicity: a single (1) _booklist in a Catalogue object will contain zero or more (*) Book objects. A
plus (+) means one or more. When it’s appropriate, we can replace a * or a + with a specific number.
At either end of the relationship arrow, we can even indicate a range of numbers like 2..5.
Figure 4.6 Diagrams that show more design detail. Class Catalogue depends on class Book via its private
booklist instance variable. The multiplicity indicators show that a single (1) Catalogue object can contain
zero or more (*) Book objects.
A dependency relationship is transient if class A has a method f that has a parameter or a local
variable that is assigned a class B object. However, class A does not have a instance variable that is
assigned a class B object. The relationship is transient because it exists only during a call to method
f. In class Catalogue (listing 4.3), the add() and find() methods each receives an Attributes object
(attrs and target_attrs, respectively). But class Catalogue does not have an instance variable that will
be assigned an Attributes object. Therefore, the dependency on class Attributes exists only during a
call to add() or to find(). Figure 4.7 shows this transient dependency relationship with the dashed
arrow.
Figure 4.7 Class Catalogue has a transient dependency relationship on class Attributes, as shown by the
dashed dependency arrow. The add() method of class Catalogue receives a reference to an Attributes
object and the find() method is passed a reference to an Attributes object. The dependency exists only
during calls to these methods.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

87
4.3.2 Aggregation and composition: Objects that contain other objects
UML class diagrams can be more precise in terms of the nature of a dependency. When a class
aggregates (contains) another class, such as by having a instance variable that can hold an object of
the other class, we can use the aggregation arrow that has an open diamond at the tail end next to
the diagram for the container class (there is no arrowhead). Figure 4.8 explicitly shows that class
Catalogue aggregates class Book. Each Catalogue object contains zero or more Book objects. In this
example, we chose to include the information that _booklist is a list of Book objects.
Figure 4.8 Class Catalogue aggregates class Book. Each Catalogue object contains zero or more Book
objects in a list instance variable named booklist. The open diamond at the tail of the dependency arrow is
next to the diagram for the container class Catalogue.
We can be even more precise about an aggregation relationship. A UML class diagram indicates a
composition type of aggregation with a filled-in diamond at the tail of the arrow (figure 4.9).
Composition is a stronger form of aggregation. We can choose to specify composition if,
according to the logic of the application, the object that’s a part of the composition cannot exist
outside of its container. In figure 4.9, an Attributes object cannot logically exist without its Book
object. In contrast, with the Catalogue-Book aggregation, a Book object can logically exist outside of
a Catalogue object.
Figure 4.9 Class Book is composed of class Attributes. Each Book object has one Attributes object.
According to the logic of the application, an Attributes object cannot exist without being a part of a Book
object.
Figure 4.10 shows both an aggregation relationship and a composition relationship to illustrate
their difference. According to the logic of a hypothetical application, Book objects are contained by
Bookshelf objects, but Book objects can exist outside of Bookshelf objects. A Bookcase object is
composed of Bookshelf objects, but a Bookshelf object cannot exist without being a part of a
Bookcase object.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

88
Figure 4.10 The difference between aggregation and composition. In this diagram, each Bookshelf object can
contain 0 through 25 Book objects, and Book objects can exist outside of Bookshelf objects. Each Bookcase
object is composed of 1 through 5 Bookshelf objects, but a Bookshelf object cannot exist without being a
part of a Bookcase object.
4.3.3 Generalization: Superclasses and their subclasses
The generalization relationship involves superclasses, subclasses, and inheritance. The general class
is the superclass.
After three development iterations of our book catalogue application in chapter 2, we had
designed (poorly, as it turned out) a Book superclass and Fiction, Cookbook, and Howto subclasses.
A UML diagram shows a superclass–subclass relationship with an arrow going from the subclass to
the superclass, and the arrowhead is an open triangle against the superclass. Figure 4.11 also
shows superclass Attributes and its subclasses FictionAttrs, CookbookAttrs, and HowtoAttrs with a
different way of drawing the arrows. We can choose the way to draw the arrows depending on
which looks the best for a diagram.
Figure 4.11 Superclass Book has subclasses Fiction, Cookbook, and Howto. Also, superclass Attributes
has subclasses FictionAttrs, CookbookAttrs, and HowtoAttrs. This figure shows two ways of drawing
generalization diagrams.
4.3.4 Abstract classes and interfaces: What subclasses must implement
A class is abstract if it is derived from the Python-supplied class ABC (for Abstract Base Class). Listing
4.5 shows abstract class MotorVehicle with two abstract methods start_engine() and stop_engine().
We then must implement these two methods in subclasses such as Car and Truck. Class
MotorVehicle provides default implementations of methods accelerate(), turn_left(), turn_right(),
apply_brakes(), and drive() that the subclasses can choose whether to override.
Listing 4.5 (Program 4.3 VehicleAbstract): motorvehicle.py
from abc import ABC, abstractmethod
class MotorVehicle(ABC):
def __init__(self):
self._brakes = [] #A
self._engine = None #A
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

89
self._heading = None #A
self._speed = 0 #A
@abstractmethod
def start_engine(self): #B
pass
@abstractmethod
def stop_engine(self): #B
pass
def accelerate(self):
print('vehicle accelerates')
def turn_left(self):
print('vehicle turns left')
def turn_right(self):
print('vehicle turns right')
def apply_brakes(self):
print('vehicle applies brakes')
def drive(self):
self.start_engine();
self.accelerate();
self.turn_left();
self.turn_right();
self.apply_brakes();
self.stop_engine();
#A Instance variables to be inherited by the subclasses
#B Abstract methods to be implemented by the subclasses
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

90
ABSTRACT CLASSES
An abstract class is a subclass of abc.ABC (for abstract base class). It contains one or more
abstract methods created by the decorator @abstractmethod. An abstract method should
not contain any code other than pass. An abstract class can contain instance variables and
non-abstract methods.
Subclasses of the abstract class, known as its concrete subclasses, must implement (have code
for) each of the abstract methods. Therefore, an abstract class forces each concrete subclass
to implement its own behaviors. A subclass that doesn’t implement all of the abstract
methods is itself abstract.
It is an error to attempt to create an instance of an abstract class. We can only create
instances of its concrete subclasses.
Subclass Car implements methods start_engine() and stop_engine(), and it inherits the remaining
methods from its superclass MotorVehicle.
Listing 4.6 (Program 4.3 VehicleAbstract): car.py
from motorvehicle import MotorVehicle
class Car(MotorVehicle):
def start_engine(self): #A
print('car starts engine')
def stop_engine(self): #A
print('car stops engine')
#A Implement abstract methods.
Subclass Truck implements methods start_engine() and stop_engine(). It also overrides the
superclass implementations of methods turn_left() and turn_right().
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

91
Listing 4.7 (Program 4.3 VehicleAbstract): truck.py
from motorvehicle import MotorVehicle
class Truck(MotorVehicle):
def start_engine(self): #A
print('truck starts engine')
def stop_engine(self): #A
print('truck stops engine')
def turn_left(self): #B
print('truck turns left')
def turn_right(self): #B
print('truck turns right')
#A Implement abstract methods.
#B Override superclass methods.
Figure 4.12 shows that in the UML class diagram for this example program, we indicate that a class
is abstract by printing its name in italics or a slanted font. We also print the name of an abstract
method in italics or a slanted font.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

92
Figure 4.12 Class MotorVehicle is abstract, so its name is in a slanted font. Its methods start_engine()
and shut_off_engine() are abstract, and so they are also in a slanted font. Subclasses Car and Truck must
implement these abstract methods. The relationship arrow with the open triangle points to the superclass.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

93
The test program main.py creates Car and Truck objects and calls the inherited drive() method on
each.
Listing 4.8 (Program 4.3 VehicleAbstract): main.py
from car import Car
from truck import Truck
if __name__ == '__main__':
car = Car()
car.drive()
print()
truck = Truck()
truck.drive()
The output from the program is
car starts engine
vehicle accelerates
vehicle turns left
vehicle turns right
vehicle applies brakes
car stops engine
truck starts engine
vehicle accelerates
truck turns left
truck turns right
vehicle applies brakes
truck stops engine
INTERFACE CLASSES
An interface class is an abstract class that contains only abstract methods and no instance
variables. It serves as a model or blueprint for the concrete subclasses that implement the
interface. An interface class defines all the behaviors that a subclass must have and forces
the subclass to implement all of them.
Class MotorVehicalInterface below is an interface class.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

94
Listing 4.9 (Program 4.4 VehicleInterface): motorvehicleinterface.py
from abc import ABC, abstractmethod
class MotorVehicleInterface(ABC):
@abstractmethod
def start_engine(self): #A
pass
@abstractmethod
def stop_engine(self): #A
pass
@abstractmethod
def accelerate(self): #A
pass
@abstractmethod
def turn_left(self): #A
pass
@abstractmethod
def turn_right(self): #A
pass
@abstractmethod
def apply_brakes(self): #A
pass
@abstractmethod
def drive(self): #A
pass
#A Only abstract methods
In this version, class Car must implement all the abstract methods of the interface.
Listing 4.10 (Program 4.4 VehicleInterface): car.py
from motorvehicleinterface import MotorVehicleInterface
class Car(MotorVehicleInterface):
def __init__(self):
self. _brakes = []
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

95
self._engine = None
self._heading = None
self._speed = 0
def start_engine(self):
print('car starts engine')
def stop_engine(self):
print('car stops engine')
def accelerate(self):
print('car accelerates')
def turn_left(self):
print('car turns left')
def turn_right(self):
print('car turns right')
def apply_brakes(self):
print('car applies brakes')
def drive(self):
self.start_engine()
self.accelerate()
self.turn_left()
self.turn_right(
self.apply_brakes()
self.stop_engine()
Similarly, class Truck must implement all the methods.
Listing 4.11 (Program 4.4 VehicleInterface): truck.py
from motorvehicleinterface import MotorVehicleInterface
class Truck(MotorVehicleInterface):
def __init__(self):
self._brakes = []
self._engine = None
self._heading = None
self._speed = 0
def start_engine(self):
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

96
print('truck starts engine')
def stop_engine(self):
print('truck stops engine')
def accelerate(self):
print('truck accelerates')
def turn_left(self):
print('truck turns left')
def turn_right(self):
print('truck turns right')
def apply_brakes(self):
print('truck applies brakes')
def drive(self):
self.start_engine()
self.accelerate()
self.turn_left()
self.turn_right()
self.apply_brakes()
self.stop_engine()
Figure 4.13 shows that in its UML class diagram, the label «interface» appears above the interface
name MotorVehicleInterface. Dashed relationship arrows indicate that classes Car and Truck
implement the interface. In a class diagram for an interface, italics or a slanted font is not
necessary.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

97
Figure 4.13 The label «interface» appears above the name of interface MotorVehicleInterface. All of its
methods are abstract, and it contains no instance variables. The dashed relationship arrow with the open
triangle indicates that subclasses Car and Truck implement the interface, and therefore, they must provide
code for all the methods of the interface.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

98
Using the same test program, the output becomes
car starts engine
car accelerates
car turns left
car turns right
car turns applies brakes
car stops engine
truck starts engine
truck accelerates
truck turns left
truck turns right
truck turns applies brakes
truck stops engine
Table 4.1 summarizes the relationship lines and arrows in UML class diagrams.
Table 4.1 Relationship lines and arrows in UML class diagrams
4.4 UML state diagram: How an object changes state
UML class diagrams document our classes and how we designed them. However, those diagrams
are static—they don’t show how objects instantiated from the classes interact with each other at
run time.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

99
A UML state diagram provides dynamic runtime information. It focuses on a single object and
how it changes state at run time in response to events defined by its behaviors. Recall that an
object’s runtime state is determined by the unique values of its instance variables, and its behaviors
are implemented by its methods. A state diagram allows us to visualize what happens to a
particular object during run time and helps to ensure that we designed the class with the correct
instance variables and methods.
Figure 4.14 is a UML state diagram for a Car object from figure 4.13. Each rounded box
represents a state, and each arrow represents a transition from one state to another. Each arrow
has a label that indicates the event that causes the transition. The object’s behaviors define the
kinds of events that can occur. In this example, the state of the Car object is characterized by the
current values of the object’s speed and heading instance variables. The filled-in circle is the starting
point, and the filled-in circle with a circle around it is an ending point.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

100
Figure 4.14 A UML state diagram that shows the state changes of a Car object during run time. Each box
represents a state, and each arrow represents a transition from one state to another. Each transition is labeled
with the behavior (event) that causes the transition. Such a diagram allows us to visualize what happens to a
particular object during run time and helps to ensure that we designed the class with the correct instance
variables and methods.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

101
Each event in the diagram causes the Car object to change state. For example, starting the engine
changes the object’s initial state from parked to idling. Accelerating then changes the object’s state
to “heading north.”
Figure 4.15 is a state diagram that will help to design a Student class in a hypothetical school
simulation application. It includes more information about an object’s runtime state transitions. The
filled-in diamonds are the decision branch and merge points, and the decision conditions are the
labels in square brackets. The heavy bars indicate where the transitions fork and join. The diagram
shows the state changes of a student enrolling in a course.
Figure 4.15 A state diagram for a student enrolling in a course. The filled-in diamonds are the decision branch
and merge points. The heavy bars indicate where the transitions fork and join. Such a diagram would help to
design a Student class with the correct instance variables and methods in a hypothetical school simulation
application.
4.5 UML sequence diagram: How objects interact [optional]
A UML sequence diagram also provides dynamic information. It shows at a high level the run-time
interactions among the objects during a use case. It helps to ensure that we assigned the methods
and designed the class relationships correctly. Figure 4.16 is a sequence diagram for our book
catalogue application in chapter 2.
The use case is a customer searching for books that match target book attributes. The figure at
the top left represents the customer. The boxes along the top of the diagram to the right of the stick
figure represent objects instantiated from the classes. By convention, each class name is underlined
to indicate that it’s an object instantiated from the class. Time proceeds from top to bottom. The
customer and each object have a lifeline represented by a dashed vertical line. Each vertical
rectangle on a lifeline represents the time during which the customer or object is active in the use
case. The labeled horizontal arrows represent the interactions among the objects. The objects’
behaviors (i.e., their methods) determine the interactions. The objects implement these interactions
with calls to methods.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

102
Figure 4.16 A UML sequence diagram for a customer searching for books that match target book attributes. At
a high level, it shows the runtime interactions among objects involved in this use case as time goes from top to
bottom. Such a diagram helps to ensure that we designed the class relationships correctly.
In this scenario, a customer first interacts with a Form object to fill in the target book attributes and
then presses the “Submit” button. That notifies the Catalogue object to start a book search. In the
meantime, the Catalogue object displays new books to the customer. The search interacts with
Book objects, which in turn match against Attributes objects. The matching attributes cause a
return of the corresponding Book objects. Finally, the Catalogue object displays these books to the
customer.
Figure 4.17 is another example of a sequence diagram, and this one is for a hypothetical bank
ATM (automatic teller machine) application.
Figure 4.17 An example of a UML sequence diagram for the use case of a customer withdrawing cash from a
bank ATM in a hypothetical banking application
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

103
The use case is a customer withdrawing cash. In this second scenario, an ATM customer first
interacts with the Console object and presses the “Withdraw” option. That action notifies the Display
object to display a confirmation message. Now the customer interacts with the Keypad object to
enter the amount to withdraw. The Keypad object notifies the Bank object, and in the meantime, it
also notifies the Display object to display bank ads. The Bank object asks the CheckingAccount
object to verify the withdrawal amount. If the CheckingAccount object accepts the withdrawal, the
Bank object notifies the Console object to initiate dispensing cash. As with the previous sequence
diagram, this diagram helps to ensure us that we assigned the methods and designed the class
relationships correctly.
4.6 The design specification and software verification
The UML class, state, and sequence diagrams belong in the design specification. This is a technical
document created by the development team that describes and justifies the design of the
application. This document can contain implementation details, and it is meant to be read by the
current and future developers of the application.
The design specification may include an Internal Test Plan. Unlike the black-box tests in an
External Test Plan described in chapter 3, an internal unit test can target and stress a particular
piece of code. For example, a unit test can pass different parameter values to a method of a class
and verify the return values. The developers should run unit tests. After a change to the code, and
especially at the end of each development iteration, regression testing ensures that previously
working code wasn’t accidentally broken (i.e., the code hasn’t regressed) by rerunning earlier unit
tests. Internal testing verifies that we developed the application right—that it’s bug-free (to the
extent that the tests can show) and meets all the requirements. Testing is the verification part of
software V&V (verification and validation).
As shown in figure 4.1, the design specification should freeze at the design freeze milestone, but
of course, late changes may be approved by the project manager at the risk of delaying the project
completion. We must update the document whenever we develop subsequent versions of the
product.
Software organizations determine the format and contents of the design specification. It may
have other names, such as “internal maintenance specification.” Whatever its name, its primary
purpose is to describe how the application was designed. Future readers of this document may
include the original designers of the application who might need reminders of why they designed
the code the way they did.
4.7 Summary
A project to develop an application consists of multiple activities performed in
parallel by a team of developers. Design occurs throughout nearly the entire
project, and mostly during the design–code–test development iterations.
Well-designed classes are cohesive and follow the Single Responsibility Principle.
Well-designed classes are loosely coupled and follow the Principle of Least
Knowledge.
An abstract class has at least one abstract method that its concrete subclasses
must implement. It can also have instance variables and non-abstract methods.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

104
An interface class is an abstract class that has only abstract methods. It serves
as a blueprint for all the behaviors that its concrete subclasses must implement.
A UML class diagram provides information about an application’s classes and
their relationships. Each class diagram shows the class name and, optionally its
instance variables and methods. The amount of information to show depends
on whether the diagram is part of a high-level or a low-level description of the
application’s design.
Different types of arrows drawn between two class diagrams indicate the
relationship between the classes: dependency, aggregation, composition, or
generalization.
A UML state diagram focuses on the state changes of a single object at run time.
An event causes an object to make a transition from one state to another, and
the events are defined by the object’s behavior. Visualizing what happens to a
particular object during run time helps to ensure that the object’s class is well-
designed with correct instance variables and methods.
A UML sequence diagram shows the high-level interactions among objects at
runtime. How an object behaves during an interaction is determined by its
methods. Visualizing these dynamic interactions helps to ensure that the classes
are well-designed with correct methods and proper relationships.
A design specification describes and justifies an application’s design for its
current and future developers. It contains the UML class, sequence, and state
diagrams. Furthermore, it can include a test plan for internal testing.
For the verification part of software V&V, software developers perform internal
testing that includes unit and regression tests during the development
iterations.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

105
5 Hide class
implementations
This chapter covers
The importance of hiding the implementation of a class
The Principle of Least Knowledge
Lazy evaluation
Getter and setter methods and immutable objects
Rules of the Law of Demeter
The Open-Closed Principle
Well-designed applications incorporate proven design principles. Chapter 4 discussed the
importance of loose coupling in class design. Two loosely coupled classes have minimal
dependencies on each other, which helps ensure that changes in one class don’t cause changes in
another class.
We can certainly be proud when other programmers admire and use the classes we wrote. But
well-designed classes hide their implementations by making their instance variables and methods
private. A class should expose by making public only those members that other programmers need
to access.
This chapter covers design principles that support a strategy to minimize the dependencies
among classes. Implementation hiding is an important part of encapsulation. If we hide the
implementation of a class, other classes can’t depend on what they can’t access. Therefore, we can
make changes to the implementation without forcing other classes to change in response.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

106
The next chapter will cover more design principles. We’ll see how the principles support each
other and work together. Later chapters will cover design patterns that provide models we can use
to develop custom solutions to common software architecture problems. The design principles are
the foundation for the design patterns.
5.1 The Principle of Least Knowledge and hidden implementations
Recall that a class’s instance variables represent state—each state of an object at run time is
characterized by a unique set of values of its instance variables. A class’s methods represent an
object’s runtime behavior. A class’s implementation is the way we code instance variables and
methods of the class.
For example, think again about the Book class from chapter 2 that represented a book in a
catalogue. Its implementation may include components such as the book’s title and author that
represent inherent attributes of a book. No other class should be concerned about how we
implement these attributes—they could be string values already assigned to the Book object or
values dynamically looked up in a database when we ask for them. Certainly, a class from a
customer application shouldn’t be allowed to change a book’s title or author. Therefore, these
attributes should be private. However, the class should provide public means for another class to
access a book’s title and author, but without needing to know their implementation.
The primary way to minimize the dependencies that a class A has on class B is for class A to
know as little as possible about the implementation of class B. This, of course, is the Principle of
Least Knowledge (sections 2.3.2 and 4.2.2). This principle is also known as the Law of Demeter,
named after the ancient Greek goddess of agriculture, with the allusion of growing software with
loosely coupled classes. Class B should expose only as much of itself as necessary for other code to
use the class, hiding the rest. By convention, hiding is accomplished in a Python class by specifying
instance variables and methods to be private by starting their names with an underscore (_). Private
methods, which should be called only by other methods of the class, are often called helper
methods.
Hidden doesn’t necessarily mean invisible. Hidden means inaccessible. Hidden implementation code
is effectively encapsulated. We can make changes to the hidden implementation of a class without
affecting any other code that uses the class. Because Python itself does not enforce privacy, we
must trust all Python programmers to abide by the convention that an instance variable or method
whose name starts with an underscore is intended to be a private and hidden implementation
detail, and that whatever is hidden is subject to change.
Therefore, if we use a class that has an instance variable named _x or a method named
_calculate_pay(), our code, which is outside the class, should not reference the variable or call the
method, let alone depend on particular implementations.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

107
Indeed, a good rule of thumb is the following: when designing a class, make every instance variable
and method private (or protected), except those that are necessary to be public to enable other
code to use the class. There’s an old saying: “Once public, always public.” If we make an instance
variable or method public, we might not be able to change it to private later without forcing code
rewrites.
5.2 Public getter and setter methods access hidden implementation
selectively
In listing 5.1 below, the Item class hides how it implements state by making its instance variables
_name, _weight, and _price private. Then, the class uses public getter and setter methods, more
formally known as accessors and mutators. Section 2.3 discussed the @property decorator, which
creates a read-only property and associates a getter method with it. In class Item, the @price.setter
decorator associates a public setter method with the price property.
PROPERTY SETTERS
After we’ve used @property to create a property object, we can associate a setter method
with it that sets a new value for a private instance variable, often with checks to ensure the
new value is valid. In class Item, the decorator @price.setter is associated with the setter
method price(self, new_price). Then we can write an assignment to the property object:
item.price = 10.75
which automatically calls the setter method to verify and set the private instance variable
_price to 10.75.
The @property decorator and property objects simplify and clarify our code and helps to
enforce hiding implementations.
Public properties of a class are meant to be used by any code instead of directly accessing and
setting private instance variables. A getter method allows code to probe an Item object’s current
state without revealing how the state is implemented. A setter method allows code to modify an
Item object’s state, such as by providing a new value for private instance variable _price, without
revealing how the state is implemented.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

108
Listing 5.1 (Program 5.1 DemeterItem): item.py
class Item:
def __init__(self, name, weight, price):
self._name = name #C
self._weight = weight #C
self._price = price #C
@property
def name(self): return self._name #A
@property
def weight(self): return self._weight #A
@property
def price(self): return self._price #A
@price.setter
def price(self, new_price): #B
assert new_price > 0
self._price = new_price
#A Getter methods for read-only properties
#B Setter method
#C Hidden state implementation
As suggested in figure 5.1, the caller of the public getter method for the price does not know how
the class implements state. The method returns the current value of the private _price instance
variable. In other versions of the application, the method could obtain the price by other hidden
means, such as a dynamic lookup in a price database. Code that uses class Item should not depend
on any particular implementation.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

109
Figure 5.1 A getter method enables code to obtain the price value from an Item object’s hidden state. A setter
method enables code to modify the price value in an Item object’s hidden state. Neither method reveals how
the class implements state. For example, we might later decide to have getter method price() dynamically
look up the price from a database. We’ll be able to make this change without making changes to the method’s
caller.
By hiding how the class implements state and then providing public getter and setter methods, we
can control how code can probe or modify an object’s state at run time. For example, a runtime
check can prevent a setter method from corrupting an object’s state with an invalid value:
@price.setter
def price(self, new_price):
assert new_price > 0
self._price = new_price
Of course, in a real application, we should handle a bad parameter value much more gracefully than
by immediately aborting the program.
The test program main.py shows calling the getter and setter methods.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

110
Listing 5.2 (Program 5.1 DemeterItem): main.py
from item import Item
if __name__ == '__main__':
item = Item('whole chicken', 4.5, 10.31)
print(f' name: {item.name}') #A
print(f'weight: {item.weight}') #A
print(f' price: ${item.price}') #A
print()
item.price = 10.75 #B
print(f'new price: ${item.price}')
print()
item.price = -9.99 #B
print(f'new price: ${item.price}')
#A Implicit calls to the getter methods for the name, weight, and price
#B Implicit calls to the setter method for the price
The second call to the setter method attempts to set an erroneous price, causing the method to
execute the assert statement to abort the program with a runtime error message. The program’s
output is
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

111
name: whole chicken
weight: 4.5
price: $10.31
new price: $10.75
------------------------------------------------------------------
AssertionError Traceback (most recent call last)
File ~/DemeterItem/main.py:15
12 print(f'new price: ${item.price}')
13 print()
---> 15 item.price = -9.99
16 print(f'new price: ${item.price}')
File ~/DemeterItem/item.py:18, in Item.price(self, price)
16 @price.setter
17 def price(self, price):
---> 18 assert price > 0
19 self._price = price
If we don’t change the signatures of the public getter and setter methods (i.e., if we don’t change
how to call them), we’ll be able to modify how the class implements state without forcing changes
on code using the class. Section 5.4 discusses further the role of setter methods.
5.3 Class Date: A case study of implementation hiding
The development iterations of the following example application demonstrate the importance of
hiding a class implementation and the problems we can run into if we don’t hide the
implementation. Let’s suppose the application maintains the dates of scheduled appointments by
using a Date class. A calendar date consists of a year, a month, and a day of the month. Therefore,
the Date class can hide its implementation by making its instance variables _year, _month, and _day
private.
DAY AND DATE
Dates are important for many applications. Unfortunately, everyday terminology can be
confusing. A day is any 24-hour period, which is midnight to midnight by convention. In the
Gregorian calendar in use today throughout much of the world, a specific day is identified by
a date consisting of three integer values: a year, a month, and a day of the month. An example
date (written in the U.S. format) is 9/2/2025 for September 2, 2025.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

112
In common use, the meanings of the words day and date often overlap. We refer to special
days using only a month and a day of the month (e.g., today is July 20, my birthday is
September 2, New Year’s Day is January 1). However, Don’s birthdate was January 10, 1938.
To add to the confusion, the day of the month is itself called a date (e.g., today’s date is the
12th). It should be clear from context which day is meant, such as Christmas Day is December
25, and there are 12 days of Christmas.
In our examples, class Date comprises three private instance variables—_year, _month, and
_day—where _day is short for day of the month.
If we were to design a Day class, it would have a one-to-one aggregation with the Date class
—each Day object would have an instance variable that references a Date object
representing its identifying date.
Next, suppose that the application must perform date arithmetic with the Date objects:
What is the date n days from this date, where n can be positive (for a date after
this date) or negative (for a date before this date)?
How many days are there from this date to another date?
Unfortunately, date arithmetic with the Gregorian calendar is notoriously difficult because of its
rules:
April, June, September, and November each has 30 days.
February has 28 days, except for leap years when it has 29 days.
All other months have 31 days.
Years that are divisible by four are leap years, except that after 1582, years
divisible by 100 but not 400 are not leap years.
There is no year 0. Year 1 CE is preceded by year 1 BCE (year -1).
During the switchover to the Gregorian calendar, 10 days were dropped. The
next date after October 4, 1582, was October 15, 1582.
5.3.1 Iteration 1: Date arithmetic with loops
The following listing shows the beginning of class Date. The private class constants are needed to
perform date arithmetic according to the Gregorian calendar rules. The private state consists of
_year, _month, and _day, which the constructor __init__() initializes. In an actual application, the
constructor should check the values of the parameters. The three getter methods allow access to a
Date object’s state.
Special method __repr__() returns the string representation of a Date object in the U.S. format,
that is, month/day/year. For example, 9/2/2025 for September 2, 2025. It calls the getter methods
self.year, self.month, and self.day.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

113
Listing 5.3 (Program 5.2 DateArithmetic-1): date.py (1 of 4) VERY INEFFICIENT!
class Date:
_JANUARY = 1 #A
_FEBRUARY = 2 #A
_DECEMBER = 12 #A
_GREGORIAN_START_YEAR = 1582 #A
_GREGORIAN_START_MONTH = 10 #A
_GREGORIAN_START_DATE = 15 #A
_JULIAN_END_DATE = 4 #A
_DAYS_IN_MONTH = ( 31, 28, 31, 30, 31, 30, #A
31, 31, 30, 31, 30, 31 ) #A
def __init__(self, year, month, day):
self._year = year #B
self._month = month #B
self._day = day #B
@property
def year(self): return self._year #C
@property
def month(self): return self._month #C
@property
def day(self): return self._day #C
def __repr__(self):
date_string = f'{self.month}/{self.day}/'
if self.year > 0: date_string += str(self.year)
else: date_string += str(-self.year) + ' BCE'
return date_string
#A Private constants for the Gregorian calendar rules
#B Private state implementation
#C Public getter methods
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

114
In the following listing, the two private static methods return the number of days in a month and
whether a year is a leap year, respectively. The private method _compare_to() compares the self
date to the other date. If the former comes before the latter in time, the method returns -1. If the
former comes after the latter in time, the method returns 1. If both dates are the same date, the
method returns 0. What’s important is whether the return value is negative, zero, or positive.
Special method __repr__() returns the string representation of a Date object in the U.S. format,
that is, month/day/year. For example, 9/2/2025 for September 2, 2025.
Listing 5.4 (Program 5.2 DateArithmetic-1): date.py (2 of 4) VERY INEFFICIENT!
@staticmethod
def _days_in_month(year, month):
if (month == Date._FEBRUARY) and Date._is_leap_year(year):
return 29
else:
return Date._DAYS_IN_MONTH[month - 1]
@staticmethod
def _is_leap_year(year):
if year%4 != 0: return False
if year < Date._GREGORIAN_START_YEAR: return True
return (year%100 != 0) or (year%400 == 0)
def _compare_to(self, other): #A
if self._year > other.year: return 1
if self._year < other.year: return -1
if self._month > other.month: return 1
if self._month < other.month: return -1
return self._day - other.day
#A Returns a positive value if the self date comes after the other date; returns a negative value if the self date
comes before the other date; and returns 0 if both dates are the same
Methods _next_date() and _previous_date() in the following listing each applies the Gregorian
calendar rules to calculate the date that follows the self date and the date that precedes the self
date, respectively. Each method returns a new Date object.
Listing 5.5 (Program 5.2 DateArithmetic-1): date.py (3 of 4) VERY INEFFICIENT!
def _next_date(self): #A
y = self._year
m = self._month
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

115
d = self._day
if ( (y == Date._GREGORIAN_START_YEAR)
and (m == Date._GREGORIAN_START_MONTH)
and (d == Date._JULIAN_END_DATE)
): d = Date._GREGORIAN_START_DATE
elif d < Date._days_in_month(y, m): d += 1
else:
d = 1
m += 1
if m > Date._DECEMBER:
m = Date._JANUARY
y += 1
if y == 0: y += 1
return Date(y, m, d)
def _previous_date(self): #B
y = self._year
m = self._month
d = self._day
if ( (y == Date._GREGORIAN_START_YEAR)
and (m == Date._GREGORIAN_START_MONTH)
and (d == Date._GREGORIAN_START_DATE)
): d = Date._JULIAN_END_DATE
elif d > 1: d -= 1
else:
m -= 1
if m < Date._JANUARY:
m = Date._DECEMBER
y -= 1
if y == 0: y -= 1
d = Date._days_in_month(y, m)
return Date(y, m, d)
#A Apply Gregorian calendar rules to return the next date.
#B Apply Gregorian calendar rules to return the previous date.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

116
Method add_days() in the following listing starts with the self date and iterates day-by-day n days
into the future if the value of argument n is positive, or n days into the past if the value of n is
negative. Method days_from() starts with the self date and iterates day-by-day to count days either
into the past or into the future, depending on whether this date falls after or before the Date
argument, respectively. Both methods call private methods _previous_date() and _next_date() in
their loops. The loops of method days_from() also calls private method _compare_to().
Listing 5.6 (Program 5.2 DateArithmetic-1): date.py (4 of 4) VERY INEFFICIENT!
def add_days(self, n):
date = self #A
while n > 0:
date = date._next_date() #B
n -= 1 #B
while n < 0:
date = date._previous_date() #C
n += 1 #C
return date
def days_from(self, other):
date = self #D
n = 0
while date._compare_to(other) > 0:
date = date._previous_date() #E
n += 1 #E
while date._compare_to(other) < 0:
date = date._next_date() #F
n -= 1 #F
return n
#A Start with a copy of this date.
#B Loop n days into the future.
#C Loop n days into the past.
#D Start with a copy of this date.
#E Loop to count days in the past.
#F Loop to count days in the future.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

117
It’s even worse than that. Each iteration of methods add_days() and days_from() gets a new Date
object when it calls _previous_date() or _next_date(). Each call to method add_days() and days_from()
returns only the Date object created by the last iteration, and so the prior iterations fill memory
with unused Date objects.
The following listing is a simple test program.
Listing 5.7 (Program 5.2 DateArithmetic-1): main.py VERY INEFFICIENT!
from date import Date
if __name__ == '__main__':
date1 = Date(2025, 9, 2)
date2 = Date(2027, 4, 3)
print(f'{date1 = }')
print(f'{date2 = }')
print()
count = date2.days_from(date1)
print(f'{count = }')
print(f'{date1.add_days(count) = }')
print(f' should be {date2 = }')
print()
count = date1.days_from(date2)
print(f'{count = }')
print(f'{date2.add_days(count) = }')
print(f' should be {date1 = }')
The output is
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

118
date1 = 9/2/2025
date2 = 4/3/2027
count = 578
date1.add_days(count) = 4/3/2027
should be date2 = 4/3/2027
count = -578
date2.add_days(count) = 9/2/2025
should be date1 = 9/2/2025
The application is functional and appears to perform the date arithmetic correctly. However, it is
terribly inefficient. Method add_days() must loop as many times as the value of argument n. Method
days_from() must loop as many times as there are days from the self date to the Date argument
other and call method _compare_to() at the beginning of each loop. Calls to methods _next_date()
and _previous_date() inside the loops are expensive because of the Gregorian calendar rules. Each
call creates and returns a new Date object. This is clearly a poor design (figure 5.2). We need to
backtrack and come up with a better design.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

119
Figure 5.2 The version of class Date from iteration 1 performs date arithmetic correctly, but it does it poorly
because of expensive looping day-by-day with the Gregorian calendar rules. This version deserves a lump of
coal.
5.3.2 Iteration 2: Julian day numbers simplify date arithmetic
A much more efficient way to perform date arithmetic is to use a Julian day number to identify each
day instead of the Gregorian year, month, and day of the month. The Julian day number of a
particular day is the number of days since noon on January 1, 4713 BCE, of the Gregorian calendar.
We’ll use a Julian day number only at noon so that the number is always a whole number. Date
arithmetic is trivial with Julian day numbers.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

120
JULIAN DAY NUMBER
Do not be puzzled by the various calendar uses of the name “Julian.” Astronomers use Julian
day numbers to identify days rather than using the year, month, and day of the month. A
Julian day number counts the number of days since noon on January 1, 4713 BCE, of the
Gregorian calendar, so that day at noon has Julian day number 0. Because it takes hours of
the day into account, a Julian day number can have a fractional part, but it’s whole at noon.
The 16th-century historian Josephus Justus Scaliger invented the concept and named it after
his father Julius.
There are complicated algorithms for converting between a day’s Julian day number and its
corresponding Gregorian year, month, and day of the month. The algorithms in the following
application are from Numerical Recipes, the Art of Scientific Computing, 3rd edition, by William
H. Press et al., Cambridge University Press, 2007.
A useful conversion milepost is Julian day number 2,440,000, which corresponds to the
Gregorian date May 23, 1968.
Julian day numbers are not related to the Julian calendar introduced by the Roman emperor
Julius Caesar in 45 BCE.
A day’s Julian date is a combination of the year and the day of the year. For example, the
Julian date of January 1, 2024, is 2024-01, and the Julian date of December 31, 2024, is 2024-
366 (2024 is a leap year). This is also not related to the Julian day number.
The second design iteration of class Date uses Julian day numbers. Like in the previous version of
the class, we want to hide how we implement the state of its objects, so instance variable julian is
private. We no longer need private instance variables year, month, and day. But we’ll need to be
able to convert from year, month, and day values to a julian number, and vice versa. As seen in the
next listing, this version needs two new class constants, _MAX_DAYS_IN_MONTH and
_MONTHS_PER_YEAR.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

121
Listing 5.8 (Program 5.3 DateArithmetic-2): date.py (1 of 2) COULD BE BETTER!
import math
class Date:
_JANUARY = 1
_FEBRUARY = 2
_DECEMBER = 12
_GREGORIAN_START_YEAR = 1582
_GREGORIAN_START_MONTH = 10
_GREGORIAN_START_DATE = 15
_JULIAN_END_DATE = 4
_MAX_DAYS_IN_MONTH = 31
_MONTHS_PER_YEAR = 12
_DAYS_IN_MONTH = ( 31, 28, 31, 30, 31, 30,
31, 31, 30, 31, 30, 31 )
Private static method _to_julian() converts a year, month, and day of the month to a Julian day
number using an established algorithm. Given year, month, and day values, it returns the calculated
Julian day number.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

122
Listing 5.9 (Program 5.3 DateArithmetic-2): date.py (2 of 4) COULD BE BETTER!
@staticmethod
def _to_julian(year, month, day): #A
y = year
if year < 0: y += 1
m = month
if month > Date._FEBRUARY: m += 1
else:
y -= 1
m += 13
j = (math.floor(math.floor(365.25*y) + math.floor(30.6001*m))
+ day + 1720995)
term = (Date._MAX_DAYS_IN_MONTH
*(month + Date._MONTHS_PER_YEAR*year))
GREGORIAN_CUTOFF = (
Date._GREGORIAN_START_DATE +
Date._MAX_DAYS_IN_MONTH
*(Date._GREGORIAN_START_MONTH +
Date._MONTHS_PER_YEAR*Date._GREGORIAN_START_YEAR)
)
if day + term >= GREGORIAN_CUTOFF:
x = math.floor(0.01*y)
j += 2 - x + math.floor(0.25*x)
return j #B
#A Private static method to convert year, month, and day of the month to a Julian day number
#B Return the calculated Julian day number
Private static method _to_ymd() converts a Julian number to year, month, and day of the month
values, which it returns as a tuple.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

123
Listing 5.10 (Program 5.3 DateArithmetic-2): date.py (3 of 4) COULD BE BETTER!
@staticmethod
def _to_ymd(julian): #A
GREGORIAN_CUTOFF = 2299161
ja = julian
if julian >= GREGORIAN_CUTOFF:
jalpha = math.floor(
(float(julian - 1867216) - 0.25)/36524.25)
ja += 1 + jalpha - math.floor(0.25*jalpha)
jb = ja + 1524
jc = math.floor(
6680.0 + (float(jb - 2439870) - 122.1)/365.25)
jd = math.floor(365*jc + (0.25*jc))
je = math.floor((jb - jd)/30.6001)
day = jb - jd - math.floor(30.6001*je)
month = je - 1
if month > Date._DECEMBER: month -= 12
year = jc - 4715
if month > Date._FEBRUARY: year -= 1
if year <= 0: year -= 1
return (year, month, day) #B
#A Private static method to convert a Julian day number to year, month, and day of the month
#B Return as a tuple
The following listing shows that the __init__() constructor receives its argument values in list parms
in order to handle two cases. It can be called with only a single argument, a Julian day number, in
which case the constructor sets the value of _julian directly. Or, the constructor can be called with
three arguments, year, month, and day of the month values, in which case it must calculate the
value of _julian by calling method _to_julian() with the three argument values.
The public getter methods of each of the year, month, and day properties must first convert the
Julian day number by calling _to_ymd() and then return the appropriate value from the tuple.
Using Julian day numbers makes date arithmetic is much more efficient. Method add_days()
simply adds the value of argument n to the self date’s Julian day number to create and return a new
Date object. Method days_from() subtracts the Julian day number of the other date from the self
date’s Julian day number and returns the number of days.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

124
Because we hid the implementation of class Date, we were able to change the implementation
radically without causing code that uses the class to change. We can call the Date constructor to
create a Date object like before and call the public getter methods get_year(), get_month(), and
get_day() without change to get the date’s year, month, and day of the month. Furthermore, we can
call the public methods add_days() and days_from() the same way as before and get the same
expected results.
Listing 5.11 (Program 5.3 DateArithmetic-2): date.py (4 of 4) COULD BE BETTER!
def __init__(self, *parms):
if len(parms) == 1:
self._julian = parms[0] #A
else:
self._julian = Date._to_julian(*parms) #B
@property
def year(self):
year, _, _ = Date._to_ymd(self._julian) #C
return year
@property
def month(self):
_, month, _ = Date._to_ymd(self._julian) #C
return month
@property
def day(self):
_, _, day = Date._to_ymd(self._julian) #C
return day
def add_days(self, n):
return Date(self._julian + n) #D
def days_from(self, other):
return self._julian - other._julian #E
#A Julian number passed as a single argument.
#B Year, month, and day passed as three arguments
#C First convert the Julian day number to year, month, day
#D Return a new Date object after an addition to the Julian day number.
#E Return the result of a subtraction of Julian day numbers
The same test program (listing 5.7) produces the same output.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

125
While it may do date arithmetic very efficiently, the second iteration of class Date introduced a
different inefficiency. Private method _to_julian() computes the Julian day number corresponding to
a Gregorian year, month, and day of the month. Conversely, private method _to_ymd() converts the
year, month, and day of the month to a corresponding Julian day number. Both are complicated
due to the Gregorian calendar rules.
Each of the public getter methods year(), month(), and day() must first call _to_ymd() before it can
return the year, month, or day of the month, respectively. Special method __repr__() also relies on
_to_ymd().
We still don’t have a good design (figure 5.3). But we can improve the efficiency of class Date with a
third iteration.
Figure 5.3 The version of class Date from iteration 2 performs data arithmetic very efficiently using Julian day
numbers, but getter methods for the year, month, or day of the month must each call an expensive conversion
algorithm. We get yet another lump of coal.
5.3.3 Iteration 3: A hybrid approach with lazy evaluation
How can we have fast access to the year, month, and day of the month along with efficient date
arithmetic? This third iteration of class Date takes a hybrid approach. As shown in the following
listing, this version has all four private instance variables: _year, _month, _day, and _julian.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

126
Listing 5.12 (Program 5.4 DateArithmetic-3): date.py (1 of 2) EFFICIENT HYBRID
class Date:
...
def __init__(self, *parms):
if len(parms) == 1:
self._julian = parms[0] #A
self._ymd_valid = False #A
self._julian_valid = True #A
else:
self._year, self._month, self._day = parms #B
self._ymd_valid = True #B
self._julian_valid = False #B
def _validate_ymd(self): #C
if not self._ymd_valid:
self._year, self._month, self._day = \
Date._to_ymd(self._julian)
self._ymd_valid = True
def _validate_julian(self): #D
if not self._julian_valid:
self._julian = \
Date._to_julian(self._year, self._month, self._day)
self._julian_valid = True
#A The values of _year, _month, and _day are valid after the Date object is created, but the value of _julian is
not.
#B The value of _julian is valid after the Date object is created, but the values of _year, _month, and _day are
not.
#C Validate the values of _year, _month, and _day.
#D Validate the value of _julian.
Boolean instance variables _ymd_valid and _julian_valid help to ensure that, whenever necessary,
the value of _julian and the values of the trio _year, _month, and _day are synchronized. Private
method _validate_ymd() synchronizes the values of the trio with the current value of _julian. Private
method _validate_julian() synchronizes the value of _julian with the current values of the trio.
This code is more efficient because instance variables _ymd_valid and _julian_valid prevent
unnecessary calls to the expensive conversion methods _to_ymd() or _to_julian() when the values of
_year, _month, and _day are already synchronized with the value of _julian.
In the following listing, public getter methods year(), month(), and day() each must first call
method _validate_ymd() to ensure that the value it returns is synchronized with the current value of
_julian. Public methods add_days() and days_from(), both of which perform date arithmetic with
Julian day numbers, must each call method _validate_julian() to ensure that the value of _julian is
synchronized with the current values of _year, _month, and _day.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

127
Listing 5.13 (Program 5.4 DateArithmetic-3): date.py (2 of 2) EFFICIENT HYBRID
@property
def year(self):
self._validate_ymd() #A
return self._year
@property
def month(self):
self._validate_ymd() #A
return self._month
@property
def day(self):
self._validate_ymd() #A
return self._day
def add_days(self, n):
self._validate_julian() #B
return Date(self._julian + n)
def days_from(self, other):
self._validate_julian() #B
other._validate_julian() #B
return self._julian - other._julian
#A Validate the values of _year, _month, and _day before returning their values.
#B Validate the julian numbers before doing date arithmetic.
We call method _to_ymd() only when we’re about to access the values of _year, _month, and _day.
We call method _to_julian() only when we’re about to perform date arithmetic using the value of
_julian. This is an example of the Lazy Evaluation Principle, where we delay performing a calculation
until we need the result, which makes our code more efficient by preventing unnecessary
calculations.
THE LAZY EVALUATION PRINCIPLE
If at run time we don’t need the result of a calculation immediately, then we should be lazy
and postpone the calculation until we need the result. The Lazy Evaluation Principle is
especially useful to improve performance if the calculation is expensive or time-consuming.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

128
Because we hid the implementation of the Date class with private instance variables and provided
public getter methods, we were again able to refactor the code to further improve its efficiency. We
encapsulated the implementation changes. Code that uses the Date class only needs to know that a
Date object’s state is characterized by its year, month, and day of the month, and that Date objects
can perform date arithmetic efficiently. We’ve hidden the use of Julian day numbers to support date
arithmetic (figure 5.4).
Figure 5.4 The version of class Date from iteration 3 is a hybrid that uses lazy evaluation. It has the best
performance of the three versions. This version deserves the pot of gold.
5.4 Public setter methods carefully modify hidden implementation
A public getter method allows code to probe an object’s state without revealing how the state is
implemented. On the other hand, a public setter method allows code to modify an object’s state,
also without revealing how the state is implemented.
None of the three versions of class Date in this chapter provided any public setter methods.
Therefore, once we’ve constructed a Date object at run time with year, month, and day of the
month values, the object is immutable—there is no way to change its state. Immutable objects are
often justified by an application’s logic. We’ll learn more about immutable objects in section 5.7.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

129
The following listing shows another version of class Date. This version selectively allows access to
another part of its implementation—its Julian day number. Public method julian() is now both a
getter method and a setter method. As a setter method, it changes the state of a Date object, and it
does it defensively in a safe manner. Therefore, in this version, Date objects are mutable.
Listing 5.14 (Program 5.5 DateArithmetic-4): date.py MUTABLE
class Date:
...
@property #A
def julian(self):
self._validate_julian()
return self._julian
@julian.setter #B
def julian(self, j):
assert(j >= 0)
self._julian = j
self._julian_valid = True
self._ymd_valid = False
...
}
#A Getter method for the Julian day number
#B Setter method for the Julian day number
Method julian() behaves both as a getter and a setter. As a setter, it checks the value of its argument
before using it and aborts the program if the value is negative. A real application should handle this
error more gracefully than immediately aborting.
The new test program exercises accessing and setting a Date object’s Julian day number.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

130
Listing 5.15 (Program 5.5 DateArithmetic-4): main.py MUTABLE
from date import Date
if __name__ == '__main__':
date1 = Date(2025, 9, 2)
date2 = Date(2027, 4, 3)
print(f'{date1 = }')
print(f'{date2 = }')
print()
print(f'{date1 = } Julian number {date1.julian = :,d}') #A
date2.julian = date1.julian #B
print(f'{date2 = } Julian number {date2.julian = :,d}')
print()
for j in [0, 2440000, 3000000:
date1.julian = j
print(f'set Julian number {j = :9,d} ==> {date1 = }')
#A Implicit call to the getter method date1.julian
#B Implicit calls to the setter method date2.julian and to the getter method date1.julian
The printed results are
date1 = 9/2/2025
date2 = 4/3/2027
date1 = 9/2/2025 Julian number date1.julian = 2,460,921
date2 = 9/2/2025 Julian number date2.julian = 2,460,921
set Julian number j = 0 ==> date1 = 1/1/4713 BCE
set Julian number j = 2,440,000 ==> date1 = 5/23/1968
set Julian number j = 3,000,000 ==> date1 = 8/15/3501
5.5 Beware of dangerous setter methods
Should we always favor providing setter methods? What about the values of the trio year, month,
and day of the month in the hidden implementation? Let’s see what can happen if we provide
additional setter methods.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

131
Listing 5.16 (Program 5.6 DateArithmetic-5): date.py DANGEROUS SETTERS
class Date:
...
@year.setter
def year(self, y):
assert(y != 0)
self._validate_ymd()
self._year = y
self._julian_valid = False
@month.setter
def month(self, m):
assert(Date._JANUARY <= m <= Date._DECEMBER)
self._validate_ymd()
self._month = m
self._julian_valid = False
@day.setter
def day(self, d):
assert(1 <= d <= 31)
self._validate_ymd()
self._day = d
self._julian_valid = False
...
}
In an actual application, setter method set_day() will need a much more comprehensive validation
of its parameter value that takes into consideration the current month and year. The following
listing is a test program for this poorly designed version of class Date.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

132
Listing 5.17 (Program 5.6 DateArithmetic-5): main.py DANGEROUS SETTERS
from date import Date
if __name__ == '__main__':
date = Date(2030, 1, 31)
print(f'starting: {date = } {date.julian = }')
date.month = 2 #A
print(f'modified: {date = } {date.julian = }')
date1 = Date(2025, 9, 2)
date2 = Date(2027, 4, 3)
j = date.julian
date.julian = j
print(f'surprise: {date = } {date.julian = }')
#A Problematic setting of the month
The output is
starting: date = 1/31/2030 date.julian = 2462533
modified: date = 2/31/2030 date.julian = 2462564
surprise: date = 3/3/2030 date.julian = 2462564
By providing setter methods to set a Date object’s private _year, _month, and _day instance
variables individually, we were able to put the object into an invalid state, the nonexistent date
February 31, 2030. Then, by resetting the Julian day number of that nonexistent date, we ended up
with March 3, 2030, a nasty surprise. We must never allow a setter method to put an object into an
invalid state. The next chapter will discuss code surprises.
If we want to allow setting the year, month, and day of the month of an existing Date object, a much
safer alternative is to provide a setter method that modifies all three at once. Then, it would be
much easier in an actual application for the setter method to check the arguments to ensure that
the combination of all three values results in a valid Date object. Of course, the Date constructor
that takes year, month, and day of the month values should also check those values.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

133
5.6 Rules from the Law of Demeter
The Law of Demeter prescribes several rules that help us design proper loosely coupled classes. By
following these rules, we avoid designing a class that has certain problematic dependencies on
another class. Specifically, they tell whether a method a() of class A can call a method b() of another
class B:
1. Method a() can call method b() on a class B object if class A aggregates the
object (i.e., class A has an instance variable whose value is a reference to a class
B object).
2. Method a() can call method b() on a class B object if the object was passed as an
argument to a().
3. Method a() can call method b() on a class B object if a() instantiated the class B
object.
4. Method a() should not call method b() on a class B object that was returned by a
call on another object’s method.
The Law of Demeter basically says that a class should only call methods of objects that are close to
it. Classes DemeterAuto, Engine, and Sparkplug provide examples that obey and disobey the law’s
rules.
Listing 5.18 (Program 5.7 DemeterAuto): auto.h
class Sparkplug:
def __init__(self, name):
self._name = name
def replace(self):
print(f'Replaced sparkplug {self._name}')
class Engine:
def __init__(self, sparkplug):
self._sparkplug = sparkplug
@property
def sparkplug(self): return self._sparkplug
def replace_sparkplug(self):
self._sparkplug.replace() #A
class DemeterAuto:
def __init__(self, engine):
self._engine = engine
def service_sparkplug(self, plug):
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

134
plug.replace() #B
def maintain_auto(self):
self._engine.replace_sparkplug() #C
plug1 = self._engine.sparkplug
plug1.replace() #D
plug2 = Sparkplug('plug2')
plug2.replace() #E
#A Obeys: _splarkplug is an instance variable of class Engine (rule 1).
#B Obeys: plug is a parameter of method service_sparkplug() (rule 2).
#C Obeys: _engine is an instance variable of class DemeterAuto (rule 1).
#D DISOBEYS: the value of plug1 is an object returned by object _engine (rule 4).
#E Obeys: the value of plug2 is instantiated by method maintain_auto() (rule 3).
5.7 But is the implementation really hidden?
To write an application that stores employee records, we could have a class Employee that records
an employee’s birthdate via a reference to a Date object. We want an Employee object to be
immutable by a regular user of the application—after we’ve created an object, the employee’s id,
name, and birthdate should not be changeable by such a user. All three private instance variables,
_employee_id, _name, and _birthdate are in the hidden state implementation, and the class itself
has no setter methods.
However, we’ll use our mutable version of class Date with its public set_julian() setter method.
We’ll assume that a different class of the application, say EmployeeForAdmin, also aggregates class
Date but has setter methods to allow an administrative user to correct an error in an employee’s
birthdate. However, a regular user should not be able to modify an employee’s birthdate. Is making
_birthdate private sufficient?
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

135
Listing 5.19 (Program 5.8 HiddenDate-1): employee.py FAULTY DESIGN
class Employee:
def __init__(self, employee_id, name, birthdate):
self._employee_id = employee_id
self._name = name
self._birthdate = birthdate
@property
def employee_id(self): return self._employee_id
@property
def name(self): return self._name
@property
def birthdate(self): return self._birthdate
def __str__(self):
return (
f'Employee #{self._employee_id}\n'
f' Name: {self._name}\n'
f' Birthdate: {self._birthdate}\n'
)
Since class Employee has no setter methods, is an Employee object truly immutable? The following
listing is a test program.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

136
Listing 5.20 (Program 5.8 HiddenDate-1): main.py FAULTY DESIGN
from date import Date
from employee import Employee
if __name__ == '__main__':
marys_birthdate = Date(2000, 1, 10) #A
mary = Employee(1234567890, 'Mary', marys_birthdate) #A
print(mary)
marys_birthdate.julian += 366 #B
print(mary)
date = mary.birthdate #C
date.julian += 365 #C
print(mary)
#A Is this Employee object immutable?
#B Changes the birthdate year to 2001
#C Changes the birthdate year to 2002
Here’s the output:
Employee #1234567890
Name: Mary
Birthdate: 1/10/2000
Employee #1234567890
Name: Mary
Birthdate: 1/10/2001
Employee #1234567890
Name: Mary
Birthdate: 1/10/2002
Obviously, the Employee object is not immutable. There were several design failures:
We first dynamically created a new Birthday object and assigned it to variable
marys_birthdate. We used marys_birthdate to create the Employee object.
Because we had a reference to the Birthday object that is now embedded in the
Employee object, we were able to use that reference, marys_birthdate, to
change the employee’s birth year.
Using the birthdate property, we set variable date to the Employee object’s
embedded Birthday object. We used the variable to change the employee’s birth
year again.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

137
This surely is a subtle design fault. If a class instantiates objects that are supposed to be immutable,
but it has improperly designed getter methods, we can inadvertently modify an object’s state at run
time.
There are remedies to ensure that the Employee objects are immutable, as shown in the
following listing. The class constructor should store a copy of the Date object that is passed to it. The
property should return a copy of the embedded Date object. Then, it will not be possible to change
the birthdate embedded in the Employee object.
Listing 5.21 (Program 5.9 HiddenDate-2): employee.py CORRECTED DESIGN
from copy import copy
class Employee:
def __init__(self, employee_id, name, birthdate):
self._employee_id = employee_id
self._name = name
self._birthdate = copy(birthdate) #A
@property
def employee_id(self): return self._employee_id
@property
def name(self): return self._name
@property
def birthdate(self): return copy(self._birthdate) #B
def __str__(self):
return (
f'Employee #{self._employee_id}\n'
f' Name: {self._name}\n'
f' Birthdate: {self._birthdate}\n'
)
#A Store a copy of the Date object that is passed in.
#B Return a copy of the stored Date object.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

138
With the same test program, the output shows that the employee’s birthdate did not change:
Employee #1234567890
Name: Mary
Birthdate: 1/10/2000
Employee #1234567890
Name: Mary
Birthdate: 1/10/2000
Employee #1234567890
Name: Mary
Birthdate: 1/10/2000
5.8 The Open-Closed Principle supports code stability
In chapter 2, during the third development iteration of the book catalogue application, we created
several subclasses for the superclass Attributes. Figure 5.5 shows that ill-fated design.
Although we ultimately determined that having many subclasses was a poor design for the
application, figure 5.5 is a good example of the Open-Closed Principle, according to which we
should close a class against modification but open it for subclassing (section 2.3.3). It assumes that
we are confident that a class has captured all the common attributes and behaviors of a set of
objects, and therefore, the design of that class should not change. That supports code stability.
However, we allow extending the class for objects that have attributes and behaviors beyond the
common ones. In other words, the closed class is the superclass, and the extensions are its
subclasses.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

139
Figure 5.5 A design of the book catalogue application with superclass Attributes and its subclasses. In the
class diagram for Attributes, the name of private method _equal_ignore_case() is underlined to indicate
that it is static.
The Open-Closed Principle is another way to design classes with hidden implementation. By
denoting the instance variables and methods of the superclass to be private, we can hide how we
implement the common parts of the state and behavior inherited by its subclasses. In class
Attributes, instance variables _title, _last, and _first are meant to be private. FictionAttrs extends
Attributes, so a FictionAttrs object hides how it implements the _title, _last, and _first parts of its
state. The subclass extends the hidden state implementation with the addition of private _year and
_genre instance variables.
The following listing is another example of the Open-Closed Principle. Suppose that class
Mammal has all the common attributes and behaviors of mammals that a particular application
needs. Therefore, we can close this class.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

140
Listing 5.22 (Program 5.10 Mammals): mammal.py
from abc import abstractmethod
class Mammal:
def __init__(self, weight, height):
self.__weight = weight #A
self.__height = height #A
@property
def weight(self): return self.__weight #B
@property
def height(self): return self.__height #B
def _snore(self): #C
print('Zzzz')
@abstractmethod
def eat(self): #D
pass
@abstractmethod
def perform(self): #D
pass
def sleep(self): #E
print('close eyes')
self._snore()
#A Hidden state implementation of this superclass
#B Common public getters
#C Private behavior implemented by the subclasses
#D Common public behaviors to be implemented by the subclasses
#E Common public behavior implemented by this superclass
We close class Mammal, but we can keep it open for extension.
In the following two listings, subclasses Human and Cat each extends Mammal by adding its
instance variables and methods. Each subclass must define abstract methods eat() and perform().
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

141
Listing 5.23 (Program 5.10 Mammals): human.py
from mammal import Mammal
class Human(Mammal):
def __init__(self, weight, height, needs_glasses):
super().__init__(weight, height) #A
self._needs_glasses = needs_glasses #B
def _read_book(self): #C
if self._needs_glasses:
print('squint')
print('turn pages')
def eat(self) #D
print('eat with knife and fork')
def perform(self): #D
self._read_book()
self.sleep()
#A Initialize the superclass object
#B Hidden extended state implementation for humans
#C Hidden extended behavior implementation for humans
#D Subclass Initialize implementation of abstract methods
Subclass Human keeps the implementation of its part of the state (instance variable _needs_glasses)
and behavior (method _read_book()) hidden.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

142
Listing 5.24 (Program 5.10 Mammals): cat.py
from mammal import Mammal
class Cat(Mammal):
def __init__(self, weight, height, fur_factor):
super().__init__(weight, height) #A
self._fur_factor = fur_factor #B
def _shed(self): #C
if self._fur_factor > 1.0:
print('shed a lot')
else:
print('shed a little')
def eat(self): #D
print('eat from a bowl')
def perform(self): #D
self._shed()
#A Initialize the superclass object
#B Hidden extended state implementation for cats
#C Hidden extended behavior implementation for cats
#D Subclass Initialize implementation of abstract methods
Subclass Cat keeps the implementation of its part of the state (instance variable _fur_factor) and
behavior (method _shed()) hidden.
Because they are declared to be abstract in superclass Mammal, both subclasses must
implement the public methods eat() and perform(). The implementation of the common parts of the
state (height and weight) and behavior (snoring) of each subclass are hidden by their superclass
Mammal. The following listing is a test program.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

143
Listing 5.25 (Program 5.10 Mammals): main.py
from human import Human
from cat import Cat
if __name__ == '__main__':
ron = Human(77.11, 1.85, True)
print('Human Ron')
print(f'{ron.weight = } kg, {ron.height = } m')
ron.eat()
ron.perform()
print()
buddy = Cat(5.55, 0.30, 1.25)
print('Cat Buddy')
print(f'{buddy.weight = } kg, {buddy.height = } m')
buddy.eat()
buddy.perform()
The output is
Human Ron
ron.weight = 77.11 kg, ron.height = 1.85 m
eat with knife and fork
squint
turn pages
close eyes
Zzzz
Cat Buddy
buddy.weight = 5.55 kg, buddy.height = 0.3 m
eat from a bowl
shed a lot
We implement a common core implementation in a superclass and lock it from further changes to
support code stability, but we can extend the implementation in subclasses. We can hide the
common and the extended implementations.
5.9 Summary
Python programmers must respect the convention that names of instance
variables and methods that begin with an underscore are denoted to be private
and therefore have hidden implementations.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

144
Minimize dependencies on a class by hiding how the class implements state to
support encapsulation. Hide instance variables and methods by making
denoting them to be private. When the hidden implementation of a class is
encapsulated, we can refactor the implementation to improve it without causing
changes to any code using the class.
Properties allow controlled access to hidden object state. A property can return
values from an object’s state without revealing how the state is implemented. A
property setter can modify an object’s state without revealing how the state is
implemented.
A property should never allow an object to be put into an invalid state. We must
be careful what property setters to provide.
An immutable class creates objects that cannot be modified after we’ve
constructed them. Such a class should not provide property setters that modify
an object’s state.
A class whose objects are supposed to be immutable must not provide
references to hidden state implementation because that would allow other code
to use the references to modify an object’s state at run time.
According to the Lazy Evaluation Principle, runtime performance should be
improved by delaying an expensive calculation until its results are needed.
The Law of Demeter prescribes rules to guide designing classes that have no
problematic dependencies on other classes. Method a() of class A can call
method b() on a class B object if class A aggregates class B, or if the class B
object was passed as an argument to method a(), or if method a() instantiated
the class B object. Method a() should not call method b() if the class B object was
returned by another object’s method.
The Open-Closed Principle says to close a superclass for modification but open
it for extensions by subclasses. The superclass can hide and encapsulate the
implementation of the common parts of the state and behavior inherited by its
subclasses. This principle supports code stability.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

145
6 Don’t surprise your users
This chapter covers
The Principle of Least Astonishment and how to avoid surprising your users
Preventing unexpectedly poor runtime performance
Careful coding with Python lists, tuples, and arrays
Refactoring code to improve performance
Applying Programming by Contract to a class and its methods
We all love surprise parties, but being surprised by the results of a function call is a definite sign of
poor design. Well-designed software should not contain any surprises that can cause runtime logic
errors or poor performance.
Ideally, when we design a class, its objects will behave and perform just the way its users expect.
A user can be another programmer who uses the class or an end user who interacts with the
application. Unexpected behavior can lead to runtime logic errors or applications that don’t
perform well.
This chapter covers some common unwanted code surprises and ways to eliminate them. Some
bad surprises are simply how Python works. However, some surprises are a result of preventable
coding faults, such as the common off-by-one error. A well-named function or method won’t
mislead another programmer to believe that it does something other than what its name suggests.
We can avoid the surprise of poor performance with more efficient programming or a better
choice of data structures. Even a built-in data structure such as a list can be inefficient if we don’t
take advantage of its features. The concept of Programming by Contract can eliminate many
surprises by making explicit what another programmer can expect from a class we wrote.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

146
6.1 No surprises and the Principle of Least Astonishment
There are many ways in which poor design can cause surprises. The Principle of Least Astonishment
states that there should be few, if any, surprises in our code.
THE PRINCIPLE OF LEAST ASTONISHMENT
There should be few, if any, surprises for programmers (including ourselves later) who use
our code. Surprises can cause logic and runtime errors and make code difficult to maintain.
This section covers two sources of surprises, off-by-one errors and misnamed functions. The
common off-by-one error can cause hard-to-find logic errors in a program, but it is easily
preventable as long as we are careful about such matters as how many times a loop executes. A
function or method that we wrote and misnamed may cause another programmer to experience
perplexing logic errors by assuming the function does something other than what its name
suggests. Section 6.2 is devoted to another insidious source of surprises—poor performance.
6.1.1 Off-by-one errors
It’s easy, even for an experienced programmer, to make an off-by-one error, where a computed
value is one more or one less than expected, or an operation occurs one more or one fewer time
than expected. These deceptive errors are hard to find, and they can cause surprising runtime logic
errors. A classic off-by-one error is a loop that goes around one too few or one too many times.
Listing 6.1 (Program 6.1 SurpriseLoop): main.py
if __name__ == '__main__':
count = 0
i = 5
while i <= 10: #A
count += 1
print(f'{count = }, {i = }')
i += 1
#A Potential off-by-one error: the loop executes not 10 − 5 = 5 times, but 10 − 5 + 1 = 6 times.
Indeed, this loop executes six times:
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

147
count = 1, i = 5
count = 2, i = 6
count = 3, i = 7
count = 4, i = 8
count = 5, i = 9
count = 6, i = 10
Here’s a sneakier example. Suppose we have an application that maintains the dates of scheduled
appointments. The following listing shows a Date class that the application can use. Its private
instance variables year, month, and day record a date’s year, month, and day of the month,
respectively, and we pass integer values to the constructor to initialize those variables. Therefore, if
we pass the values 2025, 2, and 4, we ought to expect to create a Date object that represents the
date February 4, 2025. To keep this example short, we’ll leave off checking the constructor’s
parameter values.
Listing 6.2 (Program 6.2 SurpriseDate-1): date .py OFF-BY-ONE ERROR!
class Date:
_MONTH_NAMES = ( #A
'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', #A
'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC' #A
) #A
def __init__(self, year, month, day):
self._year = year
self._month = month
self._day = day
def __str__(self):
return (f'{Date._MONTH_NAMES[self._month]} '
f'{self._day}, {self._year}')
#A Private class tuple of array of month names
Private class variable _MONTH_NAMES is a private static constant string array of month names. The
special method __str__() returns a date object in the form “month day, year” where the month is a
capitalized three-letter abbreviation, such as
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

148
FEB 4, 2025
The following listing is a short test program.
Listing 6.3 (Program 6.2 SurpriseDate-1): main.py OFF-BY-ONE ERROR!
from date import Date
if __name__ == '__main__':
date = Date(2025, 2, 4) # February 4, 2025
print(date)
The output from this program is
MAR 4, 2025
A nasty surprise! We expected FEB, not MAR.
This is only one example of the ubiquitous off-by-one error caused by list and tuple index values
beginning with 0 and not 1. This surprise is compounded by the Date class having a major
inconsistency: year and day of the month values are exact, but a month value apparently must be
one less. This is not obvious to the programmer who uses the Date class, and hence the runtime
logic error.
A well-designed class needs to remove the surprise. The following listing shows one way to do
so. Special method __str__() silently subtracts 1 from self._month when indexing into the
MONTH_NAMES string array.
Listing 6.4 (Program 6.3 SurpriseDate-2): date.py
class Date:
...
def __str__(self):
return (f'{Date._MONTH_NAMES[self._month - 1]} ' #A
f'{self._day}, {self._year}')
#A Subtract 1 from the month value.
This simple fix removes the surprise, and the output is correct:
FEB 4, 2025
Subtracting 1 from month has a tiny runtime cost. But if the cost is a concern, then there is another
solution.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

149
Listing 6.5 (Program 6.4 SurpriseDate-3): date.py
class Date:
_MONTH_NAMES = (
'', #A
'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN',
'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'
)
def __init__(self, year, month, day):
self._year = year
self._month = month
self._day = day
def __str__(self):
return (f'{Date._MONTH_NAMES[self._month]} ' #B
f'{self._day}, {self._year}')
#A Dummy first element
#B No longer needs to subtract 1
Now, there is a dummy first element (an empty string) in _MONTH_NAMES[0] and special method
__str_() no longer needs to subtract 1 from self._month. We’ve eliminated this runtime cost at the
expense of one unused array element. Again, the Date class behaves as expected, and the test
program produces the correct output.
6.1.2 Misnamed functions can mislead their callers
A frequent source of unwanted surprises for a programmer using another programmer’s code is a
poorly named function that does something unexpected when called. Often, we know what we
intend a function to do as we write it, and therefore, we may not realize that the name we chose is
ambiguous or misleading. Or, the name may have been appropriate when we wrote the function,
but we subsequently modified the function without changing its name.
Here’s an example of how a poorly named function called by an unwary user can lead to a
runtime logic error. Class SortedList consists of the public static method merge that has two list
parameters, list1 and list2.
Listing 6.6 (Program 6.5 SurpriseMerge-1): sortedlist.py MISNAMED FUNCTION
class SortedList:
@staticmethod
def merge(list1, list2):
len1 = len(list1)
len2 = len(list2)
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

150
merged = []
i1 = i2 = 0
while (i1 < len1) and (i2 < len2): #A
if list1[i1] <= list2[i2]: #A
merged.append(list1[i1]) #A
i1 += 1 #A
else: #A
merged.append(list2[i2]) #A
i2 += 1 #A
if i1 < len1:
merged += list1[i1:] #B
elif i2 < len2:
merged += list2[i2:] #C
i = 0 #D
while i < len(merged): #D
j = i + 1 #D
#D
while j < len(merged): #D
if merged[i] == merged[j]: #D
merged.pop(j) #D
else: #D
j += 1 #D
#D
i += 1 #D
return merged
#A Merge list1 and list2.
#B Append the remainder of list1.
#C Append the remainder of list2.
#D Remove duplicate values.
In the following listing, our test program initializes two sorted lists, list1 and list2, and passes them
to the static method SortedList.merge(). (In an actual application, we should check that the values in
the two lists are indeed sorted.) Based on the method name, we expect the method to return a list
that contains all the merged values from list1 and list2. The program then prints the frequencies of
the values in the merged list.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

151
Listing 6.7 (Program 6.5 SurpriseMerge-1): main.py MISNAMED FUNCTION
from sortedlist import SortedList
from collections import Counter
if __name__ == '__main__':
list1 = [ 2, 5, 5, 5, 7, 11, 11, 11, 13, 13 ]
list2 = [ 0, 1, 2, 2, 2, 2, 4, 4, 5, 6, 7, 7, 9, 11 ]
print(f' {list1 = }')
print(f' {list2 = }')
merged_list = SortedList.merge(list1, list2) #A
print(f'{merged_list = }')
print()
print('Frequency table')
for i, count in Counter(merged_list).items(): #B
print(f'{i:7d}: {count}')
#A Merge the two lists.
#B Print the frequencies of the values in the merged ist.
The output is
list1 = [2, 5, 5, 5, 7, 11, 11, 11, 13, 13]
list2 = [0, 1, 2, 2, 2, 2, 4, 4, 5, 6, 7, 7, 9, 11]
merged_list = [0, 1, 2, 4, 5, 6, 7, 9, 11, 13]
Frequency table
0: 1
1: 1
2: 1
4: 1
5: 1
6: 1
7: 1
9: 1
11: 1
13: 1
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

152
Surprise! We have a serious logic error. Because the function unexpectedly removed all the
duplicate values, each frequency is at most 1. A better name for the function that won’t mislead a
programmer might be merge_and_deduplicate.
6.2 Poor performance is an unwelcome surprise
Poor runtime performance is another bad surprise, caused by often hidden, inefficient
programming. Poor performance can even come from using a built-in data structure such as a list, if
we don’t fully use its features.
Poor performance can cause longer running time or using too much memory or other resources.
An application that does what it’s supposed to do (i.e., it meets its functional requirements) but
performs poorly (i.e., it fails to meet a nonfunctional performance requirement) is an unwelcome
surprise. Poor performance can result from careless use of a data structure.
6.2.1 Bad design can cause unexpected performance problems
Choosing the right algorithms is an important part of good design. A function that implements a
poorly chosen algorithm can lead to unexpected performance problems, such as long running time
for the unwary caller of the function.
Consider the static method SortedList.merge() in listing 6.6. As the lengths of the two vectors
grow linearly, the running time of the function grows exponentially.
The growing running times are due to the way the method removed the duplicate values from
the merged list. The second while loop contains a nested third while loop, but a much better design
would not require nested loops. We create a set from the merged list and then create a list from the
set elements. Since a set does not allow duplicate values, we can replace the two while loops and
the return merged statement with this return statement:
return list(set(merged))
and the code will run faster.
However, an even better solution is to prevent duplicate values from entering the merged list, as
in the following listing. By taking advantage of the sorted lists, we simply don’t append a value to
merged_list if it equals the last appended value.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

153
Listing 6.8 (Program 6.6 SurpriseMerge-2): sortedList.py RUNS FASTER
class SortedList:
@staticmethod
def merge_and_deduplicate(list1, list2):
len1 = len(list1)
len2 = len(list2)
merged = []
i1 = i2 = 0
while (i1 < len1) or (i2 < len2):
if ( (i1 < len1)
and ((i2 == len2) or (list1[i1] <= list2[i2]))):
if (len(merged) == 0) or (list1[i1] != merged[-1]): #A
merged.append(list1[i1])
i1 += 1
else:
if (len(merged) == 0) or (list2[i2] != merged[-1]): #A
merged.append(list2[i2])
i2 += 1
return merged
#A Don’t append a duplicate value (a value equal to the last appended value).
This improved version of the merge function scales well. As the lengths of the two SortedList objects
increase linearly, the function’s run time increases approximately linearly in proportion.
REFACTORING
We refactor code by redesigning it to improve it in some way, such as making it perform
more efficiently, but without changing its functionality or how to use it. Refactoring is a
common operation during development iterations.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

154
6.2.2 Performance surprises of lists, tuples, and arrays
Most Python applications use the ubiquitous built-in list data structure to store an ordered
sequence of values. A list greatly simplifies programming with high-level operations such as slicing
and concatenation, and we can change, insert, append, and delete elements from a list. A list’s size
can change dynamically, but we don’t have to deal with allocating or deallocating elements.
However, we must know how to take advantage of the capabilities of lists and similar data
structures to get good runtime performance.
For example, the following listing shows how much better performance we get from using list
comprehension to fill a list than from using a for loop. Many programming languages have for
loops, and we may be tempted to use one here. But Python’s list comprehension runs faster
because it is optimized for creating and filling a list. The for loop code is generic and requires a call
to function append() for each element.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

155
Listing 6.9 (Program 6.7 ListPerformance-1): main.py
import time
SIZE = 10_000_000
if __name__ == '__main__':
lst = []
start_time = time.time_ns()
for i in range(SIZE): #A
lst.append(10*i) #A
elapsed_time_for_loop = (time.time_ns() - start_time)/1.0e9
print(' for loop elapsed time = '
f'{elapsed_time_for_loop:6.4f} seconds')
start_time = time.time_ns()
lst = [10*i for i in range(SIZE)] #B
elapsed_time_comprehension = (time.time_ns() - start_time)/1.0e9
print('comprehension elapsed time = '
f'{elapsed_time_comprehension:6.4f} seconds')
print()
improvement = (
(elapsed_time_for_loop - elapsed_time_comprehension)
/elapsed_time_for_loop
)
print(f'{improvement = :4.1%}')
#A Fill the list with a for loop and calls to the append() function.
#B Create and fill the list with list comprehension.
Example output from this program:
for loop elapsed time = 0.7970 seconds
comprehension elapsed time = 0.5777 seconds
improvement = 27.5%
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

156
The next example is another demonstration of how taking advantage of a list object’s built-in
functionalities can improve performance. It also shows that replacing a list with a tuple or an array
can further improve performance.
The example involves a list of 10,000,000 random values from 1 to 5, inclusive, that can
represent the results of a scientific experiment. We want to compare averages of different samples
of the values. The program first calculates the average of all the values, then the average of a
sample of every 50th value, the average of every 100th value, the average of every 1000th value, and
finally the average of every 10,000th value. Therefore, the stride (step) values are 1, 50, 100, 1000,
and 10,000.
Class SampleAverages in the following listing has three static methods. Method use_for_loop()
uses a for loop over every strideth element of the values to compute the average. Method
use_stride() instead uses the list slice operator [::stride] to select the values to average. First, we will
call it with a list argument, and then with a tuple argument. Method use_numpy() also uses the slice
operator, but with a numpy array and the numpy function mean().
Listing 6.10 (Program 6.8 ListPerformance-2): averages.py (1 of 2)
import time
import numpy as np
class SampleAverages:
@staticmethod
def use_for_loop(values, stride):
count = 0
total = 0
for i in range(int(len(values)/stride)): #A
count += 1
total += values[i*stride]
return total/count
@staticmethod
def use_stride(values, stride):
selection = values[::stride] #B
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

157
count = len(selection)
return sum(selection)/count
@staticmethod
def use_numpy(values, stride):
selection = values[::stride] #B
return np.mean(selection) #C
@staticmethod
def do_calculations ...
#A Use a for loop.
#B Use the stride operator.
#C Call the numpy mean() function.
The following listing shows static method do_calculations(). It calls one of the averaging methods
shown in the previous listing to calculate all the sample averages, one per stride value, for one
sequence of values. It returns the elapsed time to compute all the sample averages. The sequence
can be a list, a tuple, or a numpy array. The method also calculates the percentage of improvement
over another timing. The method’s avgs_function parameter is passed one of the averaging
methods use_for_loop(), use_stride(), or use_numpy().
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

158
Listing 6.11 (Program 6.8 ListPerformance-2): averages.py (2 of 2)
@staticmethod
def do_calculations(sequence, strides, avgs_function, label,
other_label=None, other_et=None):
avgs = []
start_time = time.time_ns()
for stride in strides: #A
avgs.append(avgs_function(sequence, stride)) #B
et = (time.time_ns() - start_time)/1.0e9 #C
print(f'{label} elapsed time = {et:6.4f} seconds')
print(f'{avgs = }')
print()
if other_et is not None:
improvement = (other_et - et)/other_et #D
print(f'Improvement of {label} over {other_label}: '
f'{improvement:4.1%}')
print()
return et
#A Calculate the average for all the strides.
#B Call use_for_loop(), use_stride(), or use_numpy().
#C The total elapsed time over all the strides.
#D Calculate the improvement over another timing.
The test code in main.py creates the list of random values and calls method use_for_loop() and
method use_stride() with the list. Then it converts the list to a tuple and calls method use_stride()
with the tuple. Finally, it converts the list to a numpy array and calls method use_numpy() with the
array.
Listing 6.12 (Program 6.8 ListPerformance-2): main.py
import random
import numpy as np
from averages import SampleAverages
SIZE = 10_000_000
STRIDES = (1, 50, 100, 1000, 10_000)
if __name__ == '__main__':
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

159
random.seed(0)
lst = [random.randint(1, 5) for _ in range(SIZE)]
for_loop_label = 'for loop'
list_stride_label = 'list stride'
tuple_stride_label = 'tuple stride'
array_stride_label = 'ndarray stride'
elapsed_time_for_loop = \
SampleAverages.do_calculations(
lst, STRIDES,
SampleAverages.use_for_loop,
for_loop_label)
elapsed_time_list_stride = \
SampleAverages.do_calculations(
lst, STRIDES,
SampleAverages.use_stride,
list_stride_label,
other_label=for_loop_label,
other_et=elapsed_time_for_loop)
tpl = tuple(lst)
elapsed_time_tuple_stride = \
SampleAverages.do_calculations(
tpl, STRIDES,
SampleAverages.use_stride,
tuple_stride_label,
other_label=list_stride_label,
other_et=elapsed_time_list_stride)
arr = np.array(lst)
elapsed_time_array_stride = \
SampleAverages.do_calculations(
arr, STRIDES,
SampleAverages.use_numpy,
array_stride_label,
other_label=tuple_stride_label,
other_et=elapsed_time_tuple_stride)
overall = ( (elapsed_time_for_loop - elapsed_time_array_stride)
/elapsed_time_for_loop
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

160
)
print(f'Overall improvement: {overall:4.1%}')
The output below clearly shows that using a list and for loop to compute the sample averages has
the worst performance. The performance improves by replacing the for loop with the slice operator
containing the stride. Using a tuple instead of a list further improves the performance. The best
performance uses a numpy array and the mean() function.
for loop elapsed time = 0.9100 seconds
avgs = [2.99985, 2.999335, 3.00003, 2.9792, 2.984]
list stride elapsed time = 0.1496 seconds
avgs = [2.99985, 2.999335, 3.00003, 2.9792, 2.984]
Improvement of list stride over for loop: 83.6%
tuple stride elapsed time = 0.0830 seconds
avgs = [2.99985, 2.999335, 3.00003, 2.9792, 2.984]
Improvement of tuple stride over list stride: 44.5%
ndarray stride elapsed time = 0.0114 seconds
avgs = [2.99985, 2.999335, 3.00003, 2.9792, 2.984]
Improvement of ndarray stride over tuple stride: 86.3%
Overall improvement: 98.8%
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

161
6.3 Programming by Contract helps to eliminate surprises [optional]
The bottom line: Never leave surprises in your code! One way to eliminate surprises in a class that
we write is to include a contract for programmers who use the class. The contract for a method
states explicitly what preconditions must be true when a caller calls the function and what
postconditions the caller can expect to be true when the function returns. The contract also states
the class invariant. During run time, the class invariant must be true for each object after the object
is created, and it must remain true for each object before and after every call to a method that
mutates the object’s state. (It may be violated temporarily by an object undergoing mutation.) The
invariant ensures that there are never any objects left in an invalid state.
By defining the preconditions and postconditions of methods of a class and the class invariant,
both the programmers and the users of a class can be confident that objects of the class will behave
correctly as expected at run time and therefore not have surprises.
PROGRAMMING BY CONTRACT
The concept of programming by contract was first proposed by the object-oriented
programming pioneer Bertrand Meyer. His Eiffel programming language had constructs that
allowed a programmer to define preconditions, postconditions, and invariants, and the
language checked at run time that they were true. This was especially helpful while
debugging a program. The checks could be turned off when the application is deployed so
that they don’t hurt performance.
The Python language doesn’t have native support for programming by contract. However, we can
still implement its concepts using existing features of the language. While it’s probably overkill to
use contracts on every class of an application, it may be wise to use them on the most critical
classes.
This section shows how we can program a circular buffer class by contract. We’ll add
preconditions and postconditions to its methods and devise a class invariant. We’ll see how the
contract helps ensure that the class is correctly designed.
6.3.1 Programming a circular buffer by contract
The following example demonstrates programming by contract on a class that implements a
circular buffer. Private instance variable _buffer is a buffer implemented as a list with a _capacity,
the maximum number of elements we allow the buffer to contain. Public method add() inserts an
element at the tail of the buffer, and public method remove() removes an element from the head of
the buffer and returns the element’s value. Private instance variables _head and _tail are the
indexes of the head and tail elements, respectively. Private instance variable _count keeps track of
how many elements are currently in the buffer.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

162
Public method add() increments instance variable _tail after adding a new value to the buffer.
The value of _tail wraps around to the other end of the buffer when it exceeds the buffer capacity.
Public method remove() increments instance variable _head after removing a value from the buffer.
Its value also wraps around to the other end of the buffer when it exceeds the buffer capacity.
Private method _class_invariant() computes the class invariant and returns true if the invariant
holds or false otherwise. Public methods add_precondition() and add_postcondition() implement
the pre- and postconditions of method add(), respectively. Public methods remove_precondition()
and remove_postcondition() implement the pre- and postconditions of method remove(),
respectively.
Listing 6.13 (Program 6.9 CircularBuffer-1): buffer.py
class CircularBuffer:
def _class_invariant(self): #A
return ( (0 <= self._head < self._capacity)
and (0 <= self._tail < self._capacity)
)
def __init__(self, capacity):
self._capacity = capacity
self._head = 0
self._tail = 0
self._count = 0
self._buffer = [0]*capacity
assert self._class_invariant(), \ #B
'class invariant is false' #B
@property
def count(self): return self._count
def add_precondition(self): #I
return self._count < self._capacity
def add_postcondition(self): #J
return self._count > 0
def add(self, value):
assert self.add_precondition(), \ #C
'add_precondition is false' #C
self._buffer[self._tail] = value
self._tail = (self._tail + 1)%self._capacity
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

163
self._count += 1
assert self.add_postcondition(), \ #D
'add_postcondition is false' #D
assert self._class_invariant(), \ #E
'class_invariant is false' #E
def remove_precondition(self): #K
return self._count > 0
def remove_postcondition(self): #L
return self._count < self._capacity
def remove(self):
assert self.remove_precondition(), \ #F
'remove_precondition is false' #F
value = self._buffer[self._head]
self._head = (self._head + 1)%self._capacity
self._count -= 1
assert self.remove_postcondition(), \ #G
'remove_postcondition is false' #G
assert self._class_invariant(), \ #H
'class_invariant is false' #H
return value
#A Private method to test the class invariant
#B Check the class invariant after constructing a circular buffer.
#C Check the precondition before adding.
#D Check the postcondition before returning.
#E Check the class invariant before returning.
#F Check the precondition before removing.
#G Check the postcondition before returning.
#H Check the class invariant before returning
#I add precondition: the buffer is not full
#J add postcondition: the buffer is not empty
#K remove precondition: the buffer is not empty
#L remove postcondition: the buffer is not full
The test program in main.py exercises the circular buffer.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

164
Listing 6.14 (Program 6.10 CircularBuffer-1): main.py
from buffer import CircularBuffer
SIZE = 5
if __name__ == '__main__':
buffer = CircularBuffer(SIZE)
for value in range(10, 101, 10):
if buffer.add_precondition(): #A
buffer.add(value) #A
print(f'added {value}')
for _ in range(10):
if buffer.remove_precondition(): #B
value = buffer.remove() #B
print(f'removed {value}')
buffer.remove() #C
#A Check the add precondition before calling buffer.add().
#B Check the remove precondition before calling buffer.remove().
#C Call buffer.remove() without first checking its precondition.
The output of the test program is:
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

165
added 10
added 20
added 30
added 40
added 50
removed 10
removed 20
removed 30
removed 40
removed 50
---------------------------------------------------------------------
AssertionError Traceback (most recent call last)
File ~/SoftwareDesign/programs/Python6.9-CircularBuffer-1/main.py:18
15 value = buffer.remove()
16 print(f'removed {value}')
---> 18 buffer.remove()
File ~/SoftwareDesign/programs/Python6.9-CircularBuffer-1/buffer.py:47, in
CircularBuffer.remove(self)
46 def remove(self):
---> 47 assert self.remove_precondition(), \
48 'remove_precondition is false'
50 value = self._buffer[self._head]
51 self._head = (self._head + 1)%self._capacity
AssertionError: remove_precondition is false
The following sections explain the preconditions, postconditions, class invariant, and output of this
program.
6.3.2 Precondition: What must be true before calling a function
The precondition of a method or function must be true when a method or function is called. It is the
caller’s responsibility to check the precondition before making the call.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

166
THE PRECONDITION PRINCIPLE
The precondition of a function is a condition (a Boolean expression) that must be true when
we call the function. According to programming by contract, if the precondition of a function
is true and we call the function, the function must guarantee that it will behave properly. It is
the responsibility of the caller to check the precondition before making the call. If the
precondition is false, but we call the function anyway, the function is not required to behave
in a manner suitable or convenient for the caller.
If the precondition is for a method of a class, then the class must provide some public means
for the caller to check the validity of the precondition. Because it’s the caller’s responsibility
to do so, the function has no obligation to check whether the precondition is met.
In class CircularBuffer (listing 6.13), the precondition to calling method add() is that the buffer is not
full: self._count < self._capacity. Therefore, the test program (listing 6.14) first checks that
precondition. It doesn’t try to add if the buffer is full. The precondition to calling method remove() is
that the buffer is not empty: self._count > 0. It doesn’t try to remove an element if the buffer is
empty.
If the precondition of a function is true, and we call the function, the function must guarantee
that it will behave properly. For function add(), that means it must properly add the value to the tail
of the buffer and advance instance variable _tail. Function remove() must properly remove a value
from the head of the buffer, advance instance variable _head, and return the removed value.
Because it’s the caller’s responsibility to check the precondition of a function, the function is
relieved of the obligation to check it. What happens if the precondition of a function is not met, but
we call the function anyway? The function is not required to behave in a manner suitable to the
caller. For example, if we call method add(), and the buffer is already full, ways that function can
behave include the following:
Assumes the caller checked the precondition and proceeds to add the new value
to the buffer, thereby overwriting an existing value. This also causes the value of
instance variable _tail cross the value of instance variable _head and the value of
instance variable _count to exceed the capacity of the buffer.
Checks the precondition and if it’s not met, it does not add the new value, but
instead does nothing or prints an error message.
Checks the precondition, and if it’s not met, aborts the program.
If we don’t check the precondition of method remove() and call it when the buffer is empty, ways
that function can behave include the following:
Assumes the caller checked the precondition and proceed to remove a value
from the buffer, thereby potentially returning a value that had previously been
returned. This also causes the value of instance variable _head to cross the
value of instance variable _tail and the value of instance variable _count to go
negative.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

167
Checks the precondition and if it’s not met, it does not remove a value, but
instead does nothing, prints an error message, or returns a dummy value.
Checks the precondition, and if it’s not met, aborts the program.
In class CircularBuffer, we chose the abort option for both methods. In each function, the assert
checks the value of the function’s precondition and immediately aborts the program if the
precondition is not met. Programming by contract allows a function’s programmer to code a
behavior that may not necessarily be convenient for the caller. Another option, especially in an
actual application, is to raise an exception that the caller must handle.
The test program (listing 6.14) made its last call to remove() without first checking the function’s
precondition. The buffer was empty, so the function aborted the program with an assertion failure.
If the precondition of a method or function includes the fact that the function will raise an exception
for bad argument values, we consider the exception to be part of the contract with the caller. Then,
the caller is no longer obligated to check the argument values before calling the function.
6.3.3 Postcondition: What must be true after returning from a function
However, if a function was called when its precondition was met, then it is the responsibility of the
function to meet its postcondition before returning.
THE POSTCONDITION PRINCIPLE
The postcondition of a function is a condition (a Boolean expression) that must be true when
the function returns. According to programming by contract, if a function was called when its
precondition was met, it is the responsibility of the function to meet its postcondition before
returning.
We can assume that if we called a function and it returned, it behaved properly, and the
postcondition is true. This relieves us from the obligation to do an error check after the call.
(Of course, we still can check.)
In class CircularBuffer (listing 6.13), if we call method add() after confirming that its precondition is
met, then the function must successfully add the new value to the buffer, and thereafter, the buffer
cannot be empty. Before the function returns, it checks its postcondition: self._count > 0. For this
example, the function aborts the program if the postcondition isn’t met.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

168
If we call method remove() after confirming that its precondition is met, then the function must
successfully remove a value from the buffer and return it, and thereafter, the buffer cannot be full.
Before the function returns, it checks its postcondition: self._count < self._capacity. In this example,
the function aborts the program if the postcondition isn’t met.
In an actual application, a function would somehow try a different way to meet its postcondition
rather than simply abort the program. A possible remedy is to raise an exception if a problem
occurred. That would change the function’s contract. The postcondition would then be that the
function either succeeded or it raised an exception.
6.3.4 Class invariant: What must remain true of object states
A class invariant ensures that no invalid objects are created at run time and that each of its objects
never enters an invalid state.
THE CLASS INVARIANT PRINCIPLE
The class invariant is a condition (a Boolean expression) involving the class’s state
implementation that must be true after each object is created at run time (i.e., after each
constructor call). It must remain true each time after an object is mutated by a setter
function or any other function that changes the object’s state. The class invariant ensures
that no invalid objects are created and that no object ever enters an invalid state. Typically,
the class invariant is a relationship among the class’s instance variables.
In class CircularBuffer (listing 6.17), the class invariant says that the values of instance variables
head and tail are both always greater than or equal to 0 and less than the buffer capacity:
( (0 <= self._head < self._capacity)
and (0 <= self._tail < self._capacity)
)
The private Boolean method _class_invariant() performs this test, and we must call it before the
constructor returns and before each of the methods add() and remove() returns. The constructor
sets an object’s initial state, and the two methods modify the object’s state. Like with the function
preconditions and postconditions in this example class, the program aborts if the class invariant is
ever false. An actual application might raise an exception instead.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

169
Is this a valid class invariant? When an object is first created, instance variables _head and _tail
are each set to 0, which satisfies the >= 0 parts of the invariant. Methods add() and remove() each
increments tail and head by 1 and then performs the modulo operation with instance variable
capacity on the sum:
(self._tail + 1)%self._capacity
and
(self._head + 1)%self._capacity
The result of a modulo operation is always a value from 0 up to but not including the value of the
divisor (self._capacity in this case), and so the values of _head and _tail each remains >= 0 and <
self._capacity. Therefore, we have a valid invariant.
The class invariant can be violated while an object’s state is changing. For example, in function
add(), had we written
self._tail = self._tail + 1;
self._tail = self._tail% self._capacity
the value of _tail can briefly equal the value of _capacity before the modulo operation occurs.
However, the class invariant must be true again before the function returns.
Finding an appropriate invariant for a class can be challenging. The class invariant we chose for
class CircularBuffer alone is not sufficient to ensure that the buffer will operate correctly. For
example, it does not guarantee that the values of instance variables _head and _tail do not cross
each other. The class invariant works together with the preconditions and postconditions of the
methods to guarantee that the buffer will operate correctly.
PROVING A PROGRAM TO BE CORRECT
Theoretically, if we can specify the proper class invariants and the preconditions and
postconditions for each method in every class of a program, we can prove that the program
is correct. However, this is very difficult in practice for all but the simplest programs.
Famous computer scientist Don Knuth once said about a program he had written, “Beware of
bugs in the above code; I have only proved it correct, not tried it” (https://www- cs-faculty.
stanford. edu/~knuth/ faq.html).
6.4 Summary
Code should behave as expected by its users.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

170
The Principle of Least Astonishment states that there should be few, if any,
surprises in well-designed software. Some surprises are due to the way Python
operates. We can also inadvertently put surprises in our code.
Off-by-one errors are common, and they can lead to insidious runtime logic
errors that are hard to find.
A poorly named function can mislead a caller of the function to believe that it
does something other than its name suggests.
Poorly designed code can have unexpected bad runtime performance, which
includes longer than expected running times or excessive use of memory and
other resources.
A Python list is easy to use and very powerful. However, we should use build-in
features such as list comprehension and slicing to ensure good performance.
Using tuples or numpy arrays instead of lists can improve performance.
Programming by contract ensures users of a class that we wrote won’t be
surprised by how its objects behave at run time.
The Precondition Principle states that the caller of a function must ensure that
the function’s precondition is true before making the call. If the precondition is
not true but the function is called anyway, the function can behave in a manner
that might not be convenient for the caller. A typical behavior in an application is
for the function to raise an exception. On the other hand, if the precondition is
true, the function must guarantee that it will perform correctly.
The Postcondition Principle states that the function must ensure that its
postcondition is true before returning.
The Class Invariant Principle involves a condition that must remain true at run
time. It ensures that none of the class’s objects are left in an invalid state. In an
application, the class can raise an exception if any object violates its invariant.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

171
7 Design subclasses right
This chapter covers
When to override and when to overload methods
Type hints and multimethod
The Liskov Substitution Principle
Designing classes and subclasses properly with is-a and has-a relationships
The Favor Composition over Inheritance Principle
Factory classes
Using Programming by Contract correctly when designing subclasses
As described in section 1.8, inheritance is one of the main concepts of object-oriented
programming. When we create an application with class hierarchies of superclasses and subclasses,
we must design the subclasses right to achieve a well-designed application.
We will examine several important design issues. We should know when to override methods
and when to overload methods, and whether or not to use type hints. The Liskov Substitution
Principle states that we should be able to substitute a superclass object by one of its subclass
objects, and it provides additional rules to help ensure that we designed the subclasses correctly.
The Favor Composition over Inheritance Principle involves making design tradeoffs between is-a
relationships and has-a relationships among classes to avoid hardcoding object behaviors in the
source code and instead provide the flexibility to make behavior decisions at run time. We can
increase flexibility of our code further by using factory classes. If we use Programming by Contract
(introduced in section 6.3) with subclasses, we must be extra careful testing the preconditions and
postconditions of any overriding methods.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

172
7.1 When to override and when to overload methods
This section describes method overriding and overloading, used by the example programs in this
and the previous chapters. Good class design can use both concepts, so we should know how to
use them properly when designing classes.
7.1.1 Override superclass methods to get subclass behavior
Method overriding involves superclasses and their subclasses. A method of a subclass overrides a
method of the superclass if the two methods have the same signature. The signature of a method
consists of its method name, the number and order of its parameters, and the datatype of its return
value. The names of the parameters are not included in the signature.
In statically typed languages like Java and C++ where we must explicitly specify the datatype of
each parameter, method signatures include the order of the parameters, such as int, float vs. int,
float, int. But Python is dynamically typed, and we don’t specify the datatypes of the parameters or
return values. Therefore, Python methods with the same name can have different signatures based
only on having different numbers of parameters. (We’ll discuss Python’s type hints feature shortly.)
We should use method overriding when we want a subclass object to have similar but not
exactly the same behavior as a superclass object. The subclass’s overriding method implements the
desired subclass behavior. At run time, polymorphism can determine whether to call the superclass
method or the overriding method from one of the subclasses. We’ll use the Code to the Interface
Principle (section 2.3.3).
Figure 7.1 shows an example of method overriding. Methods _cost() and print_cost() in subclass
OrganicItem override the methods with the same signatures in superclass Item. The UML diagram
indicates that instance variable _name and method _cost() in the superclass Item are protected—
they should be accessible only by the Item objects or OrganicItem subclass objects.
Figure 7.1 Methods _cost() and _print_cost() in each of the subclass OrganicItem override the
corresponding methods in superclass Item with the same signature.
Subclass OrganicItem has a private instance variable _markup which is the percentage price markup
for an organic item.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

173
The following listing shows superclass Item and its subclass.
Listing 7.1 (Program 7.1 Item): item.py
class Item:
def __init__(self, name):
self._name = name
def _cost(self, price, weight): #A
return price*weight
def print_cost(self, price, weight): #A
print(f'The total cost of {self._name} '
f'is ${price:.2f}/lb')
print(f' times ${weight:.1f} lbs '
f'= ${self._cost(price, weight):.2f}')
class OrganicItem(Item):
def __init__(self, name, markup):
super().__init__(name)
self._markup = markup
def _cost(self, price, weight): #B
return super()._cost(price, weight)*(1 + self._markup/100) #C
def print_cost(self, price, weight): #B
print(f'The total cost of {self._name} '
f'is ${price:.2f}/lb')
print(f' times ${weight:.1f} lbs '
f'= ${super()._cost(price, weight):.2f} '
f'+ {self._markup}% extra '
f'= ${self._cost(price, weight):.2f}')
#A Methods to be overridden.
#B Overriding methods in the subclasses
#C Call the superclass method _cost()
Method _cost() of superclass Item returns the regular cost of price times weight. In subclass
OrganicItem, method _cost() overrides method _cost() of the superclass. However, by calling super(),
the subclass _cost() method can call the overridden superclass _cost() method to calculate the
regular price, and then the subclass method adds the markup for organic items.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

174
A call to method print_cost() on a superclass Item object in turn calls the superclass _cost()
method. Calling method print_cost()on a subclass OrganicItem object invokes the overriding
method of the subclass, which in turn calls the subclass _cost() method. Polymorphism determines
which methods to call.
In the following listing, the test program in main.py demonstrates the results of the method
overriding.
Listing 7.2 (Program 7.1 Item): main.py
from item import Item, OrganicItem
if __name__ == '__main__':
regular = Item('peaches')
regular.print_cost(2.99, 2)
print()
organic = OrganicItem('organic peaches', 25)
organic.print_cost(2.99, 2)
The output is
The total cost of peaches is $2.99/lb
times $2.0 lbs = $5.98
The total cost of organic peaches is $2.99/lb
times $2.0 lbs = $5.98 + 25% extra = $7.48
7.1.2 Type hints and method overriding
Although Python is fundamentally a dynamically typed language, we can use type hints in a Python
program. Type hints help to document the programmer’s intent and prevent programming errors.
Before running a program, we can run a type checker which uses the type hints to help ensure that
the variables and parameters are used as intended. But type hints are ignored at runtime, and
therefore the language remains dynamically typed.
The following is an example of how a method can be overridden despite the use of type hints,
which may not be what the programmer intended. (Such bad design can be flagged by type-
checking tools.)
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

175
Listing 7.3 (Program 7.2 BadOverride): superclass.py BAD DESIGN!
class Superclass:
def operate(self, x: str, y: str):
return x + y
class Subclass(Superclass):
def operate(self, x: int, y: int): #A
return x*y
supe = Superclass()
sub = Subclass()
print(f"{supe.operate('Hi, ', 'Ron') = }")
print(f"{sub.operate(2, 3) = }")
print(f"{sub.operate('Hi, ', 'Ron') = }")
#A Override despite type hints
The main shows how a runtime error can result with unexpected overloading.
Listing 7.4 (Program 7.2 BadOverride): main.py BAD DESIGN!
from superclass import Superclass, Subclass
if __name__ == '__main__':
supe = Superclass()
sub = Subclass()
print(f"{supe.operate('Hi, ', 'Ron') = }")
print(f"{sub.operate(2, 3) = }")
print(f"{sub.operate('Hi, ', 'Ron') = }") #A
#A Wrong method called
Because Subclass.operate() overrides Superclass.operate() despite the type hints, the second call to
sub.operate() calls the subclass method rather than the superclass method as was probably
intended. The unfortunate output is
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

176
super.operate('Hi, ', 'Ron') = 'Hi, Ron'
sub.operate(2, 3) = 6
Traceback (most recent call last):
File "/Users/rmak/SoftwareDesign/programs/Python7.2x-
BadOverride/superclass.py", line 12, in <module>
print(f"{sub.operate('Hi, ', 'Ron') = }")
^^^^^^^^^^^^^^^^^^^^^^^^^^
File "/Users/rmak/SoftwareDesign/programs/Python7.2x-
BadOverride/superclass.py", line 5, in operate
def operate(self, x: int, y: int): return x*y
~^~
TypeError: can't multiply sequence by non-int of type 'str'
7.1.3 Overload methods that have similar or equivalent behaviors
Method overloading occurs when two or more methods of a class have the same name but
different signatures. We should overload a set of methods when they are so strongly related that it
doesn’t make sense to invent a different name for each method. Python knows which overloaded
function or method to invoke based on the call’s arguments.
METHOD OVERLOADING IS VERY COMMON
Function overloading is very common in Python programs. For example, if we consider the +
operator as a method (it maps to the special __add__() method of a class), then we have
operator overloading. If its two arguments are integer or real values, the operator returns
their sum by performing arithmetic addition. However, if the two arguments are string
values, the operator performs string concatenation and returns a string value equal to the
value of the second string added to the end of the value of the first string. The built-in len()
function (which uses the special __len__() method) can return the length of a string, list, tuple,
or any other sequence.
We can use function overloading for well-designed applications in the following situations:
The functions perform conceptually similar operations. For example,
def write_text(some_text):... # write to the terminal
def write_text(some_text, text_file): ... # write to a file
The functions perform the same operation and produce identical results. For
example,
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

177
def draw_circle(x, y, radius): ...
def draw_circle(point, radius): ...
In these two examples, if class Point has public x and y instance variables, the
second function can call the first:
def draw_circle(point, radius):
draw_circle(point.x, point.y, radius)
The functions perform equivalent operations. For example,
def search(genre, year, title): ...
def search(region, title): ...
If a Python class has multiple methods with the same name, even if they have different signatures,
only the last method in the class definition is used. Therefore, we must use runtime parameter
checking to achieve method overloading. The following is a simple example.
Listing 7.5 (Program 7.3 Shape) shape.py
import math
class Shape:
def area(self, parm1, parm2=None):
return (math.pi*parm1*parm1 if parm2 is None
else parm1*parm2
)
Method area() checks its parm1 and parm2 parameters at run time to determine whether to
calculate the area of a rectangle or the area of a circle. The following main shows that, in effect, the
method is overloaded.
Listing 7.6 (Program 7.3 Shape) main.py
from shape import Shape
if __name__ == '__main__':
rectangle = Shape()
print(f'{rectangle.area(2, 3) = }')
circle = Shape()
print(f'{circle.area(1.0) = :6.4f}')
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

178
The output is
rectangle.area(2, 3) = 6
circle.area(1.0) = 3.1416
Here’s another example. Class Line has an overloaded length() method that accepts the endpoint
coordinates of a line in various ways, including floats, lists, dictionaries, or Point objects. A Point
object stores its x and y coordinates as properties.
Listing 7.7 (Program 7.4 Line) point.py
class Point:
def __init__(self, x, y):
self._x = x
self._y = y
@property
def x(self): return self._x
@property
def y(self): return self._y
def __repr__(self):
return f'Point({self._x}, {self._y})'
Method length() of the Line class is overloaded by checking its parameters at run time. It checks
both the number of parameters and their datatypes.
Listing 7.8 (Program 7.4 Line) line.py
import math
from point import Point
class Line:
def length(self, *parms):
parmslen = len(parms)
if parmslen == 1:
x1, y1, x2, y2 = parms[0]
elif parmslen == 2:
parm1, parm2 = parms
if type(parm1) is dict:
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

179
x1 = parm1['x']
y1 = parm1['y']
elif type(parm1) is Point:
x1 = parm1.x
y1 = parm1.y
else:
x1, y1 = parm1
if type(parm2) is dict:
x2 = parm2['x']
y2 = parm2['y']
elif type(parm2) is Point:
x2 = parm2.x
y2 = parm2.y
else:
x2, y2 = parm2
elif parmslen == 4:
x1, y1, x2, y2 = parms
else:
raise Exception(f'Unsupported arguments: {parms}')
d1 = x1 - x2
d2 = y1 - y2
return math.hypot(d1, d2)
The following main makes several overloaded calls to method length() with different numbers and
datatypes of arguments.
Listing 7.9 (Program 7.4 Line) main.py
from line import Line
from point import Point
def line_lengths():
line_tuples = Line()
p1 = (1, 1)
p2 = (4, 5)
print(f' {p1 = }')
print(f' {p2 = }')
print(f'{line_tuples.length(p1, p2) = }')
print()
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

180
line_dicts = Line()
p1 = {'x': 1, 'y': 1}
p2 = {'x': 4, 'y': 5}
print(f' {p1 = }')
print(f' {p2 = }')
print(f'{line_dicts.length(p1, p2) = }')
print()
line_points = Line()
p1 = Point(1, 1)
p2 = Point(4, 5)
print(f' {p1 = }')
print(f' {p2 = }')
print(f'{line_points.length(p1, p2) = }')
print()
line_ints = Line()
print(f'{line_ints.length(1, 1, 4, 5) = }')
line_floats = Line()
print(f'{line_floats.length(1.0, 1.0, 4.0, 5.0) = }')
line_list = Line()
print(f'{line_list.length([1, 1, 4, 5]) = }')
line_error = Line()
print(f'{line_error.length(1, 1, 4) = }')
if __name__ == '__main__':
try:
line_lengths()
except Exception as error:
print()
print(f'*** ERROR: {error}')
The output is
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

181
p1 = (1, 1)
p2 = (4, 5)
line_tuples.length(p1, p2) = 5.0
p1 = {'x': 1, 'y': 1}
p2 = {'x': 4, 'y': 5}
line_dicts.length(p1, p2) = 5.0
p1 = Point(1, 1)
p2 = Point(4, 5)
line_points.length(p1, p2) = 5.0
line_ints.length(1, 1, 4, 5) = 5.0
line_floats.length(1.0, 1.0, 4.0, 5.0) = 5.0
line_list.length([1, 1, 4, 5]) = 5.0
*** ERROR: Unsupported arguments: (1, 1, 4)
7.1.4 Overloading with multimethod and type hints
Method line() in listing 7.8 showed that using runtime checks to achieve an overloaded method can
result in code that is complex and prone to error. The @multimethod decorator together with type
hints allow a class to have multiple methods with the same name but different signatures
differentiated by datatypes. This reduces complexity and increases readability by splitting the code
of method length() among its overloaded counterparts. Python is still dynamically typed, but before
our code executes, @multimethod generates the appropriate runtime code that offers Python the
same overloading capabilities as languages such as Java and C++.
Install the multimethod module with the following command in a terminal or command window:
python -m pip install multimethod
The following version of class Line demonstrates the use of the @multimethod decorator. This
example purposely has no overloaded length() method for integer parameters. Class Point is
unchanged from listing 7.7.
Listing 7.10 (Program 7.5 MultimethodLine) line.py
import math
from multimethod import multimethod
from point import Point
class Line:
@staticmethod
def _pythagoras(x1: float, y1: float,
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

182
x2: float, y2: float) -> float:
d1 = x1 - x2
d2 = y1 - y2
return math.hypot(d1, d2)
@multimethod
def length(self, x1: float, y1: float,
x2: float, y2: float) -> float:
return Line._pythagoras(x1, y1, x2, y2)
@multimethod
def length(self, coordinates: list) -> float:
x1, y1, x2, y2 = coordinates
return Line._pythagoras(x1, y1, x2, y2)
@multimethod
def length(self, point1: dict, point2: dict) -> float:
x1 = point1['x']
y1 = point1['y']
x2 = point2['x']
y2 = point2['y']
return Line._pythagoras(x1, y1, x2, y2)
@multimethod
def length(self, point1: Point, point2: Point) -> float:
x1 = point1.x
y1 = point1.y
x2 = point2.x
y2 = point2.y
return Line._pythagoras(x1, y1, x2, y2)
@multimethod
def length(self, point1: tuple, point2: tuple) -> float:
x1, y1 = point1
x2, y2 = point2
return Line._pythagoras(x1, y1, x2, y2)
As in the previous example, the following main makes several overloaded calls to method length()
with different numbers and datatypes of arguments.
Listing 7.11 (Program 7.5 MultimethodLine) main.py
from line import Line
from point import Point
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

183
def line_lengths():
line_tuples = Line()
p1 = (1, 1)
p2 = (4, 5)
print(f' {p1 = }')
print(f' {p2 = }')
print(f'{line_tuples.length(p1, p2) = }')
print()
line_dicts = Line()
p1 = {'x': 1, 'y': 1}
p2 = {'x': 4, 'y': 5}
print(f' {p1 = }')
print(f' {p2 = }')
print(f'{line_dicts.length(p1, p2) = }')
print()
line_points = Line()
p1 = Point(1, 1)
p2 = Point(4, 5)
print(f' {p1 = }')
print(f' {p2 = }')
print(f'{line_points.length(p1, p2) = }')
print()
line_list = Line()
print(f'{line_list.length([1, 1, 4, 5]) = }')
line_floats = Line()
print(f'{line_floats.length(1.0, 1.0, 4.0, 5.0) = }')
line_ints = Line()
print(f'{line_ints.length(1, 1, 4, 5) = }')
if __name__ == '__main__':
try:
line_lengths()
except Exception as error:
print()
print(f'*** ERROR: {error}')
The output is
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

184
p1 = (1, 1)
p2 = (4, 5)
line_tuples.length(p1, p2) = 5.0
p1 = {'x': 1, 'y': 1}
p2 = {'x': 4, 'y': 5}
line_dicts.length(p1, p2) = 5.0
p1 = Point(1, 1)
p2 = Point(4, 5)
line_points.length(p1, p2) = 5.0
line_list.length([1, 1, 4, 5]) = 5.0
line_floats.length(1.0, 1.0, 4.0, 5.0) = 5.0
*** ERROR: ('length: 0 methods found',
(cid:0)(<class 'line.Line'>, <class 'int'>, <class 'int'>, <class 'int'>,
(cid:0)<class 'int'>), set())
7.2 The Liskov Substitution Principle and proper subclasses
Inheritance is one of the main concepts of object-oriented programming (section 1.8). When we
create applications with a class hierarchy of superclasses and their subclasses, we must design the
subclasses right to achieve a well-designed application. The Liskov Substitution Principle helps to
ensure that we designed proper subclasses for a superclass.
THE LISKOV SUBSTITUTION PRINCIPLE
Wherever there is a superclass object in a program, we should be able to substitute an object
from one of its subclasses. In other words, we should be able to replace each occurrence of a
superclass object in the source code with an object from one of its subclasses. This
substitution should be possible because an object that is an instance of a subclass object is
also an instance of the superclass.
The Liskov Substitution Principle states that if we designed the subclasses properly, after we
make such a substitution, the program should run without logic or runtime errors, although
it may produce different but meaningful results. Subclasses that violate this design principle
were designed improperly.
The principle was named after object-oriented programming pioneer and professor Barbara
Liskov of the Massachusetts Institute of Technology (MIT).
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

185
In the for loop of the test program in listing 7.2, iteration variable which can have as its value a
superclass object or any of the subclasses. The Pasta superclass and its Chinese, German, and
Italian subclasses follow the Liskov Substitution Principle.
The next example shows how a program can fail if we disregard the principle. In another version
of the CircularBuffer class (section 6.3), we’ll implement the buffer as a list—a very bad idea as we’ll
soon see, but we’ll do it to demonstrate a point—and so CircularBuffer is a subclass of list.
Listing 7.12 (Program 7.6 CircularBuffer-2): buffer.py POORLY DESIGNED
class CircularBuffer(list): #A
def __init__(self, buffer_size):
self._buffer_size = buffer_size
self._head = 0
self._tail = 0
self._values_count = 0
for _ in range(buffer_size):
self.append(None) #B
@property
def values_count(self): return self._values_count
def add(self, value):
self[self._tail] = value #B
self._tail = (self._tail + 1)%self._buffer_size
self._values_count += 1
def remove(self):
value = self[self._head] #B
self._head = (self._head + 1)%self._buffer_size
self._values_count -= 1
return value
def __str__(self): #C
i = self._head
c = self._values_count
result = 'Contents:'
while c > 0:
result += f' {self[i]}' #B
i = (i + 1)%self._buffer_size
c -= 1
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

186
return result
#A Implement a circular buffer as a list (bad design!)
#B Use list indexing operations.
#C Print the buffer contents in order from head to tail.
As in our previous version of class CircularBuffer, method add() adds a new value to the buffer at its
tail. Method remove() removes a value from the buffer at its head. To keep this version of the class
short, we’ll leave out the pre- and postconditions and the class invariant. Because buffer is a list, we
can use list indexing operations: self[head], self[tail], and self[i]. The special method __str__() prints
the contents of the buffer in order from head to tail.
The following listing is test code in main.py. It performed two invalid operations because we
violated the Liskov Substitution Principle.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

187
Listing 7.13 (Program 7.6 CircularBuffer-2): main.py POORLY DESIGNED
from buffer import CircularBuffer
BUFFER_SIZE = 5
if __name__ == '__main__':
buffer = CircularBuffer(BUFFER_SIZE)
for value in range(10, 51, 10):
buffer.add(value)
print(buffer)
buffer[1] = 99 #A
print(buffer)
print(f'{buffer.remove() = }')
print(f'{buffer.remove() = }')
print(buffer)
buffer.pop(1) #B
print(buffer)
#A Invalid modification of a value in the buffer
#B Invalid removal of a value from the buffer
Output from the program is
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

188
Contents: 10 20 30 40 50
Contents: 10 99 30 40 50
buffer.remove() = 10
buffer.remove() = 99
Contents: 30 40 50
---------------------------------------------------------------------
IndexError Traceback (most recent call last)
File ~/CircularBuffer-2/main.py:21
18 print(buffer)
20 buffer.pop(1)
---> 21 print(buffer)
File ~/CircularBuffer-2/buffer.py:33, in CircularBuffer.__str__(self)
30 result = 'Contents:'
32 while c > 0:
---> 33 result += f' {self[i]}'
34 i = (i + 1)%self._buffer_size
35 c -= 1
IndexError: list index out of range
A circular buffer is logically not a list. We should not attempt to treat the CircularBuffer object (the
subclass) as a list object (the superclass) and use list operations to modify a value in the buffer, nor
should we remove a value using the list pop() method. These operations corrupt the circular buffer
and will result in runtime logic errors, causing the program to crash. The program failed because
subclass CircularBuffer violated the Liskov Substitution Principle—we cannot substitute a subclass
CircularBuffer object by a superclass list object because we can’t use list operations on a circular
buffer.
We can fix the program by not making CircularBuffer a subclass of list, but instead, the
CircularBuffer class can contain an instance variable that is a list. In other words, class
CircularBuffer aggregates a list. This is the difference between the is-a (inheritance) relationship and
the has-a (aggregation) relationship. The Liskov Substitution Principle can help us decide which one
to use. We can rewrite CircularBuffer as a standalone class that has private instance variable buffer
that is a list.
Listing 7.14 (Program 7.7 CircularBuffer-3): buffer.py
class CircularBuffer: #A
def __init__(self, buffer_size):
self._buffer_size = buffer_size
self._head = 0
self._tail = 0
self._values_count = 0
self._buffer = [None]*buffer_size #B
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

189
@property
def values_count(self): return self._values_count
def add(self, value):
self._buffer[self._tail] = value #C
self._tail = (self._tail + 1)%self._buffer_size
self._values_count += 1
def remove(self):
value = self._buffer[self._head] #C
self._head = (self._head + 1)%self._buffer_size
self._values_count -= 1
return value
def __str__(self):
i = self._head
c = self._values_count
result = 'Contents:'
while c > 0:
result += f' {self._buffer[i]}' #C
i = (i + 1)%self._buffer_size
c -= 1
return result
#A Not a subclass of list
#B Aggregated list
#C Indexing operations on the aggregated list
Class CircularBuffer hides its aggregated list. The public methods add() and remove() control access
to the list and uses list indexing operations, but the class does not enable invalid operations.
The following test code in main.py only performs valid add() and remove() operations on a
circular buffer.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

190
Listing 7.15 (Program 7.7 CircularBuffer-3): main.py
from buffer import CircularBuffer
BUFFER_SIZE = 5
if __name__ == '__main__':
buffer = CircularBuffer(BUFFER_SIZE)
for value in range(10, 51, 10):
buffer.add(value)
print(buffer)
print(f'{buffer.remove() = }')
print(f'{buffer.remove() = }')
print(buffer)
The program no longer crashes, and it runs properly. Its output is
Contents: 10 20 30 40 50
buffer.remove() = 10
buffer.remove() = 20
Contents: 30 40 50
7.3 Choosing the is-a and has-a relationships
An object-oriented application often contains multiple superclasses and their subclasses, and
classes with instance variables that reference other classes. Therefore, designing such an
application well requires choosing between is-a (inheritance) and has-a (aggregation) relationships,
or using a good combination of the two.
Consider an application involving children’s toys. This application includes several different toys:
toy car, model airplane, and train set. For each toy, we want to model its play action behavior (roll it
on the floor or fly it in the air) and its sound behavior (engine noises or the choo-choo sound).
7.3.1 Using is-a
Our first version of the application architecture involves primarily is-a relationships between the
abstract superclass Toy and its subclasses (figure 7.2). The Toy subclasses can have different
behaviors, but each must implement the what(), play(), and sound() methods. As the figure clearly
shows, this version of the application uses is-a relationships. ToyCar, ModelAirplane, and TrainSet is
each a subclass of Toy.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

191
Figure 7.2 This version of the application uses is-a relationships between the Toy subclasses and their
superclass. Two design faults are the duplicated code, which violates the Don’t Repeat Yourself Principle, and
the hardcoded play action and sound behavior of each toy.
We can imagine that in a real application, each toy could have more behaviors, and each behavior
would involve more than simply returning a string, as shown in the following listing.
Listing 7.16 (Program 7.8 Toys-1): toy.py POORLY DESIGNED
from abc import ABC, abstractmethod
class Toy(ABC):
@abstractmethod
def what(self): pass #A
@abstractmethod
def play(self): pass #A
@abstractmethod
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

192
def sound(self): pass #A
def __str__(self):
return (f'{self.what()}\n'
f' play: {self.play()}\n'
f' sound: {self.sound()}\n'
)
class ToyCar(Toy):
def what(self): return 'TOY CAR'
def play(self): return 'roll it'
def sound(self): return 'RRrr RRrr'
class ModelAirplane(Toy):
def what(self): return 'MODEL AIRPLANE'
def play(self): return 'fly it'
def sound(self): return 'RRrr RRrr'
def power(self): return 'wind up'
def __str__(self):
return ( super().__str__()
+ f' power: {self.power()}\n'
)
class TrainSet(Toy):
def what(self): return 'TRAIN SET'
def play(self): return 'roll it'
def sound(self): return 'choo choo'
def setup(self): return 'lay down track'
def power(self): return 'insert batteries'
def __str__(self):
return ( super().__str__()
+ f' setup: {self.setup()}\n'
+ f' power: {self.power()}\n'
)
#A Common behaviors to be implemented by each subclass
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

193
A serious fault of this design is the duplicated code among the subclasses, which violates the Don’t
Repeat Yourself Principle (section 2.3.3). For example, both ToyCar and TrainSet have the same
code that implements their play() methods, and both ToyCar and ModelAirplane have the same
code for their sound() methods. This will be a more serious problem if the code that implements
each method does more or if we add more subclasses and behaviors.
Another fault is that each toy’s play action and sound behavior are hardcoded in the source code
for each Toy subclass. For example, the source code that implements class TrainSet hardcodes that
a train set is played by rolling it and that it makes the choo-choo sound. The following test code in
main.py exercises the behaviors.
Listing 7.17 (Program 7.8 Toys-1): main.py POORLY DESIGNED
from toy import ToyCar, ModelAirplane, TrainSet
if __name__ == '__main__':
car = ToyCar()
print(car)
plane = ModelAirplane()
print(plane)
train = TrainSet()
print(train)
The output is
TOY CAR
play: roll it
sound: RRrr RRrr
MODEL AIRPLANE
play: fly it
sound: RRrr RRrr
power: wind up
TRAIN SET
play: roll it
sound: choo choo
setup: lay down track
power: insert batteries
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

194
7.3.2 Using is-a with multiple inheritance
One way to avoid duplicating code among the methods of the Toy subclasses is to make each
unique play action and sound behavior an individual class. Then, we can share those behavior
classes by having the Toy subclasses inherit them (figure 7.3). The figure shows that each of the Toy
methods is intended to be protected, although that feature is not supported directly by Python.
Figure 7.3 The play action and sound behaviors are each a separate class. Each Toy subclass has an is-a
relationship with the Toy superclass and s-a relationships with the play action and sound classes. By sharing
these classes, we’ve eliminated some code duplication, but each toy still has hardcoded behaviors.
The figure shows that both the ToyCar and TrainSet subclasses inherit and share the RollPlay class
and that both the ToyCar and ModelAirplane subclasses inherit and share the EngineSound class.
ModelAirplane also inherits the FlyPlay class, and TrainSet also inherits the ChooChooSound class.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

195
The following listing shows the play actions as individual classes.
Listing 7.18 (Program 7.9 Toys-2): playaction.py MULTIPLE INHERITANCE
class FlyPlay:
@staticmethod
def play(): return 'fly it'
class RollPlay:
@staticmethod
def play(): return 'roll it'
The following listing shows the sounds as individual classes.
Listing 7.19 (Program 7.9 Toys-2): sound.py MULTIPLE INHERITANCE
class EngineSound:
@staticmethod
def sound(): return 'RRrr RRrr'
class ChooChooSound:
@staticmethod
def sound(): return 'choo choo'
With this design, each toy can inherit its play action and sound behaviors (figure 7.3). Because each
Toy subclass already inherits from superclass Toy, we must use multiple inheritance, as shown in
the following listing. The play() methods delegate to RollPlay.play() or to FlyPlay.play(). The sound()
methods delegate to EngineSound.sound() or to ChooChooSound.play().
Listing 7.20 (Program 7.9 Toys-2): toy.py MULTIPLE INHERITANCE
from abc import ABC, abstractmethod
from playaction import RollPlay, FlyPlay
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

196
from sound import EngineSound, ChooChooSound
class Toy(ABC): ...
class ToyCar(Toy, RollPlay, EngineSound): #A
def what(self): return 'TOY CAR'
def play(self): return RollPlay.play()
def sound(self): return EngineSound.sound()
class ModelAirplane(Toy, FlyPlay, EngineSound): #A
def what(self): return 'MODEL AIRPLANE'
def play(self): return FlyPlay.play()
def sound(self): return EngineSound.sound()
def power(self): return 'wind up'
def __str__(self):
return ( super().__str__()
+ f' power: {self.power()}\n'
)
class TrainSet(Toy, RollPlay, ChooChooSound): #A
def what(self): return 'TRAIN SET'
def play(self): return RollPlay.play()
def sound(self): return ChooChooSound.sound()
def setup(self): return 'lay down track'
def power(self): return 'insert batteries'
def __str__(self): ...
#A Multiple inheritance
The same test program (Listing 7.17) generates the same output as before.
For each subclass of Toy, our second version of the application added is-a relationships with the
classes for the play action and sound behaviors, in addition to its previous is-a relationship with the
Toy superclass. For example, a ModelAirplane is a Toy, and it also is a FlyPlay and an EngineSound.
This version solved the code duplication problem because there is only one sharable copy of each
play action and each sound. However, the source code for each toy’s subclass still hardcoded the
toy’s behaviors, only this time using multiple inheritance.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

197
7.3.3 Using has-a
To have more flexibility in how the toys behave, we want to avoid hardcoding each toy’s play and
sound behaviors in the source code of its subclass and instead be able to determine the toy’s
behaviors at run time. To accomplish this, our final version of the toy application replaces the is-a
relationships between the toys and their behaviors with has-a relationships. Figure 7.4 diagrams
both the is-a and has-a relationships of this final version of the application.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

198
Figure 7.4 Each Toy subclass uses an is-a relationship to the Toy superclass. The Toy superclass uses has-a
relationships to the PlayAction and Sound classes, which allows the Toy subclasses to access and share play
action and sound behaviors. This design is more flexible and has loose coupling between the toys and their play
action and sound behaviors. The toy behaviors are no longer hardcoded in the source code but can be specified
whenever a toy object is created at run time. A toy’s behaviors can also be modified at run time by calling the
sound and play setter methods.
First, we make each play action implement interface PlayAction. Each PlayAction class must
implement method play() in a way appropriate for the subclass.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

199
Listing 7.21 (Program 7.10 Toys-3): playaction.py HAS-A RELATIONSHIPS
from abc import ABC, abstractmethod
class PlayAction(ABC):
@staticmethod
@abstractmethod
def play(self): pass
class RollPlay(PlayAction):
@staticmethod
def play(): return 'roll it'
class FlyPlay(PlayAction):
@staticmethod
def play(): return 'fly it'
Similarly, we make each sound implement interface Sound. Each Sound class must implement
method sound() in a way appropriate for the subclass.
Listing 7.22 (Program 7.10 Toys-3): sound.py HAS-A RELATIONSHIPS
from abc import ABC, abstractmethod
class Sound(ABC):
@staticmethod
@abstractmethod
def sound(): pass
class EngineSound(Sound):
@staticmethod
def sound(): return 'RRrr RRrr'
class ChooChooSound(Sound):
@staticmethod
def sound(): return 'choo choo'
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

200
We’ve applied the Open-Closed Principle (sections 2.3.3 and 5.8) to both interfaces PlayAction and
Sound. We can add new play action and sound behaviors without changing their interfaces.
Class Toy maintains has-a relationships to the play action and sound behaviors via its private
__play and __sound instance variables. Subclasses ToyCar, ModelAirplane, and Trainset maintain is-a
relationships to their superclass Toy.
Listing 7.23 (Program 7.10 Toys-3): toy.py HAS-A RELATIONSHIPS
class Toy(ABC):
def __init__(self, play, sound):
self.__play = play #A
self.__sound = sound #B
@abstractmethod
def what(self): pass
@property
def play(self):
return self.__play.play() #C
@property
def sound(self):
return self.__sound.sound() #D
@play.setter
def play(self, play):
self.__play = play
@sound.setter
def sound(self, sound):
self.__sound = sound
def __str__(self):
return (f'{self.what()}\n'
f' play: {self.__play.play()}\n'
f' sound: {self.__sound.sound()}\n'
)
class ToyCar(Toy):
def __init__(self, play, sound):
super().__init__(play, sound)
def what(self): return 'TOY CAR'
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

201
class ModelAirplane(Toy):
def __init__(self, play, sound):
super().__init__(play, sound)
def what(self): return 'MODEL AIRPLANE'
def power(self): return 'wind up'
def __str__(self):
return ( super().__str__()
+ f' power: {self.power()}\n'
)
class TrainSet(Toy):
def __init__(self, play, sound):
super().__init__(play, sound)
def what(self): return 'TRAIN SET'
def setup(self): return 'lay down track'
def power(self): return 'insert batteries'
def __str__(self):
return ( super().__str__()
+ f' setup: {self.setup()}\n'
+ f' power: {self.power()}\n'
)
#A Has-a relationship to play behavior.
#B Has-a relationship to sound behavior.
#C Delegate the play behavior to a PlayAction subclass object determined at run time.
#D Delegate the sound behavior to a PlayAction subclass object determined at run time .
In this version of the application, class Toy follows the Delegation Principle (section 2.3.2) and
delegates the play action and sound behaviors to the PlayAction and Sound classes. None of the
Toy subclasses has hardcoded these behaviors. Instead, PlayAction and Sound objects representing
these behaviors are passed to each Toy subclass’s constructor when a Toy object is created at run
time.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

202
The test code main.py in the following listing creates each Toy object and creates and passes the
appropriate PlayAction and Sound objects to the constructors. It also demonstrates changing the
sound behavior of the TrainSet object at run time.
Listing 7.24 (Program 7.10 Toys-3): main.py HAS-A RELATIONSHIPS
from toy import ToyCar, ModelAirplane, TrainSet
from playaction import RollPlay, FlyPlay
from sound import EngineSound, ChooChooSound
if __name__ == '__main__':
car = ToyCar(RollPlay(), EngineSound()) #A
print(car)
plane = ModelAirplane(FlyPlay(), EngineSound()) #A
print(plane)
train = TrainSet(RollPlay(), ChooChooSound()) #A
print(train)
train.sound = EngineSound() #B
print(train)
#A Determine each toy’s behaviors when constructing a toy object.
#B Modify a train set’s sound behavior.
Output from this final version of the application is
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

203
TOY CAR
play: roll it
sound: RRrr RRrr
MODEL AIRPLANE
play: fly it
sound: RRrr RRrr
power: wind up
TRAIN SET
play: roll it
sound: choo choo
setup: lay down track
power: insert batteries
TRAIN SET
play: roll it
sound: RRrr RRrr
setup: lay down track
power: insert batteries
Using the has-a relationship instead of the is-a relationship between the toys and their play action
and sound behaviors is an example of the Favor Composition over Inheritance Principle.
THE FAVOR COMPOSITION OVER INHERITANCE PRINCIPLE
A design that uses composition (has-a relationships where classes aggregate other classes) is
often better than inheritance (is-a relationships of subclasses to superclasses). Inheritance is
determined by the source code, and therefore, it hardcodes behavior. Composing behaviors
at run time is much more flexible. Composition also makes it easier to share code and
reduce duplication.
Because has-a relationships often involve delegation, the principle is also known as the Favor
Delegation over Inheritance Principle.
Using this design principle gives us several benefits:
Flexibility—The behaviors are not hardcoded in the source code and can be
assigned and modified at run time.
Code sharing—The behaviors are shared, thereby reducing code duplication.
Delegation—The behaviors are delegated to the PlayAction and Sound
subclasses.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

204
Loose coupling—Class Toy and its subclass have no knowledge of the
implementation of the PlayAction and Sound subclasses. The PlayAction and
Sound subclasses have no dependencies on the Toy subclasses.
Encapsulation—We can add and modify toy behaviors in the future without the
need to change the Toy superclass or any of its subclasses.
Reduced complexity—The class hierarchies are simplified. No multiple
inheritance is needed.
7.4 Use a factory function with the Code to the Interface Principle
Code such as
toy = TrainSet(RollPlay(), ChooChooSound())
is inherently inflexible because variable toy is hardcoded to only point to a TrainSet object.
What if, during a different run of the application, we need to initialize variable toy to a different
Toy object? To obtain even more flexibility, where we hardcode less and allow more to be
determined at run time, we can use a factory function or factory method that encapsulates creating a
Toy object. The purpose of a factory function or method is to encapsulate creating and returning
objects from different subclasses of a superclass. A parameter value determines which subclass
object to create and return. The factory methods are often static members of a factory class. Our
ToyFactory class encapsulates creating and returning Toy objects in the static factory method
make().
Listing 7.25 (Program 7.11 Toys-4) toyfactory.py
from toy import ToyCar, ModelAirplane, TrainSet
class ToyFactory:
toy_classes = [ToyCar, ModelAirplane, TrainSet] #A
@staticmethod
def make(toy_type, play, sound): #B
return toy_type(play, sound)
#A Toy classes to instantiate.
#B Factory method that makes a toy depending on the type.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

205
THE FACTORY PRINCIPLE
If a program creates different objects at run time, we can encapsulate creating the objects in
a factory function or method. The value of a parameter passed to the factory determines
which object to create and return. The objects that a factory can create are usually from
subclasses of a common supertype. Using a factory function or method gives us the flexibility
to determine at run time what type of object to create.
We can implement a factory method as a static method of a separate factory class, or the
factory method can be a static method of the supertype itself.
The test program in the following listing shows that now we have the flexibility to determine at run
time which Toy object to create depending on the value of variable toy_class.
Listing 7.26 (Program 7.11 Toys-4): main.py
from toyfactory import ToyType, ToyFactory
from playaction import RollPlay, FlyPlay
from sound import EngineSound, ChooChooSound
if __name__ == '__main__':
roll_play = RollPlay()
fly_play = FlyPlay()
engine_sound = EngineSound()
choo_choo_sound = ChooChooSound()
# ToyCar ModelAirplane TrainSet
plays = [roll_play, fly_play, roll_play]
sounds = [engine_sound, engine_sound, choo_choo_sound]
for toy_class, play, sound \
in zip(ToyFactory.toy_classes, plays, sounds):
toy = ToyFactory.make(toy_class, play, sound) #A
print(toy)
#A Call the factory method to make a toy.
This program’s output is
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

206
TOY CAR
play: roll it
sound: RRrr RRrr
MODEL AIRPLANE
play: fly it
sound: RRrr RRrr
power: wind up
TRAIN SET
play: roll it
sound: choo choo
setup: lay down track
power: insert batteries
7.5 Programming by Contract with subclasses [optional]
We need to be extra careful with subclasses if we use Programming by Contract (section 6.3),
especially when adhering to the Code to the Interface Principle (section 7.4). We can have problems
if a subclass overrides methods of its superclass and the overridden superclass methods have pre-
and postconditions.
Consider class Shipment and its subclasses Expedited and International. In the following listing,
the cost for all Shipment objects (which represent shipping packages by regular mail) has the
precondition that _cost must be or equal to 1 or more, as specified by the class variable _min_cost.
In an actual application, public method calculate_days() would calculate the number of days for a
particular shipment. In this example, we’ll simply hardcode the instance variable _calculated_days to
5. This meets the postcondition that the number of days must be between 1 and 14, inclusively, as
specified by the class variables _min_days, and _max_days.
Listing 7.27 (Program 7.12 ContractShipment): shipment.py POORLY DESIGNED
from enum import Enum
from exceptions import CostException, DaysException
class ShipmentKind(Enum):
REGULAR = 1
EXPEDITED = 2
INTERNATIONAL = 3
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

207
def __str__(self): return self.name
class Shipment:
_min_cost = 1
_min_days = 1
_max_days = 14
def __init__(self):
self._cost = 0
self._days = 0
self._calculated_days = 5
@property
def kind(self): return ShipmentKind.REGULAR
@property
def cost(self): return self._cost
@property
def days(self): return self._calculated_days
@cost.setter
def cost(self, cost):
# precondition
if cost >= self._min_cost: #A
self._cost = cost
else:
raise CostException(cost, self._min_cost)
def calculate_days(self):
self._days = self._calculated_days
print(f' calculated days = {self._days}')
# postcondition
if not (self._min_days <= self._days #B
<= self._max_days): #B
raise DaysException(self._days, self._min_days,
self._max_days)
#A Defensively check that the cost precondition is true.
#B Verify that the days postcondition is true.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

208
Although it’s the caller’s responsibility to check, setter method cost() defensively checks the
precondition for the cost, and it raises a CostException if the precondition is false. Method
calculate_days() is responsible for verifying the postcondition for the calculated number of days
before returning, and it rases a DaysException if the postcondition is false. We define these two
exceptions in the following listing.
Listing 7.28 (Program 7.12 ConstractShipment): exceptions.py
class CostException(Exception):
def __init__(self, cost, min_cost):
self._cost = cost
self._min_cost = min_cost
@property
def cost(self): return self._cost
@property
def min_cost(self): return self._min_cost
class DaysException(Exception):
def __init__(self, days, min_days, max_days):
self._days = days
self._min_days = min_days
self._max_days = max_days
@property
def days(self): return self._days
@property
def min_days(self): return self._min_days
@property
def max_days(self): return self._max_days
Subclass Expedited in the following listing has the precondition that the cost must be equal to 5 or
more. We’ll hardcode _calculated_days to 2, which meets the postcondition that the number must
be between 1 and 3, inclusively.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

209
Listing 7.29 (Program 7.12 ContractShipment): expedited.py POORLY DESIGNED
from shipment import ShipmentKind, Shipment
class Expedited(Shipment):
_min_cost = 5
_min_days = 1
_max_days = 3
def __init__(self):
self._cost = 0
self._calculated_days = 2
@property
def kind(self): return ShipmentKind.EXPEDITED
Subclass International in the following listing has the precondition that the cost must be equal to 10
or more. We’ll hardcode _calculated_days to 20, which meets the postcondition that the number
must be between 7 and 21, inclusively.
Listing 7.30 (Program 7.12 ContractShipment): international.py POORLY DESIGNED
from shipment import ShipmentKind, Shipment
class International(Shipment):
_min_cost = 10
_min_days = 7
_max_days = 21
def __init__(self):
self._cost = 0
self._calculated_days = 20
@property
def kind(self): return ShipmentKind.INTERNATIONAL
The table below summaries the pre- and postconditions.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

210
Table 7.1 Preconditions for the costs and numbers of days.
Days postcondition
Class Kind Cost precondition
1 <= days <= 14
Shipment REGULAR cost >= 1
1 <= days <= 3
Expedited EXPEDITED cost >= 5
7 <= days <= 21
International INTERNATIONAL cost >= 10
The test code in main.py calls function ship() three times, passing it in turn a Shipment object, an
Expedited object, and an International object. Each call also passes a cost. Funtion ship() sets
shipment.cost only if the cost precondition is true. The function defensively checks that the days
postcondition is true after calling method shipment.calculate_days() even though it’s the
responsibility of the method to ensure the postcondition is met.
Listing 7.31 (Program 7.12 ContractShipment): main.py POORLY DESIGNED
from shipment import Shipment
from expedited import Expedited
from international import International
from exceptions import CostException, DaysException
def ship(shipment, *, cost):
try:
print(f'Shipping {shipment.kind}')
print(f' setting {cost = }')
if cost >= 1: #A
shipment.cost = cost
shipment.calculate_days()
days = shipment.days
if not (1 <= days <= 14): #B
raise DaysException(days, 1, 14)
except CostException as ex:
print(f'*** Cost {ex.cost} violates cost precondition: '
f'cost >= {ex.min_cost}')
except DaysException as ex:
print(f'*** Days {ex.days} violates days postcondition: '
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

211
f'{ex.min_days} <= days <= {ex.max_days}')
else:
print('Shipped OK!')
print()
if __name__ == '__main__':
ship(Shipment(), cost=1)
ship(Expedited(), cost=4)
ship(International(), cost=112)
#A Check the cost precondition.
#B Defensively check the days postcondition.
The output is
Shipping REGULAR
setting cost = 2
calculated days = 5
Shipped OK!
Shipping EXPEDITED
setting cost = 4
*** Cost 4 violates cost precondition: cost >= 5
Shipping INTERNATIONAL
setting cost = 11
calculated days = 20
*** Days 20 violates days postcondition: 1 <= days <= 14
The first shipment went OK and there were no raised exceptions.
However, the second call to ship(), with the Expedited object, raised a CostException. Although
its cost value of 4 met the Shipment object’s cost precondition of cost >= 1, the value failed the
Expedited object’s cost precondition of cost >= 5.
The third call to ship(), with the International object, raised a DaysException. Although the
hardcoded day value of 20 met the International object’s days postcondition of 7 <= days <= 21, the
value failed the Shipment object’s days precondition of 1 <= days <= 14.
Why were exceptions raised? The problem is that function ship() tested the cost and days values
against the pre- and postconditions, respectively, of superclass Shipment. That was OK when the
value of the shipment parameter was indeed a Shipment object. But the diagram below shows why
the CostException was raised when the value of the shipment parameter was an Expedited object
and a cost value of 4.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

212
Figure 7.5 Cost 4 satisfies the superclass’s precondition but violates the subclass’s precondition.
The next diagram shows why the DaysException was raised when an International object calculated
a days value of 20.
Figure 7.6 Days 20 satisfies the subclass’s postcondition but violates the superclass’s postcondition.
One solution is to ensure that the values that satisfy the precondition of a subclass method are a
subset of the values that satisfy the precondition of the overridden superclass method. Conversely,
the values that satisfy the postcondition of a subclass method should be a superset of the values
that satisfy the postconditions of the overridden superclass method. In other words, the
precondition of a subclass method cannot be more restrictive than the preconditions of the
overridden superclass method, and the postconditions of a superclass method cannot be more
restrictive that the postconditions of the overriding subclass method.
Another solution is for the superclass and each subclass to publicly expose its pre- and
postconditions as Boolean methods. Then callers of their methods can use polymorphism to verify
the pre- and postconditions that are specific to the object types.
7.6 Summary
A well-designed application should contain only well-designed subclasses that
support good design principles.
The signature of a function consists of its name and the number, datatypes, and
order of its parameters. It does not include the names of its parameters.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

213
A method of a subclass overrides a method with the same signature in its
superclass. At run time, we want to call the overriding function if the object was
instantiated from the subclass.
Overloaded functions have the same name but otherwise different signatures.
In a well-designed application, a set of overloaded functions have operations
that are conceptually similar, the same, or equivalent.
It is important to understand when to use the is-a (inheritance) and the has-a
(aggregation) relationship between classes.
The Liskov Substitution Principle says that if subclasses are designed properly
with the is-a relationship, then a subclass object can substitute for a superclass
object in the code. The program will still be logically correct and continue to run.
A subclass that violates this principle can cause the program to run with logic
errors or crash.
The Favor Composition over Inheritance Principle says that there are software
design situations, where using the has-a relationship instead of the is-a
relationship results in classes and subclasses that are more flexible, better
encapsulated against changes, less complex, and more loosely coupled.
The has-a relationship can prevent hardcoding behaviors in the source code of
classes. It provides the flexibility to set object behaviors when creating the
objects at run time and to later modify the behaviors.
A factory function encapsulates object creation. It prevents hardcoding by giving
us the flexibility to determine at run time what objects to create.
The pre- and postconditions of the methods of a superclass and its subclasses
must be carefully designed so the conditions aren’t violated when those
methods are called on the superclass and subclass objects.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

214
8 The Template Method and
Strategy Design Patterns
This chapter covers
The Template Method Design Pattern
The Strategy Design Pattern
Each design pattern is an industry-proven model from which we can create a well designed solution
to a common software architecture problem. A design pattern is only a model because it is rarely a
solution we can use directly—we use it as the basis to create a custom solution to an architecture
problem in our application. This chapter covers two design patterns.
Application development, and programming in general, involves algorithms and data. The data
are the ingredients, and the algorithms are the steps of the recipe. The two design patterns in this
chapter, the Template Method Design Pattern and the Strategy Design Pattern, are models for a
software architecture that must manage multiple algorithms.
Our example application for the Template Method Design Pattern generates sports reports. The
basic outline of the reports is the same, but parts of the report differ. The example application for
the Strategy Design Pattern shows how to deploy strategies to recruit players and reserve venues
for different sports. The strategies are interchangeable, and at run time, the application can
determine which one to deploy, depending on the sport.
For each of the two patterns, we’ll have example code that doesn’t use the pattern, followed by
example code modeled by the pattern. Then, we’ll see the improvement the pattern makes.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

215
NOTE Be sure to read the introduction to part 4 for important information about design patterns in
general and to learn how this and subsequent chapters teach each pattern. In addition, in case you’re
unfamiliar with the games of baseball and volleyball, which were used in some of the examples, the
introduction includes the basics of how the games are scored.
8.1 The Template Method Design Pattern defines the steps of an
algorithm
We often use templates in real life that define the algorithms we perform daily. For example,
consider the steps to back out of a parking space in a parking lot:
1. Step on the brake.
2. Start the car.
3. Shift into reverse.
4. Step on the accelerator to back out slowly.
5. Turn the steering wheel.
6. Step on the brake.
7. Shift into drive.
8. Step on the accelerator to move forward.
No matter what make or model of car you’re driving, these are the steps and the order in which you
must follow them. Steps 1, 4, 5, 6, and 8 are likely the same for all cars. But steps 2, 3, and 7 might
be different, depending on the car. Starting the car may involve turning a key in the ignition or
pressing a start button. The gear shift lever might be located behind the steering wheel or by your
side, or shifting gears might entail a set of push buttons.
Similarly, an application might use an algorithm that has several steps in a fixed order. Some of
the steps may be common, but other steps may vary. The first several code examples in this section
will demonstrate how the Template Method Design Pattern can help solve a software architecture
problem that defines an algorithm with steps in a prescribed order, where some of the steps are
common and implemented by a superclass, but others are implemented by subclasses.
Suppose a school’s athletics department wants an application that prints a short report after
each baseball and volleyball game. The baseball report about the performance of one team during
the game consists of a text section with some statistics displayed in a text section and a graphics
section with a simple bar chart. An example of such a report is
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

216
BASEBALL GAME REPORT
Hit type
21 singles
5 doubles
3 triples
1 homers
End of report
The volleyball report includes the winner, the winning score, and how each team scored its points
during the rounds of the game. An example of such a report is
VOLLEYBALL GAME REPORT
Winner was Team 2
The winning score was 15 to 11
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

217
....5...10...15
1: 2
2: 2
3: 2
4: 1
5: 1
6: 2
7: 1
8: 2
9: 1
10: 1
11: 2
12: 1
13: 2
14: 1
15: 2
16: 2
17: 1
18: 2
19: 1
20: 2
21: 1
22: 2
23: 2
24: 2
25: 1
26: 2
End of report
The report shows which team scored during each of the 26 rounds and the running score. For
example, team 2 scored during the sixth round, after which team 1 had 2 points and team 2 had 4
points. The game ends as soon as a team has scored 15 points, so team 2 won, while team 1 ended
with only 11 points. Therefore, the winning score was 15 to 11.
NOTE The introduction to part 4 briefly describes how baseball and volleyball games are scored.
8.1.1 Desired design features
An application that produces the baseball and volleyball reports should have the following features:
DF 1—The report generation steps are in a fixed order.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

218
DF 2—Corresponding steps between the two reports that are executed the same
way should be coded the same.
DF 3—Corresponding steps between the two reports that are executed
differently will have custom code for those steps in each report.
DF 4—There is little or no duplicated code.
8.1.2 Before using the Template Method Design Pattern
Generating a game report consists of the following steps:
1. Print the report header.
2. Acquire data from the game.
3. Analyze the data.
4. Print the report.
5. Print the report footer.
Class BaseballReport has private methods that implement these steps (figure 8.1). It depends on
class BaseballData, which uses a random number generator to generate test data for the report.
(Review chapter 4 for UML diagramming standards.)
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

219
Figure 8.1 The public method generate_report() of class BaseballReport calls its private methods that
perform the steps to generate a baseball game report. It depends on class BaseballData to generate random
test data for the report.
A random number generator in class BaseballData creates realistic data for the baseball report, as
shown in the following listing. The constructor uses the function random.gauss() to generate
normally distributed integer values that represent hits (singles, doubles, triples, homers) and outs
for the team’s players during the game. It appends each hit to the private list _hits and stops after
27 outs.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

220
Listing 8.1 (Program 8.1 Reports): baseball_data.py BEFORE DESIGN PATTERN
import random
from time import time_ns
class BaseballData:
def __init__(self):
random.seed(time_ns())
self._hits = [] #A
outs = 0
while outs < 27:
hit = int(abs(random.gauss(0.0, 1.75))) #B
if hit > 4:
hit = 4
if hit != 0:
self._hits.append(hit)
else:
outs += 1
@property
def hits(self): return self._hits
#A List of randomly generated hits
#B Randomly generate a hit.
The next listing shows that public method generate_report() of class BaseballReport calls its private
methods to execute the steps in the correct order to generate a game report. Private methods
_print_header() and _print_footer() print the report’s header and footer, respectively. Private method
_acquire_data() gets the list of hits from the BaseballData object. Private method _analyze_data()
tallies the number of singles, doubles, triples, and homers. Private method _print_report() prints the
body of the game report.
Listing 8.2 (Program 8.1 Reports): baseball_report.py BEFORE DESIGN PATTERN
import matplotlib.pyplot as plt
from baseball_data import BaseballData
class BaseballReport:
def __init__(self):
self._title = 'BASEBALL GAME REPORT'
self._hits = None
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

221
self._singles = 0
self._doubles = 0
self._triples = 0
self._homers = 0
def _print_header(self):
print(self._title)
print()
def _acquire_data(self):
data = BaseballData()
self._hits = data.hits
def _analyze_data(self):
for hit in self._hits:
if hit == 1:
self._singles += 1
elif hit == 2:
self._doubles += 1
elif hit == 3:
self._triples += 1
elif hit == 4:
self._homers += 1
def _print_report(self):
print(' Hit type') #A
print(f'{self._singles:2d} singles') #A
print(f'{self._doubles:2d} doubles') #A
print(f'{self._triples:2d} triples') #A
print(f'{self._homers:2d} homers') #A
plt.bar(['singles', 'doubles', 'triples', 'homers'], #B
[self._singles, self._doubles, #B
self._triples, self._homers]) #B
plt.title('Hits During the Game')
plt.xlabel('Type of hits')
plt.ylabel('Number of hits')
plt.show()
def _print_footer(self):
print()
print('End of report')
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

222
def generate_report(self):
self._print_header() #C
self._acquire_data() #C
self._analyze_data() #C
self._print_report() #C
self._print_footer() #C
#A The text section of the report
#B The bar chart section of the report
#C Steps to generate the report
Class VolleyballReport follows the same outline of steps to print a volleyball game report (figure 8.2).
It depends on class VolleyballData, which uses a random number generator to generate test data
for the report.
Figure 8.2 The public method generate_report() of class VolleyballReport calls its private methods,
which perform the steps to generate a volleyball game report. It depends on class VolleyballData to
generate random test data for the report.
Like class BaseballData, class VolleyballData uses a random number generator function
random.randint() to generate the private list _points that the teams had accumulated by the end of
each round during a simulated game. To distinguish the two teams’ points (local variables score1
and score2), the points of the second team are made negative. The simulated game ends when one
team attains 15 points.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

223
Listing 8.3 (Program 8.1 Reports): volleyball_data.py BEFORE DP
import random
from time import time_ns
class VolleyballData:
def __init__(self):
random.seed(time_ns())
self._points = [] #A
score1 = score2 = 0
while (score1 < 15) and (score2 < 15):
if random.randint(1, 2) == 1: #B
score1 += 1
self._points.append(score1)
else:
score2 += 1
self._points.append(-score2)
@property
def points(self): return self._points
#A Accumulated randomly generated points
#B Randomly add the point for team 1 or to team 2.
Now, we can implement class VolleyballReport. In the following listing, public method
generate_report()calls its private methods to execute the same steps in the same order as method
generate_report() did in class BaseballReport. Private method _analyze_data() determines which
team won the game (is the final entry in the points list positive or negative?) and the final score.
Listing 8.4 (Program 8.1 Reports): volleyball_report.py BEFORE DP
from volleyball_data import VolleyballData
class VolleyballReport:
def __init__(self):
self._title = 'VOLLEYBALL GAME REPORT'
self._team1_is_winner = False
self._losers_score = 0
def _print_header(self):
print(self._title)
print()
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

224
def _acquire_data(self):
data = VolleyballData()
self._points = data.points
def _analyze_data(self):
self._team1_is_winner = self._points[-1] > 0 #A
for i in range(len(self._points) - 1, 0, -1): #B
if ( ( self._team1_is_winner #B
and (self._points[i] < 0)) #B
or ( not self._team1_is_winner #B
and (self._points[i] > 0)) #B
): #B
self._losers_score = abs(self._points[i]) #B
break #B
def _print_report(self):
winner = 1 if self._team1_is_winner else 2
print(f'Winner was Team {winner}')
print(f'The winning score was 15 to {self._losers_score}')
print()
print(' ....5...10...15')
for index, score in enumerate(self._points):
print(f'{index + 1:3d}:', end='')
winner = 1 if score > 0 else 2
print(f"{' '*abs(score)}{winner:1d}")
def _print_footer(self):
print()
print('End of report')
def generate_report(self):
self._print_header() #C
self._acquire_data() #C
self._analyze_data() #C
self._print_report() #C
self._print_footer() #C
#A Determine which team won.
#B Find the losing score in the _points list.
#C Steps to generate the report
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

225
The test program in main.py below can generate either a volleyball game report or a baseball game
report, depending on whether we started the program on the command line with either the -b or -v
option, respectively.
Listing 8.5 (Program 8.1 Reports): main.py BEFORE DESIGN PATTERN
import sys
from baseball_report import BaseballReport
from volleyball_report import VolleyballReport
if __name__ == '__main__':
if len(sys.argv) < 2:
print('Usage: report -b | -v')
elif sys.argv[1] == '-b':
baseball_report = BaseballReport() #A
baseball_report.generate_report() #A
else:
volleyball_report = VolleyballReport() #B
volleyball_report.generate_report() #B
#A Generate a baseball report.
#B Generate a volleyball report.
If we wanted to produce a football game report later, we would create classes FootballData and
FootballReport, and the latter would then follow the same steps.
Indeed, the main fault with this solution is
Duplicated code—In classes BaseballReport and VolleyballReport, we duplicated
the code for methods _print_header() and _print_footer() that represent
common report generation operations. Report generation follows the same
steps for each sport, so we’ve also duplicated the code for method
generate_report() in each class.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

226
8.1.3 After using the Template Method Design Pattern
The Template Method Design Pattern comes to the rescue with this architecture problem to reduce
code duplication. A superclass outlines the steps of an algorithm (to produce a game report in our
example application), and it can implement shared common steps. Subclasses manage the different
ways to implement the remaining steps. A method in the superclass, known as the template method,
calls the methods that perform the steps in the proper order (figure 8.3).
THE TEMPLATE METHOD DESIGN PATTERN
“Define the skeleton of an algorithm in an operation, deferring some steps to subclasses.
Template Method lets subclasses redefine certain steps of an algorithm without changing the
algorithm’s structure.” (GoF 325)
Figure 8.3 This version of the application is modeled from the Template Method Design Pattern. The abstract
superclass GameReport outlines the steps in the proper order for the algorithm to generate a report. It
implements the common steps _print_header() and _print_footer() and delegates the remaining steps
_acquire_data(), _analyze_data(), and _print_report() to the BaseballReport and
VolleyballReport subclasses. The public template method generate_report() in the superclass calls the
step methods in the proper order. The grayed-out portions of the diagram haven’t changed logically from
figures 8.1 and 8.2.
Using the Template Method Design Pattern to model our architecture gives us some major benefits:
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

227
Algorithm outline—The GameReport superclass sets the standard for game
report generation by declaring methods that implement the steps of the
algorithm. The template method generate_report() calls the step methods steps
in the proper order.
Reduced code duplication—Method generate_report() and the step methods
_print_header() and _print_footer() in the superclass implement common
behavior, which eliminates code duplication. This supports the Don’t Repeat
Yourself Principle (section 2.3.3). The subclasses implement the remaining step
methods.
Open-Closed Principle—Superclass GameReport follows the Open-Closed
Principle (section 2.3.3). We won’t modify it, but we can extend it with the report
subclasses.
Encapsulated steps—The report subclasses follow the Encapsulate What Varies
Principle (section 2.3.2) to encapsulate the varying steps to generate game
reports.
Cohesive and decoupled classes—Each report subclass is cohesive and decoupled
from the other report subclasses.
In the abstract superclass GameReport, method generate_report() is the template method which
outlines the steps of the report generation algorithm.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

228
Listing 8.6 (Program 8.2 Reports-TemplateDP): game_report.py
from abc import ABC, abstractmethod
class GameReport(ABC):
def __init__(self, title):
self._title = title
def _print_header(self): #A
print(self._title)
print()
def _print_footer(self): #A
print()
print('End of report')
@abstractmethod
def _acquire_data(self): pass #B
@abstractmethod
def _analyze_data(self): pass #B
@abstractmethod
def _print_report(self): pass #B
def generate_report(self): #C
self._print_header()
self._acquire_data()
self._analyze_data()
self._print_report()
self._print_footer()
#A Implementation of common steps
#B Steps delegated to the subclasses to implement
#C The template method outlines the steps to print a report.
Class BaseballReport is now a subclass of GameReport. It only needs to implement methods
_acquire_data(), _analyze_data(), and _print_report() which are specific for baseball game reports.
The implementations of these methods are unchanged from listing 8.2.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

229
Listing 8.7 (Program 8.2 Reports-TemplateDP): baseball_report.py
import pandas as pd
import matplotlib.pyplot as plt
from game_report import GameReport
from baseball_data import BaseballData
class BaseballReport(GameReport):
def __init__(self):
super().__init__('BASEBALL GAME REPORT')
self._singles = 0
self._doubles = 0
self._triples = 0
self._homers = 0
def _acquire_data(self): ... #A
def _analyze_data(self): ... #A
def _print_report(self): ... #A
#A Steps specific to baseball game reports
The same is true for class VolleyballReport. The implementations of methods acquire_data(),
analyze_data(), and print_report() are unchanged from listing 8.3.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

230
Listing 8.8 (Program 8.2 Reports-TemplateDP): volleyball_report.py
from game_report import GameReport
from volleyball_data import VolleyballData
class VolleyballReport(GameReport):
def __init__(self):
super().__init__('VOLLEYBALL GAME REPORT')
self._team1_is_winner = False
self._losers_score = 0
def _acquire_data(self): ... #A
def _analyze_data(self): ... #A
def _print_report(self): ... #A
#A Steps specific to volleyball game reports
Classes VolleyballData and BaseballData are unchanged. The same test program (listing 8.5) prints
the same types of reports as in the previous version.
8.1.4 Template Method’s generic model
Figure 8.4 shows the generic model of the Template Method Design Pattern. It is from a design
pattern’s generic model that we can create a custom solution to an architecture problem.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

231
Figure 8.4 The generic model of the Template Method Design Pattern. We can compare it with figure 8.3. The
methods of the abstract superclass AlgorithmOutline outlines the steps of the algorithm. Method
template_method() calls the methods representing the steps in the correct order. The superclass implements
the common steps and delegates implementing the varying steps to its concrete subclasses. Table 8.1 shows
how the example application applies the pattern.
DESIGN PATTERN GENERIC MODEL
It is from a design pattern’s generic model that we can create a custom solution to an
architecture problem. Remember that a design pattern is not copy-and-paste code or code
included from a library. Once we’ve identified a problem for which an appropriate design
pattern can model a solution, we must tailor the solution to solve the specific problem in our
application.
Experience teaches us to recognize whether an architecture problem can be solved by a
design pattern and whether its benefits make its use worthwhile.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

232
Table 8.1 The Template Method Design Pattern as applied by the example application
Design pattern Applied by the example application
Client class Main
Superclass AlgorithmOutline Superclass GameReport
Subclass ConcreteAlgorithm Subclasses BaseballReport and VolleyballReport
template_method() generate_report()
Common steps _print_header() and _print_footer()
Varying steps _acquire_data(), _analyze_data(), and _print_report()
8.2 The Strategy Design Pattern encapsulates algorithms
With the next design pattern, we continue the theme of an application that must manage multiple
algorithms, but we’ll do it in a somewhat different way. The Strategy Design Pattern provides a
model for a software architecture problem that involves a family of algorithms, or several variants
of an algorithm, that need to be interchangeable at run time.
For this architecture problem, the Strategy Design Pattern provides a model for a solution that
encapsulates each algorithm or algorithm variant, reduces code duplication, and allows us to
modify the algorithms independently.
HARDCODING VS. RUNTIME FLEXIBILITY
Hardcoding refers to the code we’ve written in the source file. When we hardcode, we make
decisions when we write the code about how the program will behave at run time. Once
we’ve hardcoded, we can’t make changes to the program’s behavior without modifying the
code. This may also require extensive retesting and rewriting documentation.
Many of the design patterns provide models for software architectures that have runtime
flexibility so that the application can make behavior decisions when running. For example,
the Strategy Design Pattern enables an application to choose which algorithm to use based
on a logical decision. Our testing and documentation should cover all the algorithms before
we deploy the application. A well-designed architecture can also minimize code changes if we
later add new algorithms or modify existing ones.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

233
To demonstrate the Strategy Design Pattern with a concrete example, we’ll start with an application
that involves three sports: baseball, football, and volleyball. For each sport, we need to execute an
algorithm to recruit players and an algorithm to reserve a venue.
8.2.1 Desired design features
An application that has different algorithms for recruiting players and reserving venues for the
three sports should have the following features:
DF 1—Each sport should implement code for both algorithms.
DF 2—It should be straightforward to add or delete sports.
DF 3—It should be straightforward to add, delete, or modify algorithms for the
sports.
DF 4—It should be possible to make algorithm choices at run time.
DF 5—It should be possible for sports to share algorithms, such as one for
reserving a particular venue.
8.2.2 Before using the Strategy Design Pattern
The first version of the application is simple and straightforward (figure 8.5).
Figure 8.5 The first version of our sports application. Superclass class Sport has abstract methods
representing algorithms that each of the subclasses Baseball, Football, and Volleyball must implement
to recruit players and reserve a venue.
Superclass Sport has abstract methods recruit_players() and reserve_venue() that invoke the two
algorithms. Subclasses Baseball, Football, and Volleyball each must implement these methods.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

234
Listing 8.9 (Program 8.3 Sports): sport.py BEFORE THE DESIGN PATTERN
from abc import ABC, abstractmethod
class Sport(ABC):
_SPORT_TYPE = ''
@property
def SPORT_TYPE(self): return self._SPORT_TYPE
@abstractmethod
def recruit_players(self): pass #A
@abstractmethod
def reserve_venue(self): pass #A
#A To be implemented by subclasses
To keep this example application simple, each algorithm simply returns a descriptive string, as
shown in the following listing. In an actual application, the algorithms of a family can have more
complex behaviors.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

235
Listing 8.10 (Program 8.3 Sports): sports.py BEFORE THE DESIGN PATTERN
from sport import Sport
class Baseball(Sport):
_SPORT_TYPE = 'BASEBALL'
def recruit_players(self):
return 'baseball players'
def reserve_venue(self):
return 'stadium'
class Football(Sport):
_SPORT_TYPE = 'FOOTBALL'
def recruit_players(self):
return 'football players'
def reserve_venue(self):
return 'stadium'
class Volleyball(Sport):
_SPORT_TYPE = 'VOLLEYBALL'
def recruit_players(self):
return 'volleyball players'
def reserve_venue(self):
return 'open field'
Our test code in main.py generates a report for each sport.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

236
Listing 8.11 (Program 8.3 Sports) main.py BEFORE THE DESIGN PATTERN
from sports import Baseball, Football, Volleyball
def generate_report(sport):
print(sport.SPORT_TYPE)
print(f' players: {sport.recruit_players()}')
print(f' venue: {sport.reserve_venue()}')
print()
if __name__ == '__main__':
for sport in [Baseball(), Football(), Volleyball()]:
generate_report(sport)
The output is
baseball
players: baseball players
venue: stadium
football
players: football players
venue: stadium
volleyball
players: volleyball players
venue: open field
This solution relies on inheritance—Baseball, Football, and Volleyball each is-a Sport. We can spot
some serious shortcomings in this architecture design:
Duplicated code—For example, the statement return 'stadium' representing a
venue algorithm is repeated several times. This will be a major problem with
more sports or if the algorithms have more complex behaviors.
Lack of encapsulation—If, for example, the stadium is unavailable and the sports
that use it must have a different venue, we’ll need to change the code in
multiple places.
Hard-to-reuse code that ought to be shared—If another sport needs the stadium
venue, we can’t easily reuse that code without duplicating it.
Hardcoded players and venues—We will have to rewrite code to change them.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

237
8.2.3 After using the Strategy Design Pattern
The Strategy Design Pattern provides a model that we can use to solve this architecture problem
(figure 8.6). This solution relies on composition—has-a relationships—for the two families of
algorithms. The algorithms are organized as superclasses and subclasses. Class Sport uses
aggregation and the Code to the Interface Principle (section 2.3.3) with the PlayerStrategy and
VenueStrategy interfaces. Class Sport has-a player algorithm family referenced by instance variable
player_strategy, and it has-a venue algorithm family referenced by instance variable venue_strategy.
The Strategy Design Pattern calls each algorithm a strategy, so these names are appropriate. Each
of the Sport subclasses Baseball, Football, and Volleyball is now much simpler.
THE STRATEGY DESIGN PATTERN
“Define a family of algorithms, encapsulate each one, and make them interchangeable.
Strategy lets the algorithm vary independently from clients that use it.” (GoF 315)
Figure 8.6 This version of the application is modeled from the Strategy Design Pattern for the sport teams and
venues. The player family of algorithms implement the PlayerStrategy interface, and the venue family of
algorithms implement the VenueStrategy interface. Class Sport uses has-a relationships to aggregate the
algorithms. Each player and venue algorithm has a strategy() method. The Baseball, Football, and
Volleyball subclasses are now much simpler, and each one sets the _SPORT_TYPE, _player_strategy and
_venue_strategy instance variables of the Sport superclass.
Advantages of applying the Strategy Design Pattern include the following:
Reusable shared code—For example, subclass Stadium follows the Don’t Repeat
Yourself Principle (section 2.2.3). Both the baseball and football teams play in
the stadium.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

238
Encapsulated algorithms—It will be possible to make changes to the
interchangeable algorithms in the classes that implement PlayerStrategy and
VenueStrategy interfaces without modifying the other classes. This is the
Encapsulates What Varies Principle (section 2.3.2).
The Open-Closed Principle—Superclass Sport is closed to changes, but we can
extend it with subclasses. We can add and remove sports without affecting the
superclass.
Favor has-a over is-a—Class Sport aggregates the strategy classes such as
BaseballPlayers and Stadium rather than rely on its subclasses to implement the
strategies (section 7.3). Class Sport uses the Code to the Interface Principle
(section 2.3.3) since its instance variables player_strategy and venue_strategy
reference the strategy interfaces PlayerStrategy and VenueStrategy,
respectively.
Runtime flexibility—The application can supply strategies for the sports during
run time rather than hardcoding them. For example, a Volleyball object’s venue
strategy can change from OpenField to Stadium.
Because our example application is so small to begin with, using the Strategy Design Principle can
make it more complicated by adding classes. Each strategy simply returns a descriptive string. A
more realistic application might have more strategies, and the strategies might have more
behaviors. Then, the benefits of the Strategy Design Pattern can really shine. Each strategy might
include multiple methods. We’ll see in the following listings that the creators of Sport objects
determine the superclass’s initial strategies, and they can change the strategies later during run
time.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

239
Listing 8.12 (Program 8.4 Sports-StrategyDP): sport.py
class Sport:
_SPORT_TYPE = ''
def __init__(self, player_strategy, venue_strategy):
self._player_strategy = player_strategy #A
self._venue_strategy = venue_strategy #A
@property
def SPORT_TYPE(self): return self._SPORT_TYPE
@property
def player_strategy(self): return self._player_strategy #B
@property
def venue_strategy(self): return self._venue_strategy #B
@player_strategy.setter
def player_strategy(self, ps): #C
self._player_strategy = ps
@venue_strategy.setter
def venue_strategy(self, vs): #C
self._venue_strategy = vs
def recruit_players(self):
return self._player_strategy.strategy()
def reserve_venue(self):
return self._venue_strategy.strategy()
#A Aggregate the initial player and venue strategies
#B Return the strategies.
#C Dynamically set the strategies.
As figure 8.6 shows, each strategy to recruit players implements interface PlayerStrategy, and each
must implement the strategy() method to allow superclass Sport to execute the algorithm to recruit
players. Because its subclasses set its instance variable player_strategy, class Sport follows the
Delegation Principle (section 2.3.2) by delegating to its subclasses the choice of which player
recruitment algorithm to execute.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

240
Listing 8.13 (Program 8.4 Sports-StrategyDP): player_strategy.py
from abc import ABC, abstractmethod
class PlayerStrategy(ABC):
@abstractmethod
def strategy(self): pass #A
class BaseballPlayers(PlayerStrategy):
def strategy(self):
return 'baseball players'
class FootballPlayers(PlayerStrategy):
def strategy(self):
return 'football players'
class VolleyballPlayers(PlayerStrategy):
def strategy(self):
return 'volleyball players'
#A Strategy method to be implemented by the subclasses.
Similarly, each strategy to reserve a venue implements interface VenueStrategy, and each must
implement the strategy() method that allows the superclass Sport to execute the strategy to reserve
a venue. Like with the player strategy, class Sport delegates to its subclasses the choice of which
algorithm to execute when they set instance variable venue_strategy.
Listing 8.14 (Program 8.4 Sports-StrategyDP): venue_strategy.py
from abc import ABC, abstractmethod
class VenueStrategy(ABC):
@abstractmethod
def strategy(self): pass #A
class Stadium(VenueStrategy):
def strategy(self):
return 'stadium'
class OpenField(VenueStrategy):
def strategy(self):
return 'open field'
#A Strategy method to be implemented by the subclasses.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

241
In this example application, each player and venue strategy consists of only a method that returns a
descriptive string.
Each Sport subclass sets the initial strategies appropriately. For example, when we instantiate a
Baseball object, its constructor calls the constructor of superclass Sport to set _player_strategy to
BaseballPlayers and _venue_strategy to Stadium.
Listing 8.15 (Program 8.4 Sports-StrategyDP): sports.py
from sport import Sport
from player_strategy import BaseballPlayers, FootballPlayers, \
VolleyballPlayers
from venue_strategy import Stadium, OpenField
class Baseball(Sport):
_SPORT_TYPE = 'BASEBALL'
def __init__(self):
super().__init__(BaseballPlayers(), #A
Stadium()) #A
class Football(Sport):
_SPORT_TYPE = 'FOOTBALL'
def __init__(self):
super().__init__(FootballPlayers(), #B
Stadium()) #B
class Volleyball(Sport):
_SPORT_TYPE = 'VOLLEYBALL'
def __init__(self):
super().__init__(VolleyballPlayers(), #C
OpenField()) #C
#A Initial baseball strategies
#B Initial football strategies
#C Initial volleyball strategies
Class Sport will not need to change if we add new Sport subclasses. We can use the Open-Closed
Principle (section 2.3.3) and close superclass Sport for modification. Each Sport subclass initializes
the strategies, but now we have the flexibility to change a strategy at run time by calling a setter
function.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

242
Listing 8.16 (Program 8.4 Sports-StrategyDP): main.py
from sports import Baseball, Football, Volleyball
from venue_strategy import Stadium
def generate_report(sport):
print(sport.SPORT_TYPE)
print(f' players: {sport.recruit_players()}')
print(f' venue: {sport.reserve_venue()}')
print()
if __name__ == '__main__':
for sport in [Baseball(), Football(), Volleyball()]:
generate_report(sport)
volleyball = Volleyball() #A
volleyball.venue_strategy = Stadium() #A
generate_report(volleyball)
#A Dynamically change volleyball’s venue strategy.
The output shows that now it is possible to change a strategy at run time.
BASEBALL
players: baseball players
venue: stadium
FOOTBALL
players: football players
venue: stadium
VOLLEYBALL
players: volleyball players
venue: open field
VOLLEYBALL
players: volleyball players
venue: stadium
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

243
Indeed, design patterns help ensure that we use good design principles. The patterns simplify the
software design process and facilitate design meetings among the developers.
8.2.4 Strategy’s generic model
Figure 8.7 shows the generic model of the Strategy Design Pattern. It is from a design pattern’s
generic model that we can create a custom solution to an architecture problem.
Figure 8.7 The generic model of the Strategy Design Pattern. Compare to figure 8.6. Table 8.2 shows how the
example application applies the pattern.
Table 8.2 The Strategy Design Pattern as applied by the example application
Design pattern Applied by the example application
Class Client Superclass Sport
Superclass Strategy Interfaces PlayerStrategy and VenueStrategy
Subclasses Strategy1, Strategy2, etc. Classes BaseballPlayers, FootballPlayers,
VolleyballPlayers, Stadium, and OpenField
algorithm() strategy() methods
strategy->algorithm() _player_strategy.strategy()
_venue_strategy.strategy()
8.3 Choose between Template Method and Strategy
The Template Method Design Pattern and the Strategy Design Pattern have a similar goal—to
encapsulate algorithms. Their main differences are the following:
Template Method relies on inheritance, the is-a relationship. The outline of
algorithm is in the superclass, and the encapsulated parts of the algorithm are
in subclasses. Template Method allows the superclass to implement common
steps of the algorithm.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

244
Strategy aggregates whole algorithms and makes them interchangeable. It uses
composition, the has-a relationship. The Strategy subclasses (the PlayerStrategy
and VenueStrategy) are composed by the Client class (superclass Sport).
In the Strategy model, the Client class is loosely coupled from the Strategy
subclasses. We can add, remove, or update the subclasses later.
We must decide which design pattern to use, depending on the application’s needs and
architecture.
8.4 Summary
The Template Method Design Pattern defines the skeleton or outline of an
algorithm and defers the implementation of some of the steps to subclasses. It
lets subclasses redefine certain steps of an algorithm without changing the
algorithm’s structure.
The Template Method Design Pattern relies on inheritance, the is-a relationship.
The Strategy Design Pattern encapsulates each algorithm in a family of
algorithms and makes them interchangeable. At run time, an application can
choose which algorithm to use.
The Strategy Design Pattern uses composition, the has-a relationship. The client
class is loosely coupled from the strategy subclasses.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

245
9 The Factory Method
and the Abstract
Factory Design Patterns
This chapter covers
The Factory Method Design Pattern
The Abstract Factory Design Pattern
Chapter 8 mentioned that applications development is about algorithms and data. The two design
patterns in this chapter model ways applications can become more flexible by deploying software
factories to create objects during run time.
The Factory Method Design Pattern provides a model for creating a group of related objects. Our
example application shows how the design pattern allows a school athletic department to delegate
responsibilities to the varsity sports and intramural sports organizations. The Abstract Factory
Design Pattern goes further and provides a model for creating families of objects and prevents
mixing objects from different families. We’ll expand the example application to ensure that the
varsity sports and intramural sports organizations keep their responsibilities apart from each other.
In this chapter, we’ll again develop the example application incrementally. We’ll adapt the
appropriate patterns one at a time to model solutions to the architecture design problems as we
encounter them.
LEARNING ABOUT DESIGN PATTERNS Be sure to read the introduction to Part 4 for important
information about design patterns in general and to learn how this and subsequent chapters teach
each pattern.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

246
9.1 The Factory Method Design Pattern lets subclasses create
objects
A common software architecture problem involves a group of related objects. For example, suppose
we’re developing an application for a manufacturer of automobile engines for Ford and GM cars.
The manufacturer only works on engines for one type of car at a time. But it doesn’t always know
ahead of time which type it will work on. Then there’s the possibility that another car manufacturer
may later ask it to make engines. Should we have an EngineManufacturer class that manages the
engines for all types of cars and decides which ones to make? Should it have subclasses? How easy
would it be to add another type of car and its engines? The Factory Method Design Pattern provides
a model for encapsulating object creation by delegating their creation to subclasses.
For a concrete example, let’s expand our example sports application to include an AthleticsDept
class that manages two categories of sports, varsity and intramural. The class will also be
responsible for generating the sport report.
9.1.1 Desired design features
DF 1: Similar to our Strategy Design Pattern example in chapter 8, each sport
will be responsible for recruiting players and acquiring a venue.
DF 2: The AthleticsDept class manages the sports teams without the danger of
accidentally mixing up its responsibilities for the varsity and intramural teams.
DF 3: It should be easy to add categories and sports, such as club sports.
9.1.2 Before using Factory Method
Figure 9.1 shows our first design for the application. Classes PlayerStrategy and VenueStrategy don’t
change from the Strategy Design Pattern example (program 8.4, figure 8.6). But now we have varsity
and intramural categories with varsity and intramural players.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

247
Figure 9.1 Class AthleticsDept generates the report for varsity and intramural sports. The grayed-out
portions of the diagram haven’t changed logically from figure 8.6.
Interface PlayerStrategy hasn't changed, but it has new varsity and intramural player classes that
implement it (listing 9.1). Each must implement method strategy(). There are no changes to
interface VenueStrategy and the classes that implement it.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

248
Listing 9.1 [Program 9.1 Provisions] player_strategy.py (before the design pattern)
from abc import ABC, abstractmethod
class PlayerStrategy(ABC):
@abstractmethod
def strategy(self):
pass
class VarsityBaseballPlayers(PlayerStrategy):
def strategy(self):
return 'varsity baseball players'
class VarsityFootballPlayers(PlayerStrategy):
def strategy(self):
return 'varsity football players'
class IntramuralBaseballPlayers(PlayerStrategy):
def strategy(self):
return 'intramural baseball players'
class IntramuralFootballPlayers(PlayerStrategy):
def strategy(self):
return 'intramural football players'
class IntramuralVolleyballPlayers(PlayerStrategy):
def strategy(self):
return 'intramural volleyball players'
Superclass Sport uses enumeration classes Category and SportType, and it has class variables
_CATEGORY and _SPORT_TYPE to record a Sport subclass’s category and type of sport, respectively.
A Sport subclass object will be initialized with its player strategy and its venue strategy.
Listing 9.2 [Program 9.1 Provisions] sport.py (before the design pattern)
from enum import Enum
class Category(Enum):
VARSITY = 1
INTRAMURAL = 2
def __str__(self): return self.name
class SportType(Enum):
BASEBALL = 1
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

249
FOOTBALL = 2
VOLLEYBALL = 3
def __str__(self): return self.name
class Sport:
_CATEGORY = None
_SPORT_TYPE = None
def __init__(self, player_strategy, venue_strategy):
self._player_strategy = player_strategy
self._venue_strategy = venue_strategy
@property
def CATEGORY(self): return self._CATEGORY
@property
def SPORT_TYPE(self): return self._SPORT_TYPE
@property
def player_strategy(self): return self._player_strategy
@property
def venue_strategy(self): return self._venue_strategy
@player_strategy.setter
def player_strategy(self, ps):
self._player_strategy = ps
@venue_strategy.setter
def venue_strategy(self, vs):
self._venue_strategy = vs
def recruit_players(self):
return self._player_strategy.strategy()
def reserve_venue(self):
return self._venue_strategy.strategy()
Class Sport has new subclasses, one for each varsity and intramural sport (listing 9.3). The varsity
teams play in the stadium, but unfortunately, the intramural teams are relegated to the open field.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

250
Listing 9.3 [Program 9.1 Provisions] sports.py (before the design pattern)
from sport import Category, SportType, Sport
from player_strategy import VarsityBaseballPlayers, \
VarsityFootballPlayers, \
IntramuralBaseballPlayers, \
IntramuralFootballPlayers, \
IntramuralVolleyballPlayers
from venue_strategy import Stadium, OpenField
class VarsityBaseball(Sport):
_CATEGORY = Category.VARSITY
_SPORT_TYPE = SportType.BASEBALL
def __init__(self):
super().__init__(VarsityBaseballPlayers(),
Stadium())
class VarsityFootball(Sport):
_CATEGORY = Category.VARSITY
_SPORT_TYPE = SportType.FOOTBALL
def __init__(self):
super().__init__(VarsityFootballPlayers(),
Stadium())
class IntramuralBaseball(Sport):
_CATEGORY = Category.INTRAMURAL
_SPORT_TYPE = SportType.BASEBALL
def __init__(self):
super().__init__(IntramuralBaseballPlayers(),
OpenField())
class IntramuralFootball(Sport):
_CATEGORY = Category.INTRAMURAL
_SPORT_TYPE = SportType.FOOTBALL
def __init__(self):
super().__init__(IntramuralFootballPlayers(),
OpenField())
class IntramuralVolleyball(Sport):
_CATEGORY = Category.INTRAMURAL
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

251
_SPORT_TYPE = SportType.VOLLEYBALL
def __init__(self):
super().__init__(IntramuralVolleyballPlayers(),
OpenField())
Class AthleticsDept is responsible for generating the sport report (listing 9.4).
Listing 9.4 [Program 9.1 Provisions] athletics_dept.py (before the design pattern)
from sport import Category, SportType
from sports import VarsityBaseball, VarsityFootball, \
IntramuralBaseball, IntramuralFootball, \
IntramuralVolleyball
class AthleticsDept:
def generate_report(self, which):
sport = None
match which:
case [Category.VARSITY, SportType.BASEBALL]:
sport = VarsityBaseball()
case [Category.VARSITY, SportType.FOOTBALL]:
sport = VarsityFootball()
case [Category.INTRAMURAL, SportType.BASEBALL]:
sport = IntramuralBaseball()
case [Category.INTRAMURAL, SportType.FOOTBALL]:
sport = IntramuralFootball()
case [Category.INTRAMURAL, SportType.VOLLEYBALL]:
sport = IntramuralVolleyball()
print(f'{sport.CATEGORY} {sport.SPORT_TYPE}')
print(f' players: {sport.recruit_players()}')
print(f' venue: {sport.reserve_venue()}')
print()
To set its local variable sport, method generate_report() uses a match statement on parameter
which, whose value will be a tuple such as [Category.VARSITY, SportType.BASEBALL] containing a
category and a sport type.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

252
A long sequence of case patterns in a match statement can result in code that’s error prone.
Listing 9.5 is the test program for this version of the application.
Listing 9.5 [Program 9.1 Provisions] main.py (before the design pattern)
from sport import Category, SportType
from athletics_dept import AthleticsDept
if __name__ == '__main__':
dept = AthleticsDept()
dept.generate_report([Category.VARSITY, SportType.BASEBALL])
dept.generate_report([Category.VARSITY, SportType.FOOTBALL])
dept.generate_report([Category.INTRAMURAL, SportType.BASEBALL])
dept.generate_report([Category.INTRAMURAL, SportType.FOOTBALL])
dept.generate_report([Category.INTRAMURAL, SportType.VOLLEYBALL])
The output is
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

253
VARSITY BASEBALL
players: varsity baseball players
venue: stadium
VARSITY FOOTBALL
players: varsity football players
venue: stadium
INTRAMURAL BASEBALL
players: intramural baseball players
venue: open field
INTRAMURAL FOOTBALL
players: intramural football players
venue: open field
INTRAMURAL VOLLEYBALL
players: intramural volleyball players
venue: open field
We can readily recognize some notable shortcomings of this architecture.
Many patterns in a match statement can be awkward and error prone.
Not encapsulating the potentially changing code means we would have to
modify the AthleticsDept class’s generate_report() method if we add or remove
sports or add a new sports category, such as club sports.
Multiple responsibilities for class AthleticsDept. Besides generating the report,
it must also create the Sport objects.
9.1.3 After using Factory Method
The Factory Method Design Pattern helps to alleviate these and other shortcomings. It uses the
Factory Principle (section 7.4) in a specific architectural pattern. We want to encapsulate creating
the Sport objects and remove that responsibility from class AthleticsDept.
Following the pattern, we make AthleticsDept abstract with two subclasses, VarsityDept and
IntramuralDept (figure 9.2). It has an abstract static method create_sport(). Each of the two
subclasses serves as a factory class. Subclass VarsityDept implements create_sport() which creates
and returns a varsity Sport object. Subclass IntramuralDept implements create_sport() which
creates and returns an intramural Sport object. Therefore, each create_sport() is a factory method.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

254
THE FACTORY METHOD DESIGN PATTERN
“Define an interface for creating an object, but let subclasses decide which class to
instantiate. Factory Method lets a class defer instantiation to subclasses.” [GoF 107]
Figure 9.2 This version of the application is modeled from the Factory Method Design Pattern. Superclass
AthleticsDept delegates creating Sport objects to its subclasses. Subclasses VarsityDept and
IntramuralDept are factory classes. Each implements the factory function create_sport() which creates
and returns an appropriate varsity or intramural Sport object. The grayed-out portions of the diagram have not
changed logically from figure 9.1.
Figure 9.2 shows some of the advantages of this revised architecture:
Encapsulated changes make it easier to add new categories, such as club
sports. This is the Encapsulate What Varies design principle (section 2.3.2).
The Open-Closed Principle allows class AthleticsDept to remain stable (section
2.3.3) for generating reports with its generate_report() method. We can extend
the class by adding more subdepartments such as club sports, but the class is
closed to further modification.
Use of factory classes in the form of the two subclasses VarsityDept and
IntramuralDept which handle the varsity and intramural sports categories,
respectively. Class AthleticsDept follows the Delegation Principle (section 2.3.2)
by delegating creating Sport objects to these subclasses. It will be easier to vary
the sports of the two categories.
Cohesive classes. Each of the AthleticsDept subclasses follows the Single
Responsibility Principle (section 2.3) and is responsible only for creating its sport
objects. This also eliminates the need for nested switch statements.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

255
Loosely coupled classes. The AthleticsDept subclasses are no longer
dependent on the implementation of the Sport subclasses. This is the Principle
of Least Knowledge (section 2.3.2).
Abstract class AthleticsDept and has two concrete subclasses VarsityDept and IntramuralDept
which are factory classes (listing 9.7). Each subclass implements the virtual method create_sport(),
the factory method, to create and return a varsity or an intramural Sport object, respectively.
Listing 9.6 [Program 9.2 Provisions-FactoryDP] athletics_dept.py
from abc import abstractstaticmethod
from sport import SportType
from sports import VarsityBaseball, VarsityFootball, \
IntramuralBaseball, IntramuralFootball, \
IntramuralVolleyball
class AthleticsDept:
@abstractstaticmethod
def create_sport(self, sport_type): #A
pass
def generate_report(self, sport_type):
sport = self.create_sport(sport_type)
print(f'{sport.CATEGORY} {sport.SPORT_TYPE}')
print(f' players: {sport.recruit_players()}')
print(f' venue: {sport.reserve_venue()}')
print()
class VarsityDept(AthleticsDept):
def create_sport(self, sport_type): #B
match sport_type:
case SportType.BASEBALL:
return VarsityBaseball()
case SportType.FOOTBALL:
return VarsityFootball()
case _:
return None;
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

256
class IntramuralDept(AthleticsDept):
def create_sport(self, sport_type): #C
match sport_type:
case SportType.BASEBALL:
return IntramuralBaseball()
case SportType.FOOTBALL:
return IntramuralFootball()
case SportType.VOLLEYBALL:
return IntramuralVolleyball()
case _:
return None;
#A Abstract factory method.
#B Factory method for varsity sports.
#C Factory method for intramural sports.
Each factory subclass VarsityDept and IntramuralDept creates and returns an appropriate Sport
object. Therefore, superclass AthleticsDept delegates creating a Sport object to its subclasses. When
its method generate_report() calls the factory method create_sport() at run time, which sport object
is created depends on whether generate_report() was called on a VarsityDept object or an
IntramuralDept object. The match statements in the create_sport() factory methods are shorter and
simpler.
The test program (listing 9.7) for this version of the application calls method generate_report()
either on a VarsityDept object or on an IntramuralDept object. If it’s a VarsityDept object,
generate_report() calls the factory method create_sport() which uses polymorphism to create a
varsity Sport object. But if it’s an IntramuralDept object, the factory method uses polymorphism to
create an intramural Sport object.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

257
Listing 9.7 [Program 9.2 Provisions-FactoryDP] main.py
from sport import SportType
from athletics_dept import VarsityDept, IntramuralDept
if __name__ == '__main__':
varsity = VarsityDept()
varsity.generate_report(SportType.BASEBALL)
varsity.generate_report(SportType.FOOTBALL)
intramural = IntramuralDept()
intramural.generate_report(SportType.BASEBALL)
intramural.generate_report(SportType.FOOTBALL)
intramural.generate_report(SportType.VOLLEYBALL)
The output is unchanged from the previous version of the application.
9.1.4 Factory Method’s generic model
Figure 9.3 shows the generic model of the Factory Method Design Pattern. It is from a design
pattern’s generic model that we can create a custom solution to an architecture problem.
Figure 9.3 The generic model of the Factory Method Design Pattern. Compare to figure 9.2. Table 9.1 shows
how the example application applies the pattern.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

258
Table 9.1 The Factory Method Design Pattern as applied by the example application.
Design pattern Applied by the example application
class Product superclass Sport
class ConcreteProduct Sport subclasses VarsityBaseball, VarsityFootball,
IntramuralBaseball, IntramuralFootball, and
IntramuralVolleyball
class Creator superclass AthleticsDept
class ConcreteCreator subclasses VarsityDept and IntramuralDept
factory_method() methods VarsityDept.create_sport()
and IntramuralDept.create_sport()
operate_on_product() method AthleticsDept.generate_report()
9.2 The Abstract Factory Design Pattern creates families of objects
Let’s think back to our example of the automobile engine manufacturer and consider how an
engine is made of many parts, and therefore the manufacturer is a creator of families of engine
parts. A Ford engine consists of one family of parts, and a GM engine consists of another family of
parts. Some parts are standard and belong to both families. But the manufacturer must neither
include Ford-only parts in a GM engine nor GM-only parts in a Ford engine. If our engine
manufacturing application must include the concept of families of objects, the Abstract Factory
Pattern provides a model to solve this architecture problem.
9.2.1 Before using Abstract Factory
We saw in the previous version of our sports application that the VarsityDept subclass and the
IntramuralDept subclass are factory classes that create Sport objects for their superclass
AthleticsDept. But logically, there is no way to prevent us from making a coding error that mixes up
the objects that the factories created. The varsity baseball team does not want to play in the open
field, and it would not be wise to have football players on the volleyball team. Can we further refine
the application to help prevent such logic errors?
If we reexamine figure 9.2, we can consider the players and venue for varsity sports to be one
family of objects, and the players and venue for intramural sports to be another family of objects.
We don’t want to mix up families — the varsity player and venue objects belong together for a
varsity sport, and the intramural player and venue objects belong together for an intramural sport.
9.2.2 After using Abstract Factory
The Abstract Factory Design Pattern provides a model for an architecture design that creates
families of objects (figure 9.4). We’ve added use of the pattern as an increment to the previous
version of the application.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

259
The abstract ProvisionsFactory class is the superclass of factory subclasses. Factory subclass
VarsityFactory creates player and venue objects from the varsity family, and factory subclass
IntramuralFactory creates player and venue objects from the intramural family. The VarsityDept
subclass of superclass AthleticsDept requires the varsity family of Sport objects, and so it must use
VarsityFactory. Similarly, the IntramuralDept subclass requires the intramural family of Sport
objects, and so it must use IntramuralFactory. The two abstract factory classes relieve VarsityDept
and IntramuralDept of the responsibility of creating objects within the appropriate families, and
neither subclass needs to have knowledge of how the factories accomplish their tasks.
THE ABSTRACT FACTORY DESIGN PATTERN
“Provide an interface for creating families of related or dependent objects without specifying
their concrete classes.” [GoF 87]
It’s all about families: the Strategy Design Pattern models a software architecture that manages a
family of algorithms, while the Abstract Factory Design Pattern models a software architecture that
creates families of objects.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

260
Figure 9.4 This version of the application is modeled from the Abstract Factory Design Pattern. Interface
ProvisionsFactory is the abstract factory. Implementor class VarsityFactory creates the varsity family of
player and venue objects, and therefore, VarsityDept uses VarsityFactory. Implementor class
IntramuralFactory creates the intramural family of player and venue objects, and therefore,
IntramuralDept uses IntramuralFactory. The grayed-out portions of the diagram have not changed
logically from figure 9.2.
How will this work? As before, the AthleticsDept subclass VarsityDept creates varsity Sport objects.
In this version of the application, the create_sport() method passes a VarsityFactory object to the
Sport constructor. The Sport constructor then uses the VarsityFactory object to create appropriate
player and venue objects from the varsity family.
Similarly, the AthleticsDept subclass IntramuralDept creates intramural Sport objects. Its
create_sport() method passes an IntramuralFactory object to the Sport constructor. The latter then
uses the IntramuralFactory object to create appropriate player and venue objects from the
intramural family.
Figure 9.4 shows some of the benefits of using the Abstract Factory Pattern.
Families kept together. Each factory subclass guarantees that the objects it
creates are from a single family.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

261
Flexible to choose which family. There is less hardcoding which makes it
possible to decide at run time whether to create the varsity or the intramural
family of objects.
Encapsulated object creation. Object creation is encapsulated in the factory
subclasses. This is the Encapsulate What Varies Principle (section 2.3.2). Each
Sport object delegates player and venue object creation to either the varsity
factory or the intramural factory.
Cohesive classes. Subclasses VarsityDept and IntramuralDept are each
responsible only to create Sport objects. By passing a VarsityFactory or
IntramuralFactory object, respectively, to the Sport constructor, they delegate
creating player and venue objects from the appropriate families. This is the
Single Responsibility Principle (section 2.3).
Loosely coupled classes. Subclasses VarsityDept and IntramuralDept are not
dependent on how the object families are created. This is the Principle of Least
Knowledge (section 2.3.2).
Listing 9.10 is the abstract factory class ProvisionsFactory and the classes VarsityFactory and
IntramuralFactory that implement the interface. These classes must implement methods
make_players() and make_venue() to create player and venue objects, respectively, within each
family.
Listing 9.8 [Program 9.3 Provisions-AbsFactoryDP] provisions_factory.py
from abc import abstractstaticmethod
from sport import SportType
from player_strategy import VarsityBaseballPlayers, \
VarsityFootballPlayers, \
IntramuralBaseballPlayers, \
IntramuralFootballPlayers, \
IntramuralVolleyballPlayers
from venue_strategy import Stadium, OpenField
class ProvisionsFactory: #A
@abstractstaticmethod
def make_players(self, player_type): #B
pass
@abstractstaticmethod
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

262
def make_venue(self): #B
pass
class VarsityFactory(ProvisionsFactory): #C
def make_players(self, sport_type):
match sport_type:
case SportType.BASEBALL:
return VarsityBaseballPlayers()
case SportType.FOOTBALL:
return VarsityFootballPlayers()
case _:
return None;
def make_venue(self):
return Stadium()
class IntramuralFactory(ProvisionsFactory): #D
def make_players(self, sport_type):
match sport_type:
case SportType.BASEBALL:
return IntramuralBaseballPlayers()
case SportType.FOOTBALL:
return IntramuralFootballPlayers()
case SportType.VOLLEYBALL:
return IntramuralVolleyballPlayers()
case _:
return None;
def make_venue(self):
return OpenField()
#A Abstract factory class
#B Factory functions to be implemented by the factory subclasses
#C Factory subclass to create and return the varsity family of objects.
#D Factory subclass to create and return the intramural family of objects.
The Sport superclass delegates creating the sport’s family of player and venue objects to the
ProvisionsFactory object passed to its constructor.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

263
Listing 9.9 [Program 9.3 Provisions-AbsFactoryDP] sport.py
...
class Sport:
_CATEGORY = None
_SPORT_TYPE = None
def __init__(self, factory):
self._player_strategy = factory.make_players(self._SPORT_TYPE)
self._venue_strategy = factory.make_venue()
...
The Sport subclasses are now greatly simplified. Each only needs to specify its category and sport
type.
Listing 9.10 [Program 9.3 Provisions-AbsFactoryDP] sports.py
from sport import Sport, Category, SportType
class VarsityBaseball(Sport):
_CATEGORY = Category.VARSITY
_SPORT_TYPE = SportType.BASEBALL
class VarsityFootball(Sport):
_CATEGORY = Category.VARSITY
_SPORT_TYPE = SportType.FOOTBALL
class IntramuralBaseball(Sport):
_CATEGORY = Category.INTRAMURAL
_SPORT_TYPE = SportType.BASEBALL
class IntramuralFootball(Sport):
_CATEGORY = Category.INTRAMURAL
_SPORT_TYPE = SportType.FOOTBALL
class IntramuralVolleyball(Sport):
_CATEGORY = Category.INTRAMURAL
_SPORT_TYPE = SportType.VOLLEYBALL
In each AthleticsDept subclass VarsityDept and IntramuralDept, method create_sport() passes the
appropriate factory to the constructors of the Sport subclasses (listing 9.12).
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

264
Listing 9.11 [Program 9.3 Provisions-AbsFactoryDP] athletics_dept.py
from abc import abstractstaticmethod
from sport import SportType
from sports import VarsityBaseball, VarsityFootball, \
IntramuralBaseball, IntramuralFootball, \
IntramuralVolleyball
from provisions_factory import VarsityFactory, IntramuralFactory
class AthleticsDept:
@abstractstaticmethod
def create_sport(self, sport_type):
pass
def generate_report(self, sport_type): ...
class VarsityDept(AthleticsDept):
def __init__(self):
self._varsity_factory = VarsityFactory() #A
def create_sport(self, sport_type):
match sport_type:
case SportType.BASEBALL:
return VarsityBaseball(self._varsity_factory)
case SportType.FOOTBALL:
return VarsityFootball(self._varsity_factory)
case _:
return None;
class IntramuralDept(AthleticsDept):
def __init__(self):
self._intramural_factory = IntramuralFactory() #B
def create_sport(self, sport_type):
match sport_type:
case SportType.BASEBALL:
return IntramuralBaseball(self._intramural_factory)
case SportType.FOOTBALL:
return IntramuralFootball(self._intramural_factory)
case SportType.VOLLEYBALL:
return IntramuralVolleyball(self._intramural_factory)
case _:
return None;
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

265
#A For the varsity family of player and venue objects
#B For the intramural family of player and venue objects
There are no changes to the test program in this version of the application, and the output remains
the same.
9.2.3 Abstract Factory’s generic model
Figure 9.5 shows the generic model of the Abstract Factory Design Pattern. It is from a design
pattern’s generic model that we can create a custom solution to an architecture problem..
Figure 9.5 The generic model of the Abstract Factory Design Pattern. Compare with figure 9.4. Table 9.2 shows
how the example application applies the pattern.
© Manning Publications Co. To comment go to liveBook
Licensed to Craig Hillier <chhillier11@gmail.com>

266
Table 9.2 The Abstract Factory Design Pattern as applied by the example application.
Design pattern Applied by the example application
client superclass AthleticsDept
superclass AbstractFactory interface ProvisionsFactory
factory subclasses Factory_A , factory classes VarsityFactory and IntramuralFactory
FactoryB
methods create_product_1() , methods VarsityFactory.make_players(),
create_product_2() VarsityFactory.make_venue(),
IntramuralFactory.make_players(), and
IntramuralFactory.make_venue()
classes AbstractProduct_1 , interfaces PlayerStrategy and VenueStrategy
AbstractProduct_2
subclasses Product_A1 , classes VarsityBaseballPlayers,
Product_B1 , Product_A2 , VarsityFootballPlayers, IntramuralBaseballPlayers,
Product_B2 IntramuralFootballPlayers,
IntramuralVolleyballPlayers, Stadium, and OpenField
9.3 Summary
The Factory Method Design Pattern defines an interface for creating an object
but delegates to subclasses to decide which object to create.
The Abstract Factory Design Pattern provides an interface for creating families
of related objects. It helps to prevent coding errors that mix up objects from
different families.
© Manning Publications Co. To comment go to liveBook

